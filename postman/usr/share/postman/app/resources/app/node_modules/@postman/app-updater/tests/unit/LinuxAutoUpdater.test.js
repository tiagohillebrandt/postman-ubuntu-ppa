/* eslint-disable mocha/no-skipped-tests */
var linuxAutoUpdater = require('../../lib/autoUpdater/LinuxAutoUpdater'),
    _ = require('lodash'),
    hermes = require('@postman/hermes'),
    { expect } = require('chai'),
    sinon = require('sinon');

describe('linuxAutoUpdater', function () {
    let LinuxAutoUpdater,
        sandbox,
        options = {
            quitApp: _.noop,
            logger: {
                error: _.noop,
                info: _.noop,
                warn: _.noop
            },
            appInstallationPath: '/home/postman/Downloads/postman-app',
            appName: 'postman'
        };

    before(function () {
        LinuxAutoUpdater = new linuxAutoUpdater(options);
        sandbox = sinon.sandbox.create();
    });

    after(function () {
        sandbox.restore();
    });

    describe('downloadUpdate', function () {
        let downloadUpdateSpy;

        before(function () {
            downloadUpdateSpy = sandbox.spy(LinuxAutoUpdater, 'downloadUpdate');
        });

        after(function () {
            downloadUpdateSpy.restore();
        });

        it('should throw an error if the updateInfo.appName is empty', () => {
            let err = null,
                appName = '',
                downloadURL = 'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
                downloadDirectory = '/home/postman/Downloads/postman-app/';

            try {
                LinuxAutoUpdater.downloadUpdate(appName, downloadURL, downloadDirectory);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(downloadUpdateSpy.calledWith(appName, downloadURL, downloadDirectory));
                expect(err).to.be.instanceof(Error);
            }
        });

        it('should throw an error if the updateInfo.appName is not of type string', () => {
            let err = null,
                appName = 1,
                downloadURL = 'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
                downloadDirectory = '/home/postman/Downloads/postman-app/';

            try {
                LinuxAutoUpdater.downloadUpdate(appName, downloadURL, downloadDirectory);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(downloadUpdateSpy.calledWith(appName, downloadURL, downloadDirectory));
                expect(err).to.be.instanceof(Error);
            }
        });

        it.skip('should throw an error if the updateInfo.downloadURL is empty', () => {
            let appName = 'Postman',
                downloadURL = '',
                downloadDirectory = '/home/postman/Downloads/postman-app/';

            LinuxAutoUpdater.downloadUpdate(appName, downloadURL, downloadDirectory);
            LinuxAutoUpdater.on('error', (err) => {
                expect(downloadUpdateSpy.calledWith(appName, downloadURL, downloadDirectory));
                expect(err).to.be.instanceof(Error);
            });
        });

        it.skip('should throw an error if the updateInfo.downloadURL is not of type string', () => {
            let appName = 'Postman',
                downloadURL = 8675,
                downloadDirectory = '/home/postman/Downloads/postman-app/';

            LinuxAutoUpdater.downloadUpdate(appName, downloadURL, downloadDirectory);
            LinuxAutoUpdater.on('error', (err) => {
                expect(downloadUpdateSpy.calledWith(appName, downloadURL, downloadDirectory));
                expect(err).to.be.instanceof(Error);
            });
        });

        it.skip('should throw an error if the updateInfo.downloadDirectory is empty', () => {
            let appName = 'Postman',
                downloadURL = 'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
                downloadDirectory = '';

            LinuxAutoUpdater.downloadUpdate(appName, downloadURL, downloadDirectory);
            LinuxAutoUpdater.on('error', (err) => {
                expect(downloadUpdateSpy.calledWith(appName, downloadURL, downloadDirectory));
                expect(err).to.be.instanceof(Error);
            });
        });

        it.skip('should throw an error if the updateInfo.downloadDirectory is not of type string', () => {
            let appName = 'Postman',
                downloadURL = 'https://dl-beta.pstmn.io/download/version/6.7.0/linux_64',
                downloadDirectory = 1;

            LinuxAutoUpdater.downloadUpdate(appName, downloadURL, downloadDirectory);
            LinuxAutoUpdater.on('error', (err) => {
                expect(downloadUpdateSpy.calledWith(appName, downloadURL, downloadDirectory));
                expect(err).to.be.instanceof(Error);
            });
        });
    });

    describe.skip('cleanUp', function () {
        let loggerSpy,
            hermesClearSpy;

        beforeEach(function () {
            loggerSpy = sandbox.spy(options.logger, 'info');
            hermesClearSpy = sandbox.spy(hermes, 'clear');
        });

        afterEach(function () {
            loggerSpy.restore();
            hermesClearSpy.restore();
        });

        it('should throw an error if options(argument) is empty', () => {
            let options = {},
                expectedError = 'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out';

            LinuxAutoUpdater.cleanUp(options, (err) => {
                // function bailed out but not with error!
                expect(err).to.equal(null);
            });

            expect(loggerSpy.callCount).to.equal(1);
            expect(loggerSpy.calledWith(expectedError, options)).to.be.true;
            expect(hermesClearSpy.callCount).to.equal(0);
        });

        it('should throw an error if options have falsy values', () => {
            let options = false,
                expectedError = 'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out';

            LinuxAutoUpdater.cleanUp(options, (err) => {
                // function bailed out but not with error!
                expect(err).to.equal(null);
            });

            expect(loggerSpy.callCount).to.equal(1);
            expect(loggerSpy.calledWith(expectedError, options)).to.be.true;
            expect(hermesClearSpy.callCount).to.equal(0);
        });

        it('should throw an error if options.appInstallationPath is empty', () => {
            let options = {
                    appName: 'Postman',
                    appInstallationPath: ''
                },
                expectedError = 'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out';

            LinuxAutoUpdater.cleanUp(options, (err) => {
                // function bailed out but not with error!
                expect(err).to.equal(null);
            });

            expect(loggerSpy.callCount).to.equal(1);
            expect(loggerSpy.calledWith(expectedError, options)).to.be.true;
            expect(hermesClearSpy.callCount).to.equal(0);
        });

        it('should throw an error if options.appInstallationPath is not a string', () => {
            let options = {
                appName: 'Postman',
                appInstallationPath: 123
            };

            LinuxAutoUpdater.cleanUp(options, (err) => {
                expect(err).to.be.instanceOf(Error);
            });

            expect(hermesClearSpy.called).to.be.true;
            expect(hermesClearSpy.callCount).to.equal(1);
        });

        it('should throw an error if options.appName is empty', () => {
            let options = {
                    appName: '',
                    appInstallationPath: '/home/postman/Downloads/postman-app/'
                },
                expectedError = 'LinuxAutoUpdater~cleanUp: Missing parameters, bailing out';

            LinuxAutoUpdater.cleanUp(options, (err) => {
                // function bailed out but not with error!
                expect(err).to.equal(null);
            });

            expect(loggerSpy.callCount).to.equal(1);
            expect(loggerSpy.calledWith(expectedError, options)).to.be.true;
            expect(hermesClearSpy.callCount).to.equal(0);
        });

        it('should throw an error if options.appName is not a string', () => {
            let options = {
                appName: 123,
                appInstallationPath: '/home/postman/Downloads/postman-app/'
            };

            LinuxAutoUpdater.cleanUp(options, (err) => {
                expect(err).to.be.instanceOf(Error);
            });

            expect(hermesClearSpy.called).to.be.true;
            expect(hermesClearSpy.callCount).to.equal(1);
        });
    });

    describe('quitAndInstall', function () {
        let quitAppSpy,
            hermesSwapSpy;

        before(function () {
            quitAppSpy = sinon.spy(options, 'quitApp');
            hermesSwapSpy = sinon.spy(hermes, 'swap');
        });

        after(function () {
            quitAppSpy.restore();
            hermesSwapSpy.restore();
        });

        it('should throw an error if updateInfo is empty', () => {
            let err = null,
                updateInfo = {};

            try {
                LinuxAutoUpdater.quitAndInstall(updateInfo);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(hermesSwapSpy.callCount).to.equal(1);
                expect(quitAppSpy.callCount).to.equal(0);
                expect(err).to.be.instanceof(Error);
            }
        });

        it('should throw an error if updateInfo is not an object', () => {
            let err = null,
                updateInfo = 'foo';

            try {
                LinuxAutoUpdater.quitAndInstall(updateInfo);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(hermesSwapSpy.callCount).to.equal(2);
                expect(quitAppSpy.callCount).to.equal(0);
                expect(err).to.be.instanceof(Error);
            }
        });

        it('should throw an error if updateInfo.eId is empty', () => {
            let err = null,
                updateInfo = {
                    eID: '',
                    packageName: 'somePackage',
                    downloadURL: 'http://sample.com/foo.tar.gz',
                    downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
                    downloadChecksumAlgorithm: 'sha1',
                    downloadInfo: {
                        status: 'DOWNLOAD_COMPLETED',
                        error: null,
                        downloadDirectory: 'User/PathForDownloadDirectory'
                    },
                    extractInfo: {
                        status: 'EXTRACTION_SUCCESSFUL',
                        error: null,
                        extractDirectory: 'User/PathForExtractDirectory'
                    }
                };

            try {
                LinuxAutoUpdater.quitAndInstall(updateInfo);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(hermesSwapSpy.callCount).to.equal(3);
                expect(quitAppSpy.callCount).to.equal(0);
                expect(err).to.be.instanceof(Error);
            }
        });

        it('should throw an error if updateInfo.packageName is empty', () => {
            let err = null,
                updateInfo = {
                    eID: 'somePackage-xxxxxxxxxxxxx',
                    packageName: '',
                    downloadURL: 'http://sample.com/foo.tar.gz',
                    downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
                    downloadChecksumAlgorithm: 'sha1',
                    downloadInfo: {
                        status: 'DOWNLOAD_COMPLETED',
                        error: null,
                        downloadDirectory: 'User/PathForDownloadDirectory'
                    },
                    extractInfo: {
                        status: 'EXTRACTION_SUCCESSFUL',
                        error: null,
                        extractDirectory: 'User/PathForExtractDirectory'
                    }
                };

            try {
                LinuxAutoUpdater.quitAndInstall(updateInfo);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(hermesSwapSpy.callCount).to.equal(4);
                expect(quitAppSpy.callCount).to.equal(0);
                expect(err).to.be.instanceof(Error);
            }
        });

        it('should throw an error if updateInfo.extractInfo is empty', () => {
            let err = null,
                updateInfo = {
                    eID: 'somePackage-xxxxxxxxxxxxx',
                    packageName: 'somePackage',
                    downloadURL: 'http://sample.com/foo.tar.gz',
                    downloadChecksum: '2927b7c6ed350687446b7eba58bd74535afd411b',
                    downloadChecksumAlgorithm: 'sha1',
                    downloadInfo: {
                        status: 'DOWNLOAD_COMPLETED',
                        error: null,
                        downloadDirectory: 'User/PathForDownloadDirectory'
                    },
                    extractInfo: {}
                };

            try {
                LinuxAutoUpdater.quitAndInstall(updateInfo);
            }
            catch (e) {
                err = e;
            }
            finally {
                expect(hermesSwapSpy.callCount).to.equal(5);
                expect(quitAppSpy.callCount).to.equal(0);
                expect(err).to.be.instanceof(Error);
            }
        });
    });
});
