const http = require('http'),
      https = require('https'),
      fs = require('fs'),
      crypto = require('crypto'),
      { exec } = require('child_process');

/**
 * Returns an appropriate requester depending on the protocol of the url.
 * Supported requester are: http and https
 * @param {String} url
 */
function getRequesterForUrl(url) {
  if (typeof url !== 'string' || url === '') {
    return null;
  }
  // If it is a https request, use the https module.
  else if (url.startsWith('https://')) {
    return https;
  }
  // If it is a http request, use the http module.
  else if (url.startsWith('http://')) {
    return http;
  }
  return null;
}

/**
 * Returns sha-1 for a given file
 * @param {String} filePath
 */
function getChecksumForFile(filePath, callback, options = {}) {
  const { algorithm = 'sha1' } = options;

  if (!callback) {
    throw new Error('InvalidArgumentException: Hermes~util~checksum required parameter \'callback\'');
  }

  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~util~checksum required parameter \'callback\' should be of type function');
  }

  if (typeof filePath !== 'string') {
    callback(new Error('InvalidArgumentException: Hermes~util~checksum required parameter \'filePath\' must be a string'));
  }
  if (filePath === '') {
    callback(new Error('InvalidArgumentException: Hermes~util~checksum \'filePath\' cannot be empty'));
  }

  try {
    const stats = fs.statSync(filePath);
    if (!stats.isFile()) {
      return callback(new Error(`InvalidArgumentException: Hermes~util~checksum '${filePath}' is not a file`));
    }
  }
  catch (e) {
    return callback(new Error(`InvalidArgumentException: Hermes~util~checksum File not found '${filePath}'`));
  }

  // Algorithm depends on availability of OpenSSL on platform
  // Another algorithms: 'sha1', 'md5', 'sha256', 'sha512' ...
  const shasum = crypto.createHash(algorithm);
  const s = fs.ReadStream(filePath);
  s.on('data', (data) => {
    shasum.update(data);
  });
  // making digest
  s.on('end', () => {
    const hash = shasum.digest('hex');
    callback(null, hash);
  });
  s.on('error', (error) => {
    callback(error);
  });
}

/**
 * Download a resource from given URL to a destination
 * @param {String} url URL from where to download the resource
 * @param {String} destination Destination where the resource should be downloaded
 * @param {Function} callback Callback that will be called after download is finished
 */
function downloadFile(url, destination, callback) {
  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~util~download required parameter \'callback\' must be a function');
  }
  if (typeof url !== 'string') {
    callback(new Error('InvalidArgumentException: Hermes~util~download required parameter \'url\' must be a string'));
    return;
  }
  if (url === '') {
    callback(new Error('InvalidArgumentException: Hermes~util~download \'url\' cannot be empty'));
    return;
  }
  if (typeof destination !== 'string') {
    callback(new Error('InvalidArgumentException: Hermes~util~download required parameter \'destination\' must be a string'));
    return;
  }
  if (destination === '') {
    callback(new Error('InvalidArgumentException: Hermes~util~download \'destination\' cannot be empty'));
    return;
  }

  const requester = getRequesterForUrl(url);
  if (!requester) {
    callback(new Error('InvalidArgumentException: Hermes~util~download Invalid protocol information in URL, only https and http are supported'));
    return;
  }

  requester.get(url, (response) => {
    const statusCode = response && response.statusCode;
    let file = null;

    if (statusCode !== 200) {
      const error = new Error(`InvalidResponseException: Hermes~util~download Expected to get status 200 but received ${statusCode}`);
      callback(error);
      return;
    }

    file = fs.createWriteStream(destination);
    file.on('error', (err) => {
      file.end();
      callback(err);
    });
    response.pipe(file);

    file.on('finish', () => {
      file.close(callback);
    });
  }).on('error', (err) => {
    callback(err);
  });
}

/**
 * Extracts a compressed file
 * @param {String} filePath
 * @param {String} destinationDir
 */
function extract(filePath, destinationDir) {
  return new Promise((resolve, reject) => {
    exec(`tar -xzf ${filePath} -C ${destinationDir}`, (err) => {
      if (err) {
        return reject(err);
      }
      return resolve();
    });
  });
}

/**
 * Deletes all the files and folders in a given directory except the files and folders
 * described by given patterns
 * @param {String} rootDirectory
 * @param {Array,<String>} patterns
 * @param {Funcrion} callback
 */
function removeExcept(rootDirectory, patterns, callback) {
  if (typeof callback !== 'function') {
    throw new Error('InvalidArgumentException: Hermes~util~removeExcept required parameter \'callback\' must be a function');
  }
  if (typeof rootDirectory !== 'string') {
    return callback(new Error('InvalidArgumentException: Hermes~util~removeExcept required parameter \'rootDirectory\' must be a string'));
  }
  if (!Array.isArray(patterns)) {
    return callback(new Error('InvalidArgumentException: Hermes~util~removeExcept required parameter \'patterns\' must be an array'));
  }

  let command = `cd ${rootDirectory} && rm -rf `;
  if (patterns.length === 0) {
    command += '* .*';
  }
  else {
    command += `\`ls | egrep -v "^${patterns.join('$|^')}$"\``;
  }

  exec(command, callback);
}

module.exports = {
  getRequesterForUrl,
  getChecksumForFile,
  downloadFile,
  extract,
  removeExcept,
};
