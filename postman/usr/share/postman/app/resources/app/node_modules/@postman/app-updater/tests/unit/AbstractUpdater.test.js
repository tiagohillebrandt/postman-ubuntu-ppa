var abstractUpdater = require('../../lib/AbstractUpdater'),
    _ = require('lodash'),
    { expect } = require('chai'),
    sinon = require('sinon');

describe('AbstractUpdater', function () {
    let AbstractUpdater,
        sandbox,
        updaterOptions = {
            autoUpdater: {
                on: _.noop
            },
            adapter: {
                getLogger: function () {
                    return {
                        error: _.noop,
                        info: _.noop,
                        warn: _.noop
                    };
                }
            }
        };

    before(function () {
        AbstractUpdater = new abstractUpdater(updaterOptions);
        sandbox = sinon.sandbox.create();
    });

    after(function () {
        sandbox.restore();
    });

    describe('getFeedUrl', function () {
        let getFeedUrlSpy;

        before(function () {
            getFeedUrlSpy = sandbox.spy(AbstractUpdater, 'getFeedUrl');
        });

        it('should return a string', () => {
            const updateInfo = {
                    platform: 'LINUX',
                    version: '6.1.0',
                    updateServerDomain: 'https://dl-beta.pstmn.io/',
                    additionalParamsString: 'params'
                },
                returnVal = AbstractUpdater.getFeedUrl(updateInfo);

            expect(returnVal).to.be.a('string');
            expect(returnVal).to.be.equal('https://dl-beta.pstmn.io/update/LINUX/6.1.0/?params');
            expect(getFeedUrlSpy.called).to.equal(true);
            expect(getFeedUrlSpy.calledWith(updateInfo));
        });

        it('should throw error if the updateInfo is of type String', () => {
            let error = null,
                updateInfo = 'updateInfo';
            try {
                AbstractUpdater.getFeedUrl(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
            }
        });

        it('should throw error if the updateInfo is of type Array', () => {
            let error = null,
                updateInfo = [];
            try {
                AbstractUpdater.getFeedUrl(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
            }
        });

        it('should throw error if the updateInfo is just spaces', () => {
            let error = null,
                updateInfo = ' ';
            try {
                AbstractUpdater.getFeedUrl(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
            }
        });

        it('should throw error if the updateInfo.platform is not of type string', () => {
            let error = null,
                updateInfo = { platform: 12 };
            try {
                AbstractUpdater.getFeedUrl(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
            }
        });

        it('should call with updateInfo as an object', () => {
            let error = null,
                updateInfo = { platform: 'platform', version: 'version' };
            try {
                AbstractUpdater.getFeedUrl(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(getFeedUrlSpy.calledWith(updateInfo)).to.equal(true);
                expect(error).to.be.equal(null);
            }
        });
    });

    describe('assignUpdaterOptions', function () {
        it('should throw error if updaterOptions is null', () => {
            let error = null,
                updaterOptions = null;

            try {
                AbstractUpdater.assignUpdaterOptions(updaterOptions);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
            }
        });

        it('should not throw an error if adapter and autoUpdater property of updaterOptions have truthy value', () => {
            let error = null;
            // updaterOptions = { adapter: 'foo', autoUpdater: 'bar' };
            try {
                AbstractUpdater.assignUpdaterOptions(updaterOptions);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.equal(null);
                expect(updaterOptions).to.have.property('adapter', updaterOptions.adapter);
                expect(updaterOptions).to.have.property('autoUpdater', updaterOptions.autoUpdater);
            }
        });

        it('should throw an error if adapter and autoUpdater does not exist as a property of updaterOptions', () => {
            let error = null,
                updaterOptions = {};

            try {
                AbstractUpdater.assignUpdaterOptions(updaterOptions);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceOf(Error);
            }
        });

        it('should throw an error if adapter is empty', () => {
            let error = null,
                updaterOptions = { adapter: '', autoUpdater: 'something2' };
            try {
                AbstractUpdater.assignUpdaterOptions(updaterOptions);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceOf(Error);
            }
        });

        it('should throw an error if autoUpdater is empty', () => {
            let error = null,
                updaterOptions = { adapter: 'something', autoUpdater: '' };
            try {
                AbstractUpdater.assignUpdaterOptions(updaterOptions);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceOf(Error);
            }
        });

        it('should throw an error if adapter and autoUpdater is null', () => {
            let error = null,
                updaterOptions = { adapter: null, autoUpdater: null };
            try {
                AbstractUpdater.assignUpdaterOptions(updaterOptions);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceOf(Error);
            }
        });
    });

    describe('downloadUpdate', function () {
        it('should throw an error if updateInfo is null', () => {
            let error = null,
                updateInfo = null;
            try {
                AbstractUpdater.downloadUpdate(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
            }
        });

        it('should throw an error if updateInfo.platform is empty', () => {
            let error = null,
                updateInfo = {
                    updateServerDomain: 'domain',
                    platform: '',
                    version: '6.2.0',
                    channel: 'stage' };
            try {
                AbstractUpdater.downloadUpdate(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
                expect(updateInfo).to.have.property('updateServerDomain', updateInfo.updateServerDomain);
                expect(updateInfo).to.have.property('platform', updateInfo.platform);
                expect(updateInfo).to.have.property('version', updateInfo.version);
                expect(updateInfo).to.have.property('channel', updateInfo.channel);
            }
        });
        it('should throw error if updateInfo.version is empty', () => {
            let error = null,
                updateInfo = {
                    updateServerDomain: 'domain',
                    platform: 'Linux',
                    version: '',
                    channel: 'stage' };
            try {
                AbstractUpdater.downloadUpdate(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
                expect(updateInfo).to.have.property('updateServerDomain', updateInfo.updateServerDomain);
                expect(updateInfo).to.have.property('platform', updateInfo.platform);
                expect(updateInfo).to.have.property('version', updateInfo.version);
                expect(updateInfo).to.have.property('channel', updateInfo.channel);
            }
        });
        it('should throw error if updateInfo.updateServerDomain is empty', () => {
            let error = null,
                updateInfo = {
                    updateServerDomain: '',
                    platform: 'Linux',
                    version: '6.2.0',
                    channel: 'stage' };
            try {
                AbstractUpdater.downloadUpdate(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
                expect(updateInfo).to.have.property('updateServerDomain', updateInfo.updateServerDomain);
                expect(updateInfo).to.have.property('platform', updateInfo.platform);
                expect(updateInfo).to.have.property('version', updateInfo.version);
                expect(updateInfo).to.have.property('channel', updateInfo.channel);
            }
        });
        it('should throw error if updateInfo.channel is empty', () => {
            let error = null,
                updateInfo = {
                    updateServerDomain: 'domain',
                    platform: 'Linux',
                    version: '6.2.0',
                    channel: '' };
            try {
                AbstractUpdater.downloadUpdate(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
                expect(updateInfo).to.have.property('updateServerDomain', updateInfo.updateServerDomain);
                expect(updateInfo).to.have.property('platform', updateInfo.platform);
                expect(updateInfo).to.have.property('version', updateInfo.version);
                expect(updateInfo).to.have.property('channel', updateInfo.channel);
            }
        });

        it('should throw an error if all the properties of updateInfo is empty', () => {
            let error = null,
                updateInfo = {
                    updateServerDomain: '',
                    platform: '',
                    version: '',
                    channel: '' };
            try {
                AbstractUpdater.downloadUpdate(updateInfo);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.instanceof(Error);
                expect(updateInfo).to.have.property('updateServerDomain', updateInfo.updateServerDomain);
                expect(updateInfo).to.have.property('platform', updateInfo.platform);
                expect(updateInfo).to.have.property('version', updateInfo.version);
                expect(updateInfo).to.have.property('channel', updateInfo.channel);
            }
        });
    });

    describe('EventEmitter', function () {
        let emitterSpy;

        before(function () {
            sandbox.spy(AbstractUpdater, 'onCheckingForUpdate');
            emitterSpy = sandbox.spy(AbstractUpdater, 'emit');
        });

        after(function () {
            emitterSpy.restore();
        });

        it('should invoke event emitter', function () {
            let error = null,
                update = { appName: 'PostmanStage' };
            try {
                AbstractUpdater.onCheckingForUpdate(update);
            }
            catch (e) {
                error = e;
            }
            finally {
                expect(error).to.be.equal(null);
                expect(emitterSpy.called);
                expect(emitterSpy.callCount).to.equal(1);
            }
        });
    });
});
