const { fork } = require('child_process'), // eslint-disable-line security/detect-child-process
      { isProcessAlive } = require('./lib/helpers/process'),
      MAXIMUM_BOOT_COUNT = 10;
class PluginHost {
  constructor (options) {
    this.bootCounter = 0;
    this.host = null;
    this.hostHealthMonitor = null;
    this.options = options || {};
    this.onHostExit = this.onHostExit.bind(this);
    this.bootHost();
  }

  bootHost () {
    // Clean the old host events if available
    this.unsubscribeFromOldHost();

    // Increment the counter
    this.incrementBootCounter();

    // Check whether the boot is needed
    if (!this._canBootHost()) {
      pm.logger.error(new Error(`Trying to boot plugin host for ${this.bootCounter}th time`));
      return;
    }

    // Now boot the host process
    this.host = fork(require.resolve('./lib/host'), { env: this._getHostEnvironment() });

    this.initateHostHealthMonitor(this.host.pid);
    this.subscribeToHost();

    pm.logger.info(`PluginHost - Booted for ${this.bootCounter}th time`);
  }

  incrementBootCounter () {
    this.bootCounter++;
  }

  subscribeToHost () {
    this.host.on('message', PluginHost.onHostMessage);
    this.host.on('error', this.onHostError);
    this.host.on('exit', this.onHostExit);
  }

  unsubscribeFromOldHost () {
    let host = this.host;

    if (!host || typeof host.off !== 'function') {
      return;
    }

    // This may be needed if the host is not exited properly
    this.host.off('message', PluginHost.onHostMessage);
    this.host.off('error', this.onHostError);
    this.host.off('exit', this.onHostExit);

    // Remove the old reference
    this.host = null;
  }

  /**
     * @method initateHostHealthMonitor
     * @description It starts the setInterval to verify the child availability and re-boot if not available.
     * @param {Number} pid
     */
  initateHostHealthMonitor (pid) {
    // To makesure the method sets only one monitor on the host even when called twice or thrice
    clearInterval(this.hostHealthMonitor);
    this.hostHealthMonitor = setInterval(() => {

      // Here we need to clear our healthCheck other wise it is a waste of resource
      if (!this._canBootHost()) {
        clearInterval(this.hostHealthMonitor);
        return;
      }

      if (!isProcessAlive(pid)) {
        pm.logger.error(new Error('PluginHost - Health monitor found that host died'));
        this.bootHost();
      }
    }, 5000);
  }

  terminate () {
    // If host is still alive means kill it.
    if (this.host && !this.host.killed) {
      this.host.kill('SIGINT');
      this.terminated = true;
      this.host = null;
    }
  }

  /**
     * @method onHostExit
     * @description It will be called when the host process exit
     * @param {Integer} code
     */
  onHostExit (code) {
    pm.logger.error(new Error(`PluginHost exited with code ${code}`));
    this.bootHost();
  }

  onHostError (error) {
    pm.logger.error(new Error('PluginHost errored out', error));
    this.bootHost();
  }

  static onHostMessage (message) {
    pm.logger.info('Message from host', message);
  }

  /**
     * @private
     * @method _getHostEnvironment
     * @description returns the environment variables to be injected in the host process
     * @returns {Object}
     */
  _getHostEnvironment () {
    return this.options.env || {};
  }

  /**
     * @private
     * @method _canBootHost
     * @description It checks whether we can boot the host,
     * right now the host can be booted only if the count is less than bootCounter
     * @returns {Boolean}
     */
  _canBootHost () {
    return !this.terminated && (this.bootCounter < MAXIMUM_BOOT_COUNT);
  }
}

module.exports = PluginHost;
