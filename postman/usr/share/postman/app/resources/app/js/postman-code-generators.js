webpackJsonp([31],{

/***/ 3767:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {/* global btoa */
var _ = __webpack_require__(5285).noConflict(),
    iconvlite = __webpack_require__(5286),
    util,

    ASCII_SOURCE = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789',
    ASCII_SOURCE_LENGTH = ASCII_SOURCE.length,
    EMPTY = '';

/**
 * @module util
 * @private
 */
_.mixin(/** @lends util */ {

    /**
     * Creates an inheritance relation between the child and the parent, adding a 'super_' attribute to the
     * child, and setting up the child prototype.
     *
     * @param {Function} child - The target object to create parent references for,.
     * @param {Function} base - The parent association to assign to the provided child definition.
     * @returns {*}
     */
    inherit: function (child, base) {
        Object.defineProperty(child, 'super_', {
            value: _.isFunction(base) ? base : _.noop,
            configurable: false,
            enumerable: false,
            writable: false
        });

        child.prototype = Object.create((_.isFunction(base) ? base.prototype : base), {
            constructor: {
                value: child,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return child;
    },

    /**
     * Creates an array from a Javascript "arguments" object.
     * https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments
     *
     * @param {Array} args
     * @returns {Array.<T>}
     */
    args: function (args) {
        return Array.prototype.slice.call(args);
    },

    /**
     * Makes sure the given string is encoded only once.
     *
     * @param {String} string
     * @returns {string}
     */
    ensureEncoded: function (string) {
        // Takes care of the case where the string is already encoded.
        return encodeURIComponent(decodeURIComponent(string));
    },

    /**
     * Creates a locked property on an object, which is not writable or enumerable.
     *
     * @param {Object} obj
     * @param {String} name
     * @param {*} prop
     * @returns {*}
     */
    assignLocked: function (obj, name, prop) {
        Object.defineProperty(obj, name, {
            value: prop,
            configurable: false,
            enumerable: false,
            writable: false
        });
        return obj;
    },

    /**
     * Creates a hidden property on an object, which can be changed, but is not enumerable.
     *
     * @param {Object} obj
     * @param {String} name
     * @param {*} prop
     * @returns {*}
     */
    assignHidden: function (obj, name, prop) {
        Object.defineProperty(obj, name, {
            value: prop,
            configurable: true,
            enumerable: false,
            writable: true
        });
        return obj;
    },

    /**
     * Creates a property on an object, with the given type.
     *
     * @param {Object} obj
     * @param {String} name
     * @param {Property} Prop
     * @param {*} [fallback]
     * @returns {Prop|undefined}
     */
    createDefined: function (obj, name, Prop, fallback) {
        return _.has(obj, name) ? (new Prop(obj[name])) : fallback;
    },

    /**
     * Merges defined keys from the target object onto the source object.
     *
     * @param {Object} target
     * @param {Object} source
     * @returns {Object}
     */
    mergeDefined: function (target, source) {
        var key;

        for (key in source) {
            if (source.hasOwnProperty(key) && !_.isUndefined(source[key])) {
                target[key] = source[key];
            }
        }

        return target;
    },

    /**
     * Returns the value of a property if defined in object, else the default
     *
     * @param {Object} obj
     * @param {String} prop
     * @param {*=} def
     *
     * @returns {*}
     */
    getOwn: function (obj, prop, def) {
        return _.has(obj, prop) ? obj[prop] : def;
    },

    /**
     * Creates a clone of an object, but uses the toJSON method if available.
     *
     * @param {Object} obj
     * @returns {*}
     */
    cloneElement: function (obj) {
        return _.cloneDeepWith(obj, function (value) {
            // falls back to default deepclone if object does not have explicit toJSON().
            if (value && _.isFunction(value.toJSON)) {
                return value.toJSON();
            }
        });
    },

    /**
     * Returns the match of a value of a property by traversing the prototype
     *
     * @param {Object} obj
     * @param {String} key
     * @param {*} value
     *
     * @returns {Boolean}
     */
    inSuperChain: function (obj, key, value) {
        return obj ? ((obj[key] === value) || _.inSuperChain(obj.super_, key, value)) : false;
    },

    /**
     * Generates a random string of given length (useful for nonce generation, etc).
     *
     * @param {Number} length
     */
    randomString: function (length) {
        length = length || 6;

        var result = [],
            i;

        for (i = 0; i < length; i++) {
            result[i] = ASCII_SOURCE[(Math.random() * ASCII_SOURCE_LENGTH) | 0];
        }
        return result.join(EMPTY);
    },

    choose: function () {
        for (var i = 0, ii = arguments.length; i < ii; i++) {
            if (!_.isEmpty(arguments[i])) {
                return arguments[i];
            }
        }
    }
});

util = {
    lodash: _,

    /**
     *
     * @param {String} data
     *
     * @returns {String} [description]
     */
    btoa: ((typeof btoa !== 'function' && typeof Buffer === 'function') ? function (data) {
        return new Buffer(data).toString('base64');
    } : function (data) {
        return btoa(data);
    }), // @todo use browserify to normalise this

    /**
     * ArrayBuffer to String
     *
     * @param {ArrayBuffer} buffer
     * @returns {String}
     */
    arrayBufferToString: function (buffer) {
        var str = '',
            uArrayVal = new Uint8Array(buffer),

            i,
            ii;

        for (i = 0, ii = uArrayVal.length; i < ii; i++) {
            str += String.fromCharCode(uArrayVal[i]);
        }

        return str;
    },

    bufferOrArrayBufferToString: function (buffer, charset) {
        if (!buffer || _.isString(buffer)) {
            return buffer || '';
        }

        if (Buffer.isBuffer(buffer)) {
            if (iconvlite.encodingExists(charset)) {
                return iconvlite.decode(buffer, charset);
            }
            return buffer.toString(); // Default to utf8 if iconvlite also not supporting the charset
        }
        return util.arrayBufferToString(buffer);
    },

    bufferOrArrayBufferToBase64: function (buffer) {
        if (!buffer) {
            return '';
        }

        // handle when buffer is pure string
        if (_.isString(buffer)) {
            return util.btoa(buffer);
        }

        // check if tostring works
        var base64 = buffer.toString('base64') || '';

        if (base64 === '[object ArrayBuffer]') {
            return util.btoa(util.arrayBufferToString(buffer));
        }

        return base64;
    },

    /**
     * Check whether a value is number-like
     * https://github.com/lodash/lodash/issues/1148#issuecomment-141139153
     *
     * @param {*} n - The candidate to be checked for numeric compliance.
     * @return {Boolean}
     */
    isNumeric: function (n) {
        return !isNaN(parseFloat(n)) && isFinite(n);
    }
};

module.exports = util;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))

/***/ }),

/***/ 3787:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    uuid = __webpack_require__(145),
    PropertyBase = __webpack_require__(3813).PropertyBase,
    Description = __webpack_require__(4359).Description,
    Substitutor = __webpack_require__(5305).Substitutor,

    DISABLED = 'disabled',
    DESCRIPTION = 'description',

    Property; // constructor

/**
 * @typedef Property~definition
 * @property {String=} [id] A unique string that identifies the property.
 * @property {String=} [name] A distinctive and human-readable name of the property.
 * @property {Boolean=} [disabled] Denotes whether the property is disabled or not.
 * @property {Object=} [info] The meta information regarding the Property is provided as the `info` object.
 * @property {String=} [info.id] If set, this is used instead of the definition root's id.
 * @property {String=} [info.name] If set, this is used instead of the definition root's name.
 */
_.inherit((

    /**
     * The Property class forms the base of all postman collection SDK elements. This is to be used only for SDK
     * development or to extend the SDK with additional functionalities. All SDK classes (constructors) that are
     * supposed to be identifyable (i.e. ones that can have a `name` and `id`) are derived from this class.
     *
     * For more information on what is the structure of the `definition` the function parameter, have a look at
     * {@link Property~definition}.
     *
     * > This is intended to be a private class except for those who want to extend the SDK itself and add more
     * > functionalities.
     *
     * @constructor
     * @extends {PropertyBase}
     *
     * @param {Property~definition=} [definition] Every constructor inherited from `Property` is required to call the
     * super constructor function. This implies that construction parameters of every inherited member is propagated
     * to be sent up to this point.
     *
     * @see Property~definition
     */
    Property = function PostmanProperty (definition) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Property.super_.apply(this, arguments);

        // The definition can have an `info` object that stores the identification of this property. If that is present,
        // we use it instead of the definition root.
        var src = definition && definition.info || definition,
            id;

        // first we extract id from all possible sources
        // we also check if this property is marked to require an ID, we generate one if not found.
        id = (src && src.id) || this.id || (this._ && this._.postman_id) || (this._postman_propertyRequiresId &&
            uuid.v4());

        /**
         * The `id` of the property is a unique string that identifies this property and can be used to refer to
         * this property from relevant other places. It is a good practice to define the id or let the system
         * auto generate a UUID if one is not defined for properties that require an `id`.
         * @name id
         * @type {String}
         * @memberOf Property.prototype
         *
         * @note The property can also be present in the `postman_id` meta in case it is not specified in the
         * object. An auto-generated property is used wherever one is not specified
         */
        id && (this.id = id);

        /**
         * A property can have a distinctive and human-readable name. This is to be used to display the name of the
         * property within Postman, Newman or other runtimes that consume collection. In certain cases, the absence
         * of name might cause the runtime to use the `id` as a fallback.
         * @name name
         * @memberOf Property.prototype
         * @type {String}
         */
        src && src.name && (this.name = src.name);

        /**
         * This (optional) flag denotes whether this property is disabled or not. Usually, this is helpful when a
         * property is part of a {@link PropertyList}. For example, in a PropertyList of {@link Header}s, the ones
         * that are disabled can be filtered out and not processed.
         * @type {Boolean}
         * @optional
         * @name disabled
         *
         * @memberOf Property.prototype
         */
        definition && _.has(definition, DISABLED) && (this.disabled = Boolean(definition.disabled));

        /**
         * The `description` property holds the detailed documentation of any property. The description can be written
         * in plain text, html or markdown as mentioned in {@link Description.format} enumeration. It is recommended
         * that this property be updated using the [describe](#describe) function.
         *
         * @type {Description}
         * @see Property#describe
         *
         * @example <caption>Accessing descriptions of all root items in a collection</caption>
         * var fs = require('fs'), // needed to read JSON file from disk
         *     Collection = require('postman-collection').Collection,
         *     myCollection;
         *
         * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)
         * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));
         *
         * // Log the description of all root items
         * myCollection.item.all().forEach(function (item) {
         *     console.log(item.name || 'Untitled Item');
         *     item.description && console.log(item.description.toString());
         * });
         */
        // eslint-disable-next-line max-len
        _.has(src, DESCRIPTION) && (this.description = _.createDefined(src, DESCRIPTION, Description, this.description));
    }), PropertyBase);

_.assign(Property.prototype, /** @lends Property.prototype */ {
    /**
     * This function allows to describe the property for the purpose of detailed identification or documentation
     * generation. This function sets or updates the `description` child-property of this property.
     *
     * @param {String} content The content of the description can be provided here as a string. Note that it is expected
     * that if the content is formatted in any other way than simple text, it should be specified in the subsequent
     * `type` parameter.
     * @param {String=} [type="text/plain"] The type of the content can be one of the values mentioned in
     * {@link Description.format} enumeration - namely `text/plain`, `text/markdown` or `text/html`.
     *
     * @example <caption>Add a description to an instance of Collection</caption>
     *  var Collection = require('postman-collection').Collection,
     *     mycollection;
     *
     * // create a blank collection
     * myCollection = new Collection();
     * myCollection.describe('Hey! This is a cool collection.');
     *
     * console.log(myCollection.description.toString()); // read the description
     */
    describe: function (content, type) {
        (Description.isDescription(this.description) ? this.description : (this.description = new Description()))
            .update(content, type);
    },

    /**
     * Returns an object representation of the Property with its variable references substituted.
     *
     * @example <caption>Resolve an object using variable definitions from itself and its parents</caption>
     * property.toObjectResolved();
     *
     * @example <caption>Resolve an object using variable definitions on a different object</caption>
     * property.toObjectResolved(item);
     *
     * @example <caption>Resolve an object using variables definitions as a flat list of variables</caption>
     * property.toObjectResolved(null, [variablesDefinition1, variablesDefinition1], {ignoreOwnVariables: true});
     *
     * @private
     * @draft
     * @param {?Item|ItemGroup=} [scope] - One can specifically provide an item or group with `.variables`. In
     * the event one is not provided, the variables are taken from this object or one from the parent tree.
     * @param {Array<Object>} overrides - additional objects to lookup for variable values
     * @param {Object} [options]
     * @param {Boolean} [options.ignoreOwnVariables] - if set to true, `.variables` on self(or scope)
     * will not be used for variable resolution. Only variables in `overrides` will be used for resolution.
     * @returns {Object|undefined}
     * @throws {Error} If `variables` cannot be resolved up the parent chain.
     */
    toObjectResolved: function (scope, overrides, options) {
        var ignoreOwnVariables = options && options.ignoreOwnVariables,
            variableSourceObj,
            variables,
            reference;

        // ensure you do not substitute variables itself!
        reference = this.toJSON();
        _.isArray(reference.variable) && (delete reference.variable);

        // if `ignoreScopeVariables` is turned on, ignore `.variables` and resolve with only `overrides`
        // otherwise find `.variables` on current object or `scope`
        if (ignoreOwnVariables) {
            return Property.replaceSubstitutionsIn(reference, overrides);
        }

        // 1. if variables is passed as params, use it or fall back to oneself
        // 2. for a source from point (1), and look for `.variables`
        // 3. if `.variables` is not found, then rise up the parent to find first .variables
        variableSourceObj = scope || this;
        do {
            variables = variableSourceObj.variables;
            variableSourceObj = variableSourceObj.__parent;
        } while (!variables && variableSourceObj);

        if (!variables) { // worst case = no variable param and none detected in tree or object
            throw Error('Unable to resolve variables. Require a List type property for variable auto resolution.');
        }

        return variables.substitute(reference, overrides);
    }
});

_.assign(Property, /** @lends Property */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Property',

    /**
     * This function accepts a string followed by a number of variable sources as arguments. One or more variable
     * sources can be provided and it will use the one that has the value in left-to-right order.
     *
     * @param {String} str
     * @param {VariableList|Object|Array.<VariableList|Object>} variables
     * @returns {String}
     */
    // @todo: improve algorithm via variable replacement caching
    replaceSubstitutions: function (str, variables) {
        // if there is nothing to replace, we move on
        if (!(str && _.isString(str))) { return str; }

        // if variables object is not an instance of substitutor then ensure that it is an array so that it becomes
        // compatible with the constructor arguments for a substitutor
        !Substitutor.isInstance(variables) && !_.isArray(variables) && (variables = _.tail(arguments));
        return Substitutor.box(variables, Substitutor.DEFAULT_VARS).parse(str).toString();
    },

    /**
     * This function accepts an object followed by a number of variable sources as arguments. One or more variable
     * sources can be provided and it will use the one that has the value in left-to-right order.
     *
     * @param {Object} obj
     * @param {Array.<VariableList|Object>} variables
     * @param {Boolean=} [mutate=false]
     * @returns {Object}
     */
    replaceSubstitutionsIn: function (obj, variables, mutate) {
        // if there is nothing to replace, we move on
        if (!(obj && _.isObject(obj))) {
            return obj;
        }

        // convert the variables to a substitutor object (will not reconvert if already substitutor)
        variables = Substitutor.box(variables, Substitutor.DEFAULT_VARS);

        var customizer = function (objectValue, sourceValue) {
            objectValue = objectValue || {};
            if (!_.isString(sourceValue)) {
                _.forOwn(sourceValue, function (value, key) {
                    sourceValue[key] = customizer(objectValue[key], value);
                });

                return sourceValue;
            }

            return this.replaceSubstitutions(sourceValue, variables);
        }.bind(this);

        return _.mergeWith(mutate ? obj : {}, obj, customizer);
    }
});

module.exports = {
    Property: Property
};


/***/ }),

/***/ 3798:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyBase = __webpack_require__(3813).PropertyBase,

    __PARENT = '__parent',
    DEFAULT_INDEX_ATTR = 'id',
    DEFAULT_INDEXCASE_ATTR = false,
    DEFAULT_INDEXMULTI_ATTR = false,

    PropertyList;

_.inherit((

    /**
     * @constructor
     * @param {String} type
     * @param {Object} parent
     * @param {Array} populate
     */
    PropertyList = function PostmanPropertyList (type, parent, populate) {
        // @todo add this test sometime later
        // if (!type) {
        //     throw new Error('postman-collection: cannot initialise a list without a type parameter');
        // }

        PropertyList.super_.call(this); // call super with appropriate options

        this.setParent(parent); // save reference to parent
        _.assign(this, /** @lends PropertyList.prototype */ {
            /**
             * @private
             * @type {Array}
             */
            members: this.members || [],

            /**
             * @private
             * @type {Object}
             * @note This should not be used, and it's not guaranteed to be in sync with the actual list of members.
             */
            reference: this.reference || {},

            /**
             * @private
             * @type {Function}
             */
            Type: type
        });

        // if the type this list holds has its own index key, then use the same
        _.getOwn(type, '_postman_propertyIndexKey') && (this._postman_listIndexKey = type._postman_propertyIndexKey);

        // if the type has case sensitivity flags, set the same
        _.getOwn(type, '_postman_propertyIndexCaseInsensitive') && (this._postman_listIndexCaseInsensitive =
            type._postman_propertyIndexCaseInsensitive);

        // if the type allows multiple values, set the flag
        _.getOwn(type, '_postman_propertyAllowsMultipleValues') && (this._postman_listAllowsMultipleValues =
            type._postman_propertyAllowsMultipleValues);

        // prepopulate
        populate && this.populate(populate);
    }), PropertyBase);

_.assign(PropertyList.prototype, /** @lends PropertyList.prototype */ {

    /**
     * Indicates that this element contains a number of other elements.
     * @private
     */
    _postman_propertyIsList: true,

    /**
     * Holds the attribute to index this PropertyList by. Default: 'id'
     *
     * @private
     * @type {String}
     */
    _postman_listIndexKey: DEFAULT_INDEX_ATTR,

    /**
     * Holds the attribute whether indexing of this list is case sensitive or not
     *
     * @private
     * @type {String}
     */
    _postman_listIndexCaseInsensitive: DEFAULT_INDEXCASE_ATTR,

    /**
     * Holds the attribute whether exporting the index retains duplicate index items
     *
     * @private
     * @type {String}
     */
    _postman_listAllowsMultipleValues: DEFAULT_INDEXMULTI_ATTR,

    /**
     * Insert an element at the end of this list. When a reference member specified via second parameter is found, the
     * member is inserted at an index before the reference member.
     *
     * @param {PropertyList.Type} item
     * @param {PropertyList.Type|String} [before]
     */
    insert: function (item, before) {
        if (!_.isObject(item)) { return; } // do not proceed on empty param

        var duplicate = this.indexOf(item),
            index;

        // remove from previous list
        PropertyList.isPropertyList(item[__PARENT]) && (item[__PARENT] !== this) && item[__PARENT].remove(item);
        // inject the parent reference
        _.assignHidden(item, __PARENT, this);

        // ensure that we do not double insert things into member array
        (duplicate > -1) && this.members.splice(duplicate, 1);
        // find the position of the reference element
        before && (before = this.indexOf(before));

        // inject to the members array ata position or at the end in case no item is there for reference
        (before > -1) ? this.members.splice(before, 0, item) : this.members.push(item);

        // store reference by id, so create the index string. we first ensure that the index value is truthy and then
        // recheck that the string conversion of the same is truthy as well.
        if ((index = item[this._postman_listIndexKey]) && (index = String(index))) {
            // desensitise case, if the property needs it to be
            this._postman_listIndexCaseInsensitive && (index = index.toLowerCase());

            // if multiple values are allowed, the reference may contain an array of items, mapped to an index.
            if (this._postman_listAllowsMultipleValues && this.reference.hasOwnProperty(index)) {

                // if the value is not an array, convert it to an array.
                !_.isArray(this.reference[index]) && (this.reference[index] = [this.reference[index]]);

                // add the item to the array of items corresponding to this index
                this.reference[index].push(item);
            }
            else {
                this.reference[index] = item;
            }
        }
    },

    /**
     * Insert an element at the end of this list. When a reference member specified via second parameter is found, the
     * member is inserted at an index after the reference member.
     *
     * @param {PropertyList.Type} item
     * @param {PropertyList.Type|String} [after]
     */
    insertAfter: function (item, after) {
        // convert item to positional reference
        return this.insert(item, this.idx(this.indexOf(after) + 1));
    },

    /**
     * Adds or moves an item to the end of this list.
     *
     * @param {PropertyList.Type} item
     */
    append: function (item) {
        return this.insert(item);
    },

    /**
     * Adds or moves an item to the beginning of this list.
     *
     * @param {PropertyList.Type} item
     */
    prepend: function (item) {
        return this.insert(item, this.idx(0));
    },

    /**
     * Add an item or item definition to this list.
     *
     * @param {Object|PropertyList.Type} item
     * @todo
     * - remove item from original parent if already it has a parent
     * - validate that the original parent's constructor matches this parent's constructor
     */
    add: function (item) {
        // do not proceed on empty param, but empty strings are in fact valid.
        // eslint-disable-next-line lodash/prefer-is-nil
        if (_.isNull(item) || _.isUndefined(item) || _.isNaN(item)) { return; }

        // create new instance of the item based on the type specified if it is not already
        this.insert((item.constructor === this.Type) ? item :
            // if the property has a create static function, use it.
            // eslint-disable-next-line prefer-spread
            (_.has(this.Type, 'create') ? this.Type.create.apply(this.Type, arguments) : new this.Type(item)));
    },

    /**
     * Add an item or update an existing item
     *
     * @param {PropertyList~Type} item
     *
     * @returns {?Boolean}
     */
    upsert: function (item) {
        // do not proceed on empty param, but empty strings are in fact valid.
        if (_.isNil(item) || _.isNaN(item)) { return null; }

        var indexer = this._postman_listIndexKey,
            existing = this.one(item[indexer]);

        if (existing) {
            if (!_.isFunction(existing.update)) {
                throw new Error('collection: unable to upsert into a list of Type that does not support .update()');
            }
            existing.update(item);
            return false;
        }

        // since there is no existing item, just add a new one
        this.add(item);
        return true; // indicate added
    },

    /**
     * Removes all elements from the PropertyList for which the predicate returns truthy.
     *
     * @param {Function|String|Type} predicate
     * @param {Object} context Optional context to bind the predicate to.
     */
    remove: function (predicate, context) {
        var match; // to be used if predicate is an ID

        !context && (context = this);

        if (_.isString(predicate)) {
            // if predicate is id, then create a function to remove that
            // need to take care of case sensitivity as well :/
            match = this._postman_listIndexCaseInsensitive ? predicate.toLowerCase() : predicate;
            predicate = function (item) {
                var id = item[this._postman_listIndexKey];
                this._postman_listIndexCaseInsensitive && (id = id.toLowerCase());
                return id === match;
            }.bind(this);
        }
        else if (predicate instanceof this.Type) {
            // in case an object reference is sent, prepare it for removal using direct reference comparison
            match = predicate;
            predicate = function (item) {
                return (item === match);
            };
        }

        _.isFunction(predicate) && _.remove(this.members, function (item) {
            var index;
            if (predicate.apply(context, arguments)) {
                if ((index = item[this._postman_listIndexKey]) && (index = String(index))) {
                    this._postman_listIndexCaseInsensitive && (index = index.toLowerCase());

                    if (this._postman_listAllowsMultipleValues && _.isArray(this.reference[index])) {
                        // since we have an array of multiple values, remove only the value for which the
                        // predicate returned truthy. If the array becomes empty, just delete it.
                        _.remove(this.reference[index], function (each) {
                            return each === item;
                        });

                        // If the array becomes empty, remove it
                        (this.reference[index].length === 0) && (delete this.reference[index]);

                        // If the array contains only one element, remove the array, and assign the element
                        // as the reference value
                        (this.reference[index].length === 1) && (this.reference[index] = this.reference[index][0]);
                    }
                    else {
                        delete this.reference[index];
                    }
                }
                delete item[__PARENT]; // unlink from its parent
                return true;
            }
        }.bind(this));
    },

    /**
     * Removes all items in the list
     */
    clear: function () {
        // we unlink every member from it's parent (assuming this is their parent)
        this.all().forEach(PropertyList._unlinkItemFromParent);

        this.members.length = 0; // remove all items from list

        // now we remove all items from index reference
        Object.keys(this.reference).forEach(function (key) {
            delete this.reference[key];
        }.bind(this));
    },

    /**
     * Load one or more items
     *
     * @param {Object|Array} items
     */
    populate: function (items) {
        // if Type supports parsing of string headers then do it before adding it.
        _.isString(items) && _.isFunction(this.Type.parse) && (items = this.Type.parse(items));
        // add a single item or an array of items.
        _.forEach(_.isArray(items) ? items :
            // if population is not an array, we send this as single item in an array or send each property separately
            // if the core Type supports Type.create
            ((_.isPlainObject(items) && _.has(this.Type, 'create')) ? items : [items]), this.add.bind(this));
    },

    /**
     * Clears the list and adds new items.
     *
     * @param {Object|Array} items
     */
    repopulate: function (items) {
        this.clear();
        this.populate(items);
    },

    /**
     * Add or update values from a source list.
     *
     * @param {PropertyList|Array} source
     * @param {Boolean} [prune=false] Setting this to `true` will cause the extra items from the list to be deleted
     */
    assimilate: function (source, prune) {
        var members = PropertyList.isPropertyList(source) ? source.members : source,
            list = this,
            indexer = list._postman_listIndexKey,
            sourceKeys = {}; // keeps track of added / updated keys for later exclusion

        if (!_.isArray(members)) {
            return;
        }

        members.forEach(function (item) {
            if (!(item && item.hasOwnProperty(indexer))) { return; }
            list.upsert(item);
            sourceKeys[item[indexer]] = true;
        });

        // now remove any variable that is not in source object
        // @note - using direct `this.reference` list of keys here so that we can mutate the list while iterating
        // on it
        if (prune) {
            _.forEach(list.reference, function (value, key) {
                if (sourceKeys.hasOwnProperty(key)) { return; } // de not delete if source obj has this variable
                list.remove(key); // use PropertyList functions to remove so that the .members array is cleared too
            });
        }
    },

    /**
     * Returns a map of all items.
     *
     * @returns {Object}
     */
    all: function () {
        return _.clone(this.members);
    },

    /**
     * Get Item in this list by `ID` reference. If multiple values are allowed, the last value is returned.
     *
     * @param {String} id
     * @returns {PropertyList.Type}
     */
    one: function (id) {
        var val = this.reference[this._postman_listIndexCaseInsensitive ? String(id).toLowerCase() : id];

        if (this._postman_listAllowsMultipleValues && Array.isArray(val)) {
            return val.length ? val[val.length - 1] : undefined;
        }

        return val;
    },

    /**
     * Get the value of an item in this list. This is similar to {@link PropertyList.one} barring the fact that it
     * returns the value of the underlying type of the list content instead of the item itself.
     *
     * @param {String|Function} key
     * @returns {PropertyList.Type|*}
     */
    get: function (key) {
        var member = this.one(key);
        if (!member) { return; } // eslint-disable-line getter-return

        return member.valueOf();
    },

    /**
     * Iterate on each item of this list.
     *
     * @param {Function} iterator
     * @param {Object} context
     */
    each: function (iterator, context) {
        _.forEach(this.members, _.isFunction(iterator) ? iterator.bind(context || this.__parent) : iterator);
    },

    /**
     * @param {Function} rule
     * @param {Object} context
     */
    filter: function (rule, context) {
        return _.filter(this.members, _.isFunction(rule) && _.isObject(context) ? rule.bind(context) : rule);
    },

    /**
     * Find an item within the item group
     *
     * @param {Function} rule
     * @param {Object} [context]
     * @returns {Item|ItemGroup}
     */
    find: function (rule, context) {
        return _.find(this.members, _.isFunction(rule) && _.isObject(context) ? rule.bind(context) : rule);
    },

    /**
     * Iterates over the property list.
     *
     * @param {Function} iterator Function to call on each item.
     * @param {Object} context Optional context, defaults to the PropertyList itself.
     */
    map: function (iterator, context) {
        return _.map(this.members, _.isFunction(iterator) ? iterator.bind(context || this) : iterator);
    },

    /**
     * Iterates over the property list and accumulates the result.
     *
     * @param {Function} iterator Function to call on each item.
     * @param {*} accumulator Accumulator initial value
     * @param {Object} context Optional context, defaults to the PropertyList itself.
     */
    reduce: function (iterator, accumulator, context) {
        return _.reduce(this.members, _.isFunction(iterator) ? iterator.bind(context || this) : iterator, accumulator);
    },

    /**
     * Returns the length of the PropertyList
     *
     * @returns {Number}
     */
    count: function () {
        return this.members.length;
    },

    /**
     * Get a member of this list by it's index
     *
     * @param {Number} index
     * @returns {PropertyList.Type}
     */
    idx: function (index) {
        return this.members[index];
    },

    /**
     * Find the index of an item in this list
     *
     * @param {String|Object} item
     * @returns {Number}
     */
    indexOf: function (item) {
        return this.members.indexOf(_.isString(item) ? (item = this.one(item)) : item);
    },

    /**
     * Check whether an item exists in this list
     *
     * @param {String|PropertyList.Type} item
     * @param {*=} value
     * @returns {Boolean}
     */
    has: function (item, value) {
        var match,
            val,
            i;

        match = _.isString(item) ?
            this.reference[this._postman_listIndexCaseInsensitive ? item.toLowerCase() : item] :
            this.filter(function (member) {
                return member === item;
            });

        // If we don't have a match, there's nothing to do
        if (!match) { return false; }

        // if no value is provided, just check if item exists
        if (arguments.length === 1) {
            return Boolean(_.isArray(match) ? match.length : match);
        }

        // If this property allows multiple values and we get an array, we need to iterate through it and see
        // if any element matches.
        if (this._postman_listAllowsMultipleValues && _.isArray(match)) {
            for (i = 0; i < match.length; i++) {

                // use the value of the current element
                val = _.isFunction(match[i].valueOf) ? match[i].valueOf() : match[i];

                if (val === value) { return true; }
            }

            // no matches were found, so return false here.
            return false;
        }

        // We didn't have an array, so just check if the matched value equals the provided value.
        _.isFunction(match.valueOf) && (match = match.valueOf());

        return match === value;
    },

    /**
     * Iterates over all parents of the property list
     *
     * @param {Function} iterator
     * @param {Object=} [context]
     */
    eachParent: function (iterator, context) {
        // validate parameters
        if (!_.isFunction(iterator)) { return; }
        !context && (context = this);

        var parent = this.__parent,
            prev;

        // iterate till there is no parent
        while (parent) {
            // call iterator with the parent and previous parent
            iterator.call(context, parent, prev);

            // update references
            prev = parent;
            parent = parent.__parent;
        }
    },

    /**
     * Converts a list of Properties into an object where key is `_postman_propertyIndexKey` and value is determined
     * by the `valueOf` function
     *
     * @param {?Boolean} [excludeDisabled=false] - When set to true, disabled properties are excluded from the resultant
     * object.
     * @param {?Boolean} [caseSensitive] - When set to true, properties are treated strictly as per their original
     * case. The default value for this property also depends on the case insensitivity definition of the current
     * property.
     * @param {?Boolean} [multiValue=false] - When set to true, only the first value of a multi valued property is
     * returned.
     * @param {Boolean} [sanitizeKeys=false] - When set to true, properties with falsy keys are removed.
     * @todo Change the function signature to an object of options instead of the current structure.
     * @return {Object}
     */
    toObject: function (excludeDisabled, caseSensitive, multiValue, sanitizeKeys) {
        var obj = {}, // create transformation data accumulator

            // gather all the switches of the list
            key = this._postman_listIndexKey,
            sanitiseKeys = this._postman_sanitizeKeys || sanitizeKeys,
            sensitive = !this._postman_listIndexCaseInsensitive || caseSensitive,
            multivalue = this._postman_listAllowsMultipleValues || multiValue;

        // iterate on each member to create the transformation object
        this.each(function (member) {
            // Bail out for the current member if ANY of the conditions below is true:
            // 1. The member is falsy.
            // 2. The member does not have the specified property list index key.
            // 3. The member is disabled and disabled properties have to be ignored.
            // 4. The member has a falsy key, and sanitize is true.
            if (!member || !member.hasOwnProperty(key) || (excludeDisabled && member.disabled) ||
                (sanitiseKeys && !member[key])) {
                return;
            }

            // based on case sensitivity settings, we get the property name of the item
            var prop = sensitive ? member[key] : String(member[key]).toLowerCase();

            // now, if transformation object already has a member with same property name, we either overwrite it or
            // append to an array of values based on multi-value support
            if (multivalue && obj.hasOwnProperty(prop)) {
                (!Array.isArray(obj[prop])) && (obj[prop] = [obj[prop]]);
                obj[prop].push(member.valueOf());
            }
            else {
                obj[prop] = member.valueOf();
            }
        });

        return obj;
    },

    /**
     * Adds ability to convert a list to a string provided it's underlying format has unparse function defined.
     *
     * @return {String}
     */
    toString: function () {
        if (this.Type.unparse) {
            return this.Type.unparse(this.members);
        }

        return this.constructor ? this.constructor.prototype.toString.call(this) : '';
    },

    toJSON: function () {
        if (!this.count()) {
            return [];
        }

        return _.map(this.members, function (member) {
            // use member.toJSON if it exists
            if (!_.isEmpty(member) && _.isFunction(member.toJSON)) {
                return member.toJSON();
            }

            return _.reduce(member, function (accumulator, value, key) {
                if (value === undefined) { // true/false/null need to be preserved.
                    return accumulator;
                }

                // Handle plurality of PropertyLists in the SDK vs the exported JSON.
                // Basically, removes the trailing "s" from key if the value is a property list.
                if (value && value._postman_propertyIsList && !value._postman_proprtyIsSerialisedAsPlural &&
                    _.endsWith(key, 's')) {
                    key = key.slice(0, -1);
                }

                // Handle 'PropertyBase's
                if (value && _.isFunction(value.toJSON)) {
                    accumulator[key] = value.toJSON();
                    return accumulator;
                }

                // Handle Strings
                if (_.isString(value)) {
                    accumulator[key] = value;
                    return accumulator;
                }

                // Everything else
                accumulator[key] = _.cloneElement(value);
                return accumulator;
            }, {});
        });
    }
});

_.assign(PropertyList, /** @lends PropertyList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'PropertyList',

    /**
     * Removes child-parent links for the provided PropertyList member.
     *
     * @param {Property} item - The property for which to perform parent de-linking.
     * @private
     */
    _unlinkItemFromParent: function (item) {
        item.__parent && (delete item.__parent); // prevents V8 from making unnecessary look-ups if there is no __parent
    },

    /**
     * Checks whether an object is a PropertyList
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isPropertyList: function (obj) {
        return Boolean(obj) && ((obj instanceof PropertyList) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', PropertyList._postman_propertyName));
    }
});

module.exports = {
    PropertyList: PropertyList
};


/***/ }),

/***/ 3813:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,

    __PARENT = '__parent',

    PropertyBase; // constructor

/**
 * @typedef PropertyBase~definition
 * @property {String|Description} [description]
 */
/**
 * Base of all properties in Postman Collection. It defines the root for all standalone properties for postman
 * collection.
 *
 * @constructor
 * @private
 * @param {PropertyBase~definition} definition
 */
PropertyBase = function PropertyBase (definition) {
    // In case definition object is missing, there is no point moving forward. Also if the definition is basic string
    // we do not need to do anything with it.
    if (!definition || typeof definition === 'string') { return; }

    // call the meta extraction functions to create the object where all keys that are prefixed with underscore can be
    // stored. more details on that can be retrieved from the propertyExtractMeta function itself.
    // @todo: make this a closed function to do getter and setter which is non enumerable
    var src = definition && definition.info || definition,
        meta = _(src).pickBy(PropertyBase.propertyIsMeta).mapKeys(PropertyBase.propertyUnprefixMeta).value();

    if (_.keys(meta).length) {
        this._ = _.isObject(this._) ? _.mergeDefined(this._, meta) : meta;
    }
};

_.assign(PropertyBase.prototype, /** @lends PropertyBase.prototype */ {

    /**
     * Invokes the given iterator for every parent in the parent chain of the given element.
     *
     * @param {?Object|Boolean} [options={}] - A set of options for the parent chain traversal.
     * @param {?Boolean} [options.withRoot=false] - Set to true to include the collection object as well.
     * @param {Function} iterator - The function to call for every parent in the ancestry chain.
     * @todo Cache the results
     */
    forEachParent: function (options, iterator) {
        _.isFunction(options) && (iterator = options, options = {});
        if (!_.isFunction(iterator) || !_.isObject(options)) { return; }

        var parent = this.parent(),
            grandparent = parent && _.isFunction(parent.parent) && parent.parent();

        while (parent && (grandparent || options.withRoot)) {
            iterator(parent);
            parent = grandparent;
            grandparent = grandparent && _.isFunction(grandparent.parent) && grandparent.parent();
        }
    },

    /**
     * Tries to find the given property locally, and then proceeds to lookup in each parent,
     * going up the chain as necessary. Lookup will continue until `customizer` returns a truthy value. If used
     * without a customizer, the lookup will stop at the first parent that contains the property.
     *
     * @param {String} property
     * @param {Function} [customizer]
     *
     * @returns {*|undefined}
     */
    findInParents: function (property, customizer) {
        var owner = this.findParentContaining(property, customizer);
        return owner ? owner[property] : undefined;
    },

    /**
     * Looks up the closest parent which has a truthy value for the given property. Lookup will continue
     * until `customizer` returns a truthy value. If used without a customizer,
     * the lookup will stop at the first parent that contains the property.
     *
     * @param {String} property
     * @param {Function} [customizer]
     *
     * @returns {PropertyBase|undefined}
     * @private
     */
    findParentContaining: function (property, customizer) {
        var parent = this;

        // if customizer is present test with it
        if (customizer) {
            customizer = customizer.bind(this);

            do {
                // else check for existence
                if (customizer(parent)) {
                    return parent;
                }

                parent = parent.__parent;
            } while (parent);
        }

        // else check for existence
        else {
            do {
                if (parent[property]) {
                    return parent;
                }

                parent = parent.__parent;
            } while (parent);
        }
    },

    /**
     * Returns the JSON representation of a property, which conforms to the way it is defined in a collection.
     * You can use this method to get the instantaneous representation of any property, including a {@link Collection}.
     */
    toJSON: function () {
        return _.reduce(this, function (accumulator, value, key) {
            if (value === undefined) { // true/false/null need to be preserved.
                return accumulator;
            }

            // Handle plurality of PropertyLists in the SDK vs the exported JSON.
            // Basically, removes the trailing "s" from key if the value is a property list.
            // eslint-disable-next-line max-len
            if (value && value._postman_propertyIsList && !value._postman_proprtyIsSerialisedAsPlural && _.endsWith(key, 's')) {
                key = key.slice(0, -1);
            }

            // Handle 'PropertyBase's
            if (value && _.isFunction(value.toJSON)) {
                accumulator[key] = value.toJSON();
                return accumulator;
            }

            // Handle Strings
            if (_.isString(value)) {
                accumulator[key] = value;
                return accumulator;
            }

            // Everything else
            accumulator[key] = _.cloneElement(value);
            return accumulator;
        }, {});
    },

    /**
     * Returns the meta keys associated with the property
     *
     * @returns {*}
     */
    meta: function () {
        return arguments.length ? _.pick(this._, Array.prototype.slice.apply(arguments)) : _.cloneDeep(this._);
    },

    /**
     * Returns the parent of item
     *
     * @returns {*|undefined}
     */
    parent: function () {
        // @todo return grandparent only if it is a list
        return this && this.__parent && (this.__parent.__parent || this.__parent) || undefined;
    },

    /**
     * Accepts an object and sets it as the parent of the current property.
     *
     * @param {Object} parent The object to set as parent.
     * @private
     */
    setParent: function (parent) {
        _.assignHidden(this, __PARENT, parent);
    }
});

_.assign(PropertyBase, /** @lends Base */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'PropertyBase',

    /**
     * Filter function to check whether a key starts with underscore or not. These usually are the meta properties. It
     * returns `true` if the criteria is matched.
     *
     * @param {*} value
     * @param {String} key
     *
     * @returns {boolean}
     */
    propertyIsMeta: function (value, key) {
        return _.startsWith(key, '_') && (key !== '_');
    },

    /**
     * Map function that removes the underscore prefix from an object key.
     *
     * @param {*} value
     * @param {String} key
     *
     * @returns {String}
     */
    propertyUnprefixMeta: function (value, key) {
        return _.trimStart(key, '_');
    },

    /**
     * Static function which allows calling toJSON() on any object.
     *
     * @param {Object} obj
     * @returns {*}
     */
    toJSON: function (obj) {
        return PropertyBase.prototype.toJSON.call(obj);
    }
});

module.exports = {
    PropertyBase: PropertyBase
};


/***/ }),

/***/ 3837:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyBase = __webpack_require__(3813).PropertyBase,
    QueryParam = __webpack_require__(4088).QueryParam,
    PropertyList = __webpack_require__(3798).PropertyList,
    VariableList = __webpack_require__(3921).VariableList,

    E = '',
    OBJECT = 'object',
    PROTOCOL_HTTPS = 'https',
    PROTOCOL_HTTP = 'http',
    HTTPS_PORT = '443',
    HTTP_PORT = '80',
    PATH_SEPARATOR = '/',
    PATH_VARIABLE_IDENTIFIER = ':',
    PORT_SEPARATOR = ':',
    DOMAIN_SEPARATOR = '.',
    PROTOCOL_SEPARATOR = '://',
    AUTH_SEPARATOR = ':',
    AUTH_CREDENTIALS_SEPARATOR = '@',
    QUERY_SEPARATOR = '?',
    SEARCH_SEPARATOR = '#',

    DEFAULT_PROTOCOL = PROTOCOL_HTTP + PROTOCOL_SEPARATOR,

    GET_0 = '[0]',
    GET_1 = '[1]',
    MATCH_1 = '$1',

    regexes = {
        // @todo: According to the IETF RFC #3986, '.' is a valid part of the protocol. Figure out a way to support it
        extractProtocol: /^([^:?]+):\/\/([^?#/:]*|$)/,
        extractHost: /^([^?#/]+)/,
        extractHostAuth: /^([^@]+)@/,
        extractPort: /:([^:]*)$/,
        extractPath: /.*?(?=\?|#|$)/,
        trimPath: /^\/((.+))$/,
        extractQuery: /^\?([^#]+)/,
        extractSearch: /#(.+)$/,
        splitDomain: /\.(?![^{]*\}{2})/g
    },

    Url;

_.inherit((

    /**
     * Defines a URL.
     *
     * @constructor
     * @extends {PropertyBase}
     * @param {Object|String} options
     */
    Url = function PostmanUrl (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Url.super_.apply(this, arguments);

        // create the url properties
        this.update(options);
    }), PropertyBase);

_.assign(Url.prototype, /** @lends Url.prototype */ {
    /**
     * Set a URL.
     *
     * @draft
     * @param {String|Object} url
     */
    update: function (url) {
        !url && (url = E);
        var parsedUrl = _.isString(url) ? Url.parse(url) : url,
            auth = parsedUrl.auth,
            protocol = parsedUrl.protocol,
            port = parsedUrl.port,
            path = parsedUrl.path,
            hash = parsedUrl.hash,
            host = parsedUrl.host,
            query = parsedUrl.query,
            variable = parsedUrl.variable;

        // convert object based query string to array
        // @todo: create a key value parser
        if (query) {
            if (_.isString(query)) {
                query = QueryParam.parse(query);
            }

            if (!_.isArray(query) && _.keys(query).length) {
                query = _.map(_.keys(query), function (key) {
                    return {
                        key: key,
                        value: query[key]
                    };
                });
            }
        }

        // backward compatibility with path variables being storing thins with `id`
        if (_.isArray(variable)) {
            variable = _.map(variable, function (v) {
                _.isObject(v) && (v.key = v.key || v.id); // @todo Remove once path variables are deprecated
                return v;
            });
        }

        // expand string path name
        if (_.isString(path)) {
            path && (path = path.replace(regexes.trimPath, MATCH_1)); // remove leading slash for valid path
            // if path is blank string, we set it to undefined, if '/' then single blank string array
            path = path ? (path === PATH_SEPARATOR ? [E] : path.split(PATH_SEPARATOR)) : undefined;
        }

        // expand host string
        _.isString(host) && (host = host.split(regexes.splitDomain));

        _.assign(this, /** @lends Url.prototype */ {
            /**
             * @type {String}
             */
            auth: auth,

            /**
             * @type {String}
             */
            protocol: protocol,

            /**
             * @type {String}
             */
            port: port || undefined,

            /**
             * @type {Array<String>}
             */
            path: path,

            /**
             * @type {String}
             */
            hash: hash || undefined,

            /**
             * @type {Array<String>}
             */
            host: host,

            /**
             * @type {PropertyList<QueryParam>}
             */
            query: new PropertyList(QueryParam, this, query || []),

            /**
             * @type {VariableList}
             */
            variables: new VariableList(this, variable || [])
        });
    },

    /**
     * Add query parameters to the URL.
     *
     * @param {Object|String} params Key value pairs to add to the URL.
     */
    addQueryParams: function (params) {
        params = _.isString(params) ? QueryParam.parse(params) : params;
        this.query.populate(params);
    },

    /**
     * Removes query parameters from the URL.
     *
     * @param {Array<QueryParam>|Array<String>|String} params Params should be an array of strings, or an array of
     * actual query parameters, or a string containing the parameter key.
     * @note Input should *not* be a query string.
     */
    removeQueryParams: function (params) {
        params = _.isArray(params) ? _.map(params, function (param) {
            return param.key ? param.key : param;
        }) : [params];
        this.query.remove(function (param) {
            return _.includes(params, param.key);
        });
    },

    /**
     * Unparses a {PostmanUrl} into a string.
     *
     * @deprecated Please use {@link Url#toString} instead of this
     * @returns {string}
     */
    getRaw: function () {
        return this.toString();
    },

    /**
     * Unparses a {PostmanUrl} into a string.
     *
     * @param {Boolean=} forceProtocol - Forces the URL to have a protocol
     * @returns {string}
     */
    toString: function (forceProtocol) {
        var rawUrl = E,
            protocol = this.protocol,
            queryString;

        forceProtocol && !protocol && (protocol = DEFAULT_PROTOCOL);

        if (protocol) {
            rawUrl += (_.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR);
        }

        if (this.auth && this.auth.user) { // If the user is not specified, ignore the password.
            rawUrl = rawUrl + ((this.auth.password) ?
                // ==> username:password@
                this.auth.user + AUTH_SEPARATOR + this.auth.password : this.auth.user) + AUTH_CREDENTIALS_SEPARATOR;
        }

        if (this.host) {
            rawUrl += this.getHost();
        }

        if (this.port) {
            rawUrl += PORT_SEPARATOR + this.port.toString();
        }

        if (this.path) {
            rawUrl += this.getPath();
        }

        if (this.query && this.query.count()) {
            queryString = this.getQueryString({ ignoreDisabled: true });
            queryString && (rawUrl += QUERY_SEPARATOR + queryString);
        }

        if (this.hash) {
            rawUrl += SEARCH_SEPARATOR + this.hash;
        }

        return rawUrl;
    },

    /**
     * Returns the request path, with a leading '/'.
     *
     * @param {?Boolean=} [unresolved=false]
     * @returns {string}
     *
     * @note deprecated variant in v3.4:
     *  - param {Object} options
     *  - param {Object} options.unresolved If set to true, path variables will not be processed
     */
    getPath: function (unresolved) {
        if (typeof unresolved === OBJECT) { // @todo discontinue in v4
            unresolved = unresolved.unresolved;
        }

        // for unresolved case, this is super simple as that is how raw data is stored
        if (unresolved) {
            return PATH_SEPARATOR + this.path.join(PATH_SEPARATOR);
        }

        var self = this,
            segments;

        segments = _.transform(this.path, function (res, segment) {
            var variable;

            // check if the segment has path variable prefix followed by the variable name.
            if (_.startsWith(segment, PATH_VARIABLE_IDENTIFIER) && segment !== PATH_VARIABLE_IDENTIFIER) {
                variable = self.variables.one(segment.slice(1)); // remove path variable prefix.
            }

            variable = variable && variable.valueOf && variable.valueOf();
            res.push(_.isString(variable) ? variable : segment);
        }, []);

        return PATH_SEPARATOR + segments.join(PATH_SEPARATOR); // add leading slash
    },

    /**
     * Returns the stringified query string for this URL.
     *
     * @param {?Boolean} [encode=false] - Enables URL encoding when processing the query string
     * @returns {String}
     *
     * @deprecated since v3.4.6, drop support for `encode`
     *
     * @note Deprecated variant of this function is as follows:
     * - param {?Object} [options={}]
     * - param {?Boolean} options.encode - Enables URL encoding when processing the query string.
     * - param {?Boolean} options.ignoreDisabled - Prevents disabled query parameters from showing up in the unparsed
     */
    getQueryString: function (encode) {
        if (!this.query.count()) {
            return E;
        }

        if (typeof encode === OBJECT) { // @todo discontinue in v4
            return QueryParam.unparse(this.query.all(), encode);
        }

        return QueryParam.unparse(this.query.all(), { encode: encode });
    },

    /**
     * Returns the complete path, including the query string.
     *
     * @param {?Boolean} [encodeQuery=false] - when set to `true` the query string part will be URL encoded
     *
     * @returns {*|string}
     * @example /something/postman?hi=notbye
     *
     * @deprecated since v3.4.6, drop support for `encodeQuery`
     */
    getPathWithQuery: function (encodeQuery) {
        var path = this.getPath();

        // check count first so that, we can ensure that ba `?` is always appended, even if a blank query string exists
        if (this.query.count()) {
            path += (QUERY_SEPARATOR + this.getQueryString(encodeQuery));
        }

        return path;
    },

    /**
     * Returns the host part of the URL
     *
     * @returns {string}
     */
    getHost: function () {
        if (!this.host) {
            return E;
        }

        return _.isArray(this.host) ? this.host.join(DOMAIN_SEPARATOR) : this.host.toString();
    },

    /**
     * Returns the host *and* port (if any), separated by a ":"
     *
     * @param {?Boolean} [forcePort=false] - forces the port to be added even for the protocol default ones (89, 443)
     * @returns {String}
     *
     * @note deprecated variant since v3.5
     *  - param {Object} options
     *  - param {Boolean} options.forcePort
     */
    getRemote: function (forcePort) {
        var host = this.getHost(),
            port = this.port && this.port.toString();

        // @todo remove when v4 is released and this is discontinued
        if (typeof forcePort === OBJECT) {
            forcePort = forcePort.forcePort;
        }

        if (forcePort && !port) { // this (!port) works since it assumes port as a string
            port = this.protocol && (this.protocol === PROTOCOL_HTTPS) ? HTTPS_PORT : HTTP_PORT;
        }

        return port ? (host + PORT_SEPARATOR + port) : host;
    },

    /**
     * Returns a OAuth1.0-a compatible representation of the request URL, also called "Base URL".
     * For details, http://oauth.net/core/1.0a/#anchor13
     *
     * todo: should we ignore the auth parameters of the URL or not? (the standard does not mention them)
     * we currently are.
     *
     * @private
     * @returns {String}
     *
     * @deprecated since v3.5 in favour of getBaseUrl
     * @todo discontinue in v4.0
     */
    getOAuth1BaseUrl: function () {
        var protocol = this.protocol || PROTOCOL_HTTP,
            port = this.port ? this.port.toString() : undefined,
            host = ((port === HTTP_PORT ||
                port === HTTPS_PORT ||
                port === undefined) && this.host.join(DOMAIN_SEPARATOR)) || (this.host.join(DOMAIN_SEPARATOR) +
                    PORT_SEPARATOR + port),
            path = this.getPath();

        protocol = (_.endsWith(protocol, PROTOCOL_SEPARATOR) ? protocol : protocol + PROTOCOL_SEPARATOR);
        return protocol.toLowerCase() + host.toLowerCase() + path;
    }
});

_.assign(Url, /** @lends Url */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Url',

    /**
     * Parses a string to a PostmanUrl, decomposing the URL into it's constitutent parts, such as
     * path, host, port, etc.
     *
     * @param {String} url
     * @returns {Object}
     */
    parse: function (url) {
        url = _.trimStart(url);
        var pathVariables,
            pathVariableKeys = {},
            p = {
                raw: url
            };

        // extract the protocol
        p.protocol = _.get(url.match(regexes.extractProtocol), GET_1);
        _.isString(p.protocol) && (url = url.substr(p.protocol.length + 3)); // remove that damn protocol from url

        // extract the host
        p.host = _.get(url.match(regexes.extractHost), GET_1);

        // if host exists there are a lot you can extract from it
        if (_.isString(p.host)) {
            url = url.substr(p.host.length); // remove host from url

            if ((p.auth = _.get(p.host.match(regexes.extractHostAuth), GET_1))) {
                p.host = p.host.substr(p.auth.length + 1); // remove auth from host
                p.auth = p.auth.split(AUTH_SEPARATOR);
                p.auth = {
                    user: p.auth[0],
                    password: p.auth[1]
                };
            }

            // extract the port from the host
            p.port = _.get(p.host.match(regexes.extractPort), GET_1);
            p.port && (p.host = p.host.substring(0, p.host.length - p.port.length - 1)); // remove port from url

            p.host = _.trim(p.host, DOMAIN_SEPARATOR).split(regexes.splitDomain); // split host by subdomains
        }

        // extract the path
        p.path = _.get(url.match(regexes.extractPath), GET_0);
        if (_.isString(p.path)) {
            url = url.substr(p.path.length);
            p.path && (p.path = p.path.replace(regexes.trimPath, MATCH_1)); // remove leading slash for valid path
            // if path is blank string, we set it to undefined, if '/' then single blank string array
            p.path = p.path ? (p.path === PATH_SEPARATOR ? [E] : p.path.split(PATH_SEPARATOR)) : undefined;
        }

        // extract the query string
        p.query = _.get(url.match(regexes.extractQuery), GET_1);
        _.isString(p.query) && ((url = url.substr(p.query.length + 1)), (p.query = QueryParam.parse(p.query)));

        // extract the hash
        p.hash = _.get(url.match(regexes.extractSearch), GET_1);

        // extract path variables
        pathVariables = _.transform(p.path, function (res, segment) {
            // check if the segment has path variable prefix followed by the variable name and
            // the variable is not already added in the list.
            if (_.startsWith(segment, PATH_VARIABLE_IDENTIFIER) &&
                segment !== PATH_VARIABLE_IDENTIFIER &&
                !pathVariableKeys[segment]) {
                pathVariableKeys[segment] = true;
                res.push({ key: segment.slice(1) }); // remove path variable prefix.
            }
        }, []);
        p.variable = pathVariables.length ? pathVariables : undefined;

        return p;
    },

    /**
     * Checks whether an object is a Url
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isUrl: function (obj) {
        return Boolean(obj) && ((obj instanceof Url) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Url._postman_propertyName));
    }
});

module.exports = {
    Url: Url
};


/***/ }),

/***/ 3921:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    Property = __webpack_require__(3787).Property,
    Variable = __webpack_require__(4360).Variable,

    VariableList;

_.inherit((

    /**
     * @constructor
     * @extends {PropertyList}
     *
     * @param {Property} parent
     * @param {Object|Array} populate
     */
    VariableList = function PostmanVariableList (parent, populate) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        VariableList.super_.call(this, Variable, parent, populate);
    }), PropertyList);

_.assign(VariableList.prototype, /** @lends VariableList.prototype */ {
    /**
     * Replaces the variable tokens inside a string with its actual values.
     *
     * @param {String} str
     * @param {Object} [overrides] - additional objects to lookup for variable values
     * @returns {String}
     */
    replace: function (str, overrides) {
        return Property.replaceSubstitutions(str, this, overrides);
    },

    /**
     * Recursively replace strings in an object with instances of variables. Note that it clones the original object. If
     * the `mutate` param is set to true, then it replaces the same object instead of creating a new one.
     *
     * @param {Array|Object} obj
     * @param {?Array<Object>=} [overrides] - additional objects to lookup for variable values
     * @param {Boolean=} [mutate=false]
     * @returns {Array|Object}
     */
    substitute: function (obj, overrides, mutate) {
        var resolutionQueue = [], // we use this to store the queue of variable hierarchy

            // this is an intermediate object to stimulate a property (makes the do-while loop easier)
            variableSource = {
                variables: this,
                __parent: this.__parent
            };

        do { // iterate and accumulate as long as you find `.variables` in parent tree
            variableSource.variables && resolutionQueue.push(variableSource.variables);
            variableSource = variableSource.__parent;
        } while (variableSource);

        variableSource = null; // cautious cleanup

        return Property.replaceSubstitutionsIn(obj, _.union(resolutionQueue, overrides), mutate);
    },

    /**
     * Using this function, one can sync the values of this variable list from a reference object.
     *
     * @param {Object} obj
     * @param {Boolean=} track
     * @param {Boolean} [prune=true]
     *
     * @returns {Object}
     */
    syncFromObject: function (obj, track, prune) {
        var list = this,
            ops = track && {
                created: [],
                updated: [],
                deleted: []
            },
            indexer = list._postman_listIndexKey,
            tmp;

        if (!_.isObject(obj)) { return ops; }

        // ensure that all properties in the object is updated in this list
        _.forOwn(obj, function (value, key) {
            // we need to create new variable if exists or update existing
            if (list.has(key)) {
                list.one(key).set(value);
                ops && ops.updated.push(key);
            }
            else {
                tmp = { value: value };
                tmp[indexer] = key;
                list.add(tmp);
                tmp = null;
                ops && ops.created.push(key);
            }
        });

        // now remove any variable that is not in source object
        // @note - using direct `this.reference` list of keys here so that we can mutate the list while iterating
        // on it
        if (prune !== false) {
            _.forEach(list.reference, function (value, key) {
                if (obj.hasOwnProperty(key)) { return; } // de not delete if source obj has this variable
                list.remove(key); // use PropertyList functions to remove so that the .members array is cleared too
                ops && ops.deleted.push(key);
            });
        }

        return ops;
    },

    /**
     * Transfer all variables from this list to an object
     *
     * @param {Object=} [obj]
     * @returns {Object}
     */
    syncToObject: function (obj) {
        var list = this;

        // in case user did not provide an object to mutate, create a new one
        !_.isObject(obj) && (obj = {});

        // delete extra variables from object that are not present in list
        _.forEach(obj, function (value, key) {
            !_.has(list.reference, key) && (delete obj[key]);
        });

        // we first sync all variables in this list to the object
        list.each(function (variable) {
            obj[variable.key] = variable.valueOf();
        });

        return obj;
    },

    /**
     * Fetches a variable and normalize its reference if disabled.
     * This updates the disabled variable `reference` in VariableList with its
     * last enabled duplicate(if found) in the `members` list.
     *
     * @private
     * @param {String} variableName - The name of the variable to get
     * @returns {Variable} - In case of duplicates, returns last enabled
     */
    oneNormalizedVariable: function (variableName) {
        var indexKey = this._postman_listIndexKey, // `key` for Variable
            variable = this.reference[variableName],
            i;

        if (variable && !variable.disabled) {
            return variable;
        }

        // traverse the members list in reverse direction in order to find the last enabled
        for (i = this.members.length - 1; i >= 0; i--) {
            variable = this.members[i];
            if (variable[indexKey] === variableName && !variable.disabled) {
                // update the input variable reference if comparison is not disabled
                this.reference[variableName] = variable;
                break; // return updated reference variable
            }
        }

        return this.reference[variableName];
    }
});

_.assign(VariableList, /** @lends VariableList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     *
     * @note that this is directly accessed only in case of VariableList from _.findValue lodash util mixin
     */
    _postman_propertyName: 'VariableList',

    /**
     * Checks whether an object is a VariableList
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isVariableList: function (obj) {
        return Boolean(obj) && ((obj instanceof VariableList) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', VariableList._postman_propertyName));
    }
});

module.exports = {
    VariableList: VariableList
};


/***/ }),

/***/ 3922:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    // for curl escaping of single quotes inside single quotes involves changing of ' to '\''
    inputString = inputString.replace(/'/g, "'\\''"); // eslint-disable-line quotes
    return trim ? inputString.trim() : inputString;
  },
  form: function (option, format) {
    if (format) {
      switch (option) {
        case '-s':
          return '--silent';
        case '-L':
          return '--location';
        case '-m':
          return '--max-time';
        case '-I':
          return '--head';
        case '-X':
          return '--request';
        case '-H':
          return '--header';
        case '-d':
          return '--data';
        case '-F':
          return '--form';
        default:
          return '';
      }
    }
    else {
      return option;
    }
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {*} urlObject The request sdk request.url object
 * @returns {String} The final string after parsing all the parameters of the url including
 * protocol, auth, host, port, path, query, hash
 * This will be used because the url.toString() method returned the URL with non encoded query string
 * and hence a manual call is made to getQueryString() method with encode option set as true.
 */
  getUrlStringfromUrlObject: function (urlObject) {
    var url = '';
    if (!urlObject) {
      return url;
    }
    if (urlObject.protocol) {
      url += (urlObject.protocol.endsWith('://') ? urlObject.protocol : urlObject.protocol + '://');
    }
    if (urlObject.auth && urlObject.auth.user) {
      url = url + ((urlObject.auth.password) ?
      // ==> username:password@
        urlObject.auth.user + ':' + urlObject.auth.password : urlObject.auth.user) + '@';
    }
    if (urlObject.host) {
      url += urlObject.getHost();
    }
    if (urlObject.port) {
      url += ':' + urlObject.port.toString();
    }
    if (urlObject.path) {
      url += urlObject.getPath();
    }
    if (urlObject.query && urlObject.query.count()) {
      let queryString = urlObject.getQueryString({ ignoreDisabled: true, encode: true });
      queryString && (url += '?' + queryString);
    }
    if (urlObject.hash) {
      url += '#' + urlObject.hash;
    }

    return url;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3978:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(3767),
    _ = util.lodash,
    PropertyBase = __webpack_require__(3813).PropertyBase,
    Property = __webpack_require__(3787).Property,
    Url = __webpack_require__(3837).Url,
    ProxyConfig = __webpack_require__(4091).ProxyConfig,
    Certificate = __webpack_require__(4087).Certificate,
    HeaderList = __webpack_require__(4092).HeaderList,
    RequestBody = __webpack_require__(4366).RequestBody,
    RequestAuth = __webpack_require__(3979).RequestAuth,

    Request,

    /**
     * Default request method
     *
     * @private
     * @const
     * @type {String}
     */
    DEFAULT_REQ_METHOD = 'GET',

    /**
     * Content length header name
     *
     * @private
     * @const
     * @type {String}
     */
    CONTENT_LENGTH = 'Content-Length',

    /**
     * Single space
     *
     * @private
     * @const
     * @type {String}
     */
    SP = ' ',

    /**
     * Carriage return + line feed
     *
     * @private
     * @const
     * @type {String}
     */
    CRLF = '\r\n',

    /**
     * HTTP version
     *
     * @private
     * @const
     * @type {String}
     */
    HTTP_X_X = 'HTTP/X.X',

    /**
     * @private
     * @type {Boolean}
     */
    supportsBuffer = (typeof Buffer !== undefined) && _.isFunction(Buffer.byteLength),

    /**
     * Source of request body size calculation.
     * Either computed from body or used Content-Length header value.
     *
     * @private
     * @const
     * @type {Object}
     */
    SIZE_SOURCE = {
        computed: 'COMPUTED',
        contentLength: 'CONTENT-LENGTH'
    };

/**
 * @typedef Request~definition
 * @property {String|Url} url The URL of the request. This can be a {@link Url~definition} or a string.
 * @property {String} method The request method, e.g: "GET" or "POST".
 * @property {Array<Header~definition>} header The headers that should be sent as a part of this request.
 * @property {RequestBody~definition} body The request body definition.
 * @property {RequestAuth~definition} auth The authentication/signing information for this request.
 * @property {ProxyConfig~definition} proxy The proxy information for this request.
 * @property {Certificate~definition} certificate The certificate information for this request.
 */
_.inherit((

    /**
     * A Postman HTTP request object.
     *
     * @constructor
     * @extends {Property}
     * @param {Request~definition} options
     */
    Request = function PostmanRequest (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Request.super_.apply(this, arguments);

        // if the definition is a string, it implies that this is a get of URL
        (typeof options === 'string') && (options = {
            url: options
        });

        // Create the default properties
        _.assign(this, /** @lends Request.prototype */ {
            /**
             * @type {Url}
             */
            url: new Url(),

            /**
             * @type {HeaderList}
             */
            headers: new HeaderList(this, options && options.header),

            // Although a similar check is being done in the .update call below, this handles falsy options as well.
            /**
             * @type {String}
             * @todo: Clean this up
             */
            // the negated condition is required to keep DEFAULT_REQ_METHOD as a fallback
            method: _.has(options, 'method') && !_.isNil(options.method) ?
                String(options.method).toUpperCase() : DEFAULT_REQ_METHOD
        });

        this.update(options);
    }), Property);

_.assign(Request.prototype, /** @lends Request.prototype */ {

    /**
     * Updates the different properties of the request.
     *
     * @param {Request~definition} options
     */
    update: function (options) {
        // Nothing to do
        if (!options) { return; }

        // The existing url is updated.
        _.has(options, 'url') && this.url.update(options.url);

        // The existing list of headers must be cleared before adding the given headers to it.
        options.header && this.headers.repopulate(options.header);

        // Only update the method if one is provided.
        _.has(options, 'method') && (this.method = _.isNil(options.method) ?
            DEFAULT_REQ_METHOD : String(options.method).toUpperCase());

        // The rest of the properties are not assumed to exist so we merge in the defined ones.
        _.mergeDefined(this, /** @lends Request.prototype */ {
            /**
             * @type {RequestBody|undefined}
             */
            body: _.createDefined(options, 'body', RequestBody),

            // auth is a special case, empty RequestAuth should not be created for falsy values
            // to allow inheritance from parent
            /**
             * @type {RequestAuth}
             */
            auth: options.auth ? new RequestAuth(options.auth) : undefined,

            /**
             * @type {ProxyConfig}
             */
            proxy: options.proxy && new ProxyConfig(options.proxy),

            /**
             * @type {Certificate|undefined}
             */
            certificate: options.certificate && new Certificate(options.certificate)
        });
    },

    /**
     * Sets authentication method for the request
     *
     * @param {?String|RequestAuth~definition} type
     * @param {VariableList~definition=} [options]
     *
     * @note This function was previously (in v2 of SDK) used to clone request and populate headers. Now it is used to
     * only set auth information to request
     *
     * @note that ItemGroup#authorizeUsing depends on this function
     */
    authorizeUsing: function (type, options) {
        if (_.isObject(type) && _.isNil(options)) {
            options = _.omit(type, 'type');
            type = type.type;
        }

        // null = delete request
        if (type === null) {
            _.has(this, 'auth') && (delete this.auth);
            return;
        }

        if (!RequestAuth.isValidType(type)) {
            return;
        }

        // create a new authentication data
        if (!this.auth) {
            this.auth = new RequestAuth(null, this);
        }
        else {
            this.auth.clear(type);
        }

        this.auth.use(type, options);
    },

    /**
     * Returns an object where the key is a header name and value is the header value.
     *
     * @param {Object=} options
     * @param {Boolean} options.ignoreCase When set to "true", will ensure that all the header keys are lower case.
     * @param {Boolean} options.enabled Only get the enabled headers
     * @param {Boolean} options.multiValue When set to "true", duplicate header values will be stored in an array
     * @param {Boolean} options.sanitizeKeys When set to "true", headers with falsy keys are removed
     * @returns {Object}
     * @note If multiple headers are present in the same collection with same name, but different case
     * (E.g "x-forward-port" and "X-Forward-Port", and `options.ignoreCase` is set to true,
     * the values will be stored in an array.
     */
    getHeaders: function getHeaders (options) {
        !options && (options = {});

        // @note: options.multiValue will not be respected since, Header._postman_propertyAllowsMultipleValues
        // gets higher precedence in PropertyLists~toObject.
        // @todo: sanitizeKeys for headers by default.
        return this.headers.toObject(options.enabled, !options.ignoreCase, options.multiValue, options.sanitizeKeys);
    },

    /**
     * Calls the given callback on each Header object contained within the request.
     *
     * @param {Function} callback
     */
    forEachHeader: function forEachHeader (callback) {
        this.headers.all().forEach(function (header) {
            return callback(header, this);
        }, this);
    },

    /**
     * Adds a header to the PropertyList of headers.
     *
     * @param {Header| {key: String, value: String}} header Can be a {Header} object, or a raw header object.
     */
    addHeader: function (header) {
        this.headers.add(header);
    },

    /**
     * Removes a header from the request.
     *
     * @param {String|Header} toRemove A header object to remove, or a string containing the header key.
     * @param {Object} options
     * @param {Boolean} options.ignoreCase If set to true, ignores case while removing the header.
     */
    removeHeader: function (toRemove, options) {
        toRemove = _.isString(toRemove) ? toRemove : toRemove.key;

        options = options || {};

        if (!toRemove) { // Nothing to remove :(
            return;
        }

        options.ignoreCase && (toRemove = toRemove.toLowerCase());

        this.headers.remove(function (header) {
            var key = options.ignoreCase ? header.key.toLowerCase() : header.key;
            return key === toRemove;
        });
    },

    /**
     * Updates or inserts the given header.
     *
     * @param {Object} header
     */
    upsertHeader: function (header) {
        if (!(header && header.key)) { return; } // if no valid header is provided, do nothing

        var existing = this.headers.find({ key: header.key });

        if (!existing) {
            return this.headers.add(header);
        }

        existing.value = header.value;
    },

    /**
     * Add query parameters to the request.
     *
     * @todo: Rename this?
     * @param {Array<QueryParam>|String} params
     */
    addQueryParams: function (params) {
        this.url.addQueryParams(params);
    },

    /**
     * Removes parameters passed in params.
     *
     * @param {String|Array} params
     */
    removeQueryParams: function (params) {
        this.url.removeQueryParams(params);
    },

    /**
     * Get the request size by computing the headers and body or using the
     * actual content length header once the request is sent.
     *
     * @returns {Object}
     */
    size: function () {
        var contentLength = this.headers.get(CONTENT_LENGTH),
            requestTarget = this.url.getPathWithQuery(),
            bodyString,
            sizeInfo = {
                body: 0,
                header: 0,
                total: 0,
                source: SIZE_SOURCE.computed
            };

        // if 'Content-Length' header is present, we take body as declared by
        // the client(postman-request or user-defined). else we need to compute the same.
        if (contentLength && util.isNumeric(contentLength)) {
            sizeInfo.body = parseInt(contentLength, 10);
            sizeInfo.source = SIZE_SOURCE.contentLength;
        }
        // otherwise, if body is defined, we calculate the length of the body
        else if (this.body) {
            // @note body.toString() returns E for formdata or file mode
            bodyString = this.body.toString();
            sizeInfo.body = supportsBuffer ? Buffer.byteLength(bodyString) : bodyString.length;
        }

        // https://tools.ietf.org/html/rfc7230#section-3
        // HTTP-message   = start-line (request-line / status-line)
        //                  *( header-field CRLF )
        //                  CRLF
        //                  [ message-body ]
        // request-line = method SP request-target SP HTTP-version CRLF
        sizeInfo.header = (this.method + SP + requestTarget + SP + HTTP_X_X + CRLF + CRLF).length +
            this.headers.contentSize();

        // compute the approximate total body size by adding size of header and body
        sizeInfo.total = (sizeInfo.body || 0) + (sizeInfo.header || 0);
        return sizeInfo;
    },

    /**
     * Converts the Request to a plain JavaScript object, which is also how the request is
     * represented in a collection file.
     *
     * @returns {{url: (*|string), method: *, header: (undefined|*), body: *, auth: *, certificate: *}}
     */
    toJSON: function () {
        var obj = PropertyBase.toJSON(this);

        // remove header array if blank
        if (_.isArray(obj.header) && !obj.header.length) {
            delete obj.header;
        }

        return obj;
    },

    /**
     * Creates a clone of this request
     *
     * @returns {Request}
     */
    clone: function () {
        return new Request(this.toJSON());
    },

    /**
     * Creates a copy of this request, with the appropriate auth headers or parameters added.
     *
     * @deprecated discontinued in v3.x
     * @note This function does not take care of resolving variables.
     * @returns {Request}
     */
    authorize: function () {
        throw new Error('collection request.authorize() has been discontinued');
    }
});

_.assign(Request, /** @lends Request */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Request',

    /**
     * Check whether an object is an instance of {@link ItemGroup}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isRequest: function (obj) {
        return Boolean(obj) && ((obj instanceof Request) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Request._postman_propertyName));
    }
});

module.exports = {
    Request: Request
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))

/***/ }),

/***/ 3979:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    VariableList = __webpack_require__(3921).VariableList,

    RequestAuth;

/**
 * This defines the definition of the authentication method to be used.
 *
 * @typedef RequestAuth~definition
 * @property {String=} type The Auth type to use. Check the names in {@link AuthTypes}
 *
 * @example <caption>Sample auth definition for Basic Auth</caption>
 * {
 *   "type": "basic",
 *   "basic": [
 *     { "key": "username", "value": "postman" },
 *     { "key": "password", "value": "secrets" }
 *   ]
 * }
 */
_.inherit((

    /**
     * A Postman Auth definition that comprehensively represents different types of auth mechanisms available.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {RequestAuth~definition} options Pass the initial definition of the Auth.
     * @param {Property|PropertyList=} [parent] optionally pass the parent of this auth. aides variable resolution.
     *
     * @example <caption>Creating a request with two auth data and one selected</caption>
     * var auth = new RequestAuth({
     *   type: 'digest',
     *
     *   basic: [
     *     { key: "username", value: "postman" },
     *     { key: "password", value: "secrets" }
     *   ],
     *   digest: [
     *     { key: "nonce", value: "aef54cde" },
     *     { key: "realm", value: "items.x" }
     *   ]
     * });
     *
     * // change the selected auth
     * auth.use('basic');
     */
    RequestAuth = function PostmanRequestAuth (options, parent) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        RequestAuth.super_.call(this, options);

        // set the parent
        parent && this.setParent(parent);

        // set the type, if passed via options
        if (_.has(options, 'type')) {
            this.use(options.type);
        }

        // load all possible auth parameters from options
        _.forEach(_.omit(options, 'type'), this.update.bind(this));
    }), Property);

_.assign(RequestAuth.prototype, /** @lends RequestAuth.prototype */ {
    /**
     * Update the parameters of a specific authentication type. If none is provided then it uses the one marked as to be
     * used.
     *
     * @param {VariableList|Array|Object} options
     * @param {String=} [type=this.type]
     */
    update: function (options, type) {
        // update must have options
        if (!_.isObject(options)) { return; }
        // validate type parameter and/or choose default from existing type.
        if (!RequestAuth.isValidType(type)) { type = this.type; }

        var parameters = this[type];

        // in case the type holder is not created, we create one and send the population variables
        if (!VariableList.isVariableList(parameters)) {
            // @todo optimise the handling of legacy object type auth parameters
            parameters = this[type] = new VariableList(this);
            parameters._postman_requestAuthType = type;
        }

        // we simply assimilate the new options either it is an array or an object
        if (_.isArray(options) || VariableList.isVariableList(options)) {
            parameters.assimilate(options);
        }
        else {
            parameters.syncFromObject(options, false, false); // params: no need to track and no need to prune
        }
    },

    /**
     * Sets the authentication type to be used by this item.
     *
     * @param {String} type
     * @param {VariableList|VariableList~definition=} options - note that options set here would replace all existing
     * options for the particular auth
     */
    use: function (type, options) {
        if (!RequestAuth.isValidType(type)) { return; }

        this.type = type; // set the type

        var parameters = this[type];

        if (!VariableList.isVariableList(parameters)) {
            parameters = this[type] = new VariableList(this);
        }

        // we simply assimilate the new options either it is an array or an object
        if (_.isArray(options) || VariableList.isVariableList(options)) {
            parameters.assimilate(options);
        }
        else {
            parameters.syncFromObject(options, false, false); // params: no need to track and no need to prune
        }
    },

    /**
     * Fetches the currently selected AuthType.
     *
     * @return {Object|undefined}
     * @deprecated Use .parameters() instead
     */
    current: function () {
        return this[this.type] ? this[this.type].toObject() : undefined;
    },

    /**
     * Returns the parameters of the selected auth type
     *
     * @returns {VariableList}
     */
    parameters: function () {
        return this[this.type];
    },

    /**
     * Clears the definition of an auth type.
     *
     * @param {String} type
     */
    clear: function (type) {
        if (!(RequestAuth.isValidType(type) && VariableList.isVariableList(this[type]))) {
            return;
        }

        // clear the variable list
        this[type].clear();

        // if it is not a currently selected auth type, do not delete the variable list, but simply delete it
        if (type !== this.type) {
            delete this[type];
        }
    }
});

_.assign(RequestAuth, /** @lends RequestAuth */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'RequestAuth',

    /**
     * Determines whether an authentication type name is valid or not
     *
     * @param {String} type
     *
     * @returns {Boolean}
     */
    isValidType: function (type) {
        // no auth name can be "type", else will have namespace collision with type selector
        return _.isString(type) && (type !== 'type');
    }
});

module.exports = {
    RequestAuth: RequestAuth
};


/***/ }),

/***/ 3980:
/***/ (function(module, exports) {

/**
 * sanitizes input string by handling escape characters eg: converts '''' to '\'\'' and trim input if required
 *
 * @param {String} inputString - Input String to sanitize
 * @param {Boolean} [trim] - Indicates whether to trim string or not
 * @returns {String} Sanitized String handling escape characters
 */
function sanitize (inputString, trim) {
  /* istanbul ignore next */
  if (typeof inputString !== 'string') {
    return '';
  }
  inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  return trim ? inputString.trim() : inputString;
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });
  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param

 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}

module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions,
  addFormParam: addFormParam
};


/***/ }),

/***/ 3981:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString - Input string being sanitized
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
    return trim ? inputString.trim() : inputString;

  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3982:
/***/ (function(module, exports) {

module.exports = {
/**
* sanitization of values : trim, escape characters
*
* @param {String} inputString - input
* @param {String} escapeCharFor - escape for headers, body: raw, formdata etc
* @param {Boolean} [inputTrim] - whether to trim the input
* @returns {String}
*/
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return JSON.stringify(inputString);
        case 'urlencoded':
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        case 'formdata':
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        case 'file':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'header':
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        default:
          return inputString.replace(/"/g, '\\"');
      }
    }
    return inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3983:
/***/ (function(module, exports) {

/**
 * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
 * and trim input if required
 *
 * @param {String} inputString
 * @param {Boolean} [trim] - indicates whether to trim string or not
 * @returns {String}
 */
function sanitize (inputString, trim) {
  if (typeof inputString !== 'string') {
    return '';
  }
  (trim) && (inputString = inputString.trim());
  return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'').replace(/\n/g, '\\n');
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}

module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions,
  addFormParam: addFormParam
};


/***/ }),

/***/ 3984:
/***/ (function(module, exports) {

module.exports = {
/**
* sanitization of values : trim, escape characters
*
* @param {String} inputString - input
* @param {String} escapeCharFor - escape for headers, body: raw, formdata etc
* @param {Boolean} [inputTrim] - whether to trim the input
* @returns {String}
*/
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return JSON.stringify(inputString);
        case 'urlencoded':
          return escape(inputString);
        case 'formdata':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'file':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'header':
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        default:
          return inputString.replace(/"/g, '\\"');
      }
    }
    return inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3985:
/***/ (function(module, exports) {

module.exports = {
  /**
    * used to sanitize eg: trim, handle escape characters
    * @param {String} inputString - input
    * @param {Boolean} [inputTrim] - whether to trim the input
    * @returns {String}
    */

  sanitize: function (inputString, inputTrim) {
    if (typeof inputString !== 'string') {
      return '';
    }

    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'').replace(/\n/g, '\\n');
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3986:
/***/ (function(module, exports) {

module.exports = {
  /**
    * used to sanitize eg: trim, handle escape characters
    * @param {String} inputString - input
    * @param {Boolean} [inputTrim] - whether to trim the input
    * @returns {String}
    */

  sanitize: function (inputString, inputTrim) {
    if (typeof inputString !== 'string') {
      return '';
    }

    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3987:
/***/ (function(module, exports) {

module.exports = {
/**
* Sanitizes input string by handling escape characters according to request body type
*
* @param {String} inputString - Input String to sanitize
* @param {String} escapeCharFor - Escape for headers, body: raw, formdata etc
* @param {Boolean} [inputTrim] - Whether to trim the input
* @returns {String} Sanitized String handling escape characters
*/
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return JSON.stringify(inputString);
        case 'urlencoded':
          return escape(inputString);
          /* istanbul ignore next */
        case 'formdata':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
          /* istanbul ignore next */
        case 'file':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'header':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        default:
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
      }
    }
    return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3988:
/***/ (function(module, exports) {

module.exports = {
/**
* sanitization of values : trim, escape characters
*
* @param {String} inputString - input
* @param {String} escapeCharFor - escape for headers, body: raw, formdata etc
* @param {Boolean} [inputTrim] - whether to trim the input
* @returns {String}
*/
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return JSON.stringify(inputString);
        case 'urlencoded':
          return escape(inputString);
        case 'formdata':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'file':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'header':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        default:
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
      }
    }
    return inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3989:
/***/ (function(module, exports) {

module.exports = {
/**
* sanitization of values : trim, escape characters
*
* @param {String} inputString - input
* @param {String} escapeCharFor - escape for headers, body: raw, formdata etc
* @param {Boolean} [inputTrim] - whether to trim the input
* @returns {String}
*/
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return JSON.stringify(inputString);
        case 'urlencoded':
          return escape(inputString);
        case 'formdata':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'file':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'header':
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        default:
          return inputString.replace(/"/g, '\\"');
      }
    }
    return inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 3990:
/***/ (function(module, exports) {

/**
 * Sanitizes input string by handling escape characters according to request body type
 *
 * @param {String} inputString - Input String to sanitize
 * @param {String} escapeCharFor - Escape character for headers, body: raw, formdata etc.
 * @param {Boolean} [inputTrim] - Indicates whether to trim string or not
 * @returns {String} Sanitized String handling escape characters
 */
function sanitize (inputString, escapeCharFor, inputTrim) {

  if (typeof inputString !== 'string') {
    return '';
  }
  inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
  if (escapeCharFor && typeof escapeCharFor === 'string') {
    switch (escapeCharFor) {
      case 'raw':
        return JSON.stringify(inputString);
      case 'urlencoded':
        return escape(inputString);
      case 'formdata':
        return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        /* istanbul ignore next */
      case 'file':
        return inputString.replace(/{/g, '[').replace(/}/g, ']');
      case 'header':
        return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        /* istanbul ignore next */
      default:
        return inputString.replace(/"/g, '\\"');
    }
  }
  return inputString;
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {*} urlObject The request sdk request.url object
 * @returns {String} The final string after parsing all the parameters of the url including
 * protocol, auth, host, port, path, query, hash
 * This will be used because the url.toString() method returned the URL with non encoded query string
 * and hence a manual call is made to getQueryString() method with encode option set as true.
 */
function getUrlStringfromUrlObject (urlObject) {
  var url = '';
  if (!urlObject) {
    return url;
  }
  if (urlObject.protocol) {
    url += (urlObject.protocol.endsWith('://') ? urlObject.protocol : urlObject.protocol + '://');
  }
  if (urlObject.auth && urlObject.auth.user) {
    url = url + ((urlObject.auth.password) ?
      // ==> username:password@
      urlObject.auth.user + ':' + urlObject.auth.password : urlObject.auth.user) + '@';
  }
  if (urlObject.host) {
    url += urlObject.getHost();
  }
  if (urlObject.port) {
    url += ':' + urlObject.port.toString();
  }
  if (urlObject.path) {
    url += urlObject.getPath();
  }
  if (urlObject.query && urlObject.query.count()) {
    let queryString = urlObject.getQueryString({ ignoreDisabled: true, encode: true });
    queryString && (url += '?' + queryString);
  }
  if (urlObject.hash) {
    url += '#' + urlObject.hash;
  }

  return url;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}

module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions,
  getUrlStringfromUrlObject: getUrlStringfromUrlObject,
  addFormParam: addFormParam
};


/***/ }),

/***/ 4086:
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]

/***/ }),

/***/ 4087:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    PropertyBase = __webpack_require__(3813).PropertyBase,
    Url = __webpack_require__(3837).Url,
    UrlMatchPatternList = __webpack_require__(4361).UrlMatchPatternList,

    STRING = 'string',
    HTTPS = 'https',

    Certificate;

/**
 * The following is the object representation accepted as param for the Certificate constructor.
 * Also the type of the object returned when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a
 * Certificate instance.
 * @typedef Certificate~definition
 * @property {String} [name] A name for the certificate
 * @property {Array} [matches] A list of match patterns
 * @property {{ src: (String) }} [key] Object with path on the file system for private key file, as src
 * @property {{ src: (String) }} [cert] Object with path on the file system for certificate file, as src
 * @property {String} [passphrase] The passphrase for the certificate key
 *
 * @example <caption>JSON definition of an example certificate object</caption>
 * {
 *     "name": "My certificate for example.com",
 *     "matches": ["https://example.com/*"],
 *     "key": { "src": "/path/to/key" },
 *     "cert": { "src": "/User/path/to/certificate" },
 *     "passphrase": "iampassphrase"
 * }
 */
_.inherit((

    /**
     * A Certificate definition that represents the ssl certificate
     * to be used for an url.
     * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with
     * all the variable references replaced by corresponding values.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {Certificate~definition=} [options] Object with matches, key, cert and passphrase
     *
     * @example <caption> Create a new Certificate</caption>
     *
     * var Certificate = require('postman-collection').Certificate,
     *    certificate = new Certificate({
     *     name: 'Certificate for example.com',
     *     matches: ['example.com'],
     *     key: { src: '/User/path/to/certificate/key' },
     *     cert: { src: '/User/path/to/certificate' },
     *     passphrase: 'iampassphrase'
     * });
     */
    Certificate = function Certificate (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Certificate.super_.apply(this, arguments);

        this.update(options);
    }), Property);

_.assign(Certificate.prototype, /** @lends Certificate.prototype */ {
    /**
     * Ensure all object have id
     * @private
     */
    _postman_propertyRequiresId: true,

    /**
     * Updates the certificate with the given properties.
     *
     * @param {Certificate~definition=} [options] Object with matches, key, cert and passphrase
     */
    update: function (options) {
        // return early if options is empty or invalid
        if (!_.isObject(options)) {
            return;
        }

        _.mergeDefined(this, /** @lends Certificate.prototype */ {
            /**
             * Unique identifier
             * @type {String}
             */
            id: options.id,

            /**
             * Name for user reference
             * @type {String}
             */
            name: options.name,

            /**
             * List of match pattern
             * @type {UrlMatchPatternList}
             */
            matches: options.matches && new UrlMatchPatternList({}, options.matches),

            /**
             * Private Key
             * @type {{ src: (string) }}
             */
            key: _.isObject(options.key) ? options.key : { src: options.key },

            /**
             * Certificate
             * @type {{ src: (string) }}
             */
            cert: _.isObject(options.cert) ? options.cert : { src: options.cert },

            /**
             * PFX or PKCS12 Certificate
             * @type {{ src: (string) }}
             */
            pfx: _.isObject(options.pfx) ? options.pfx : { src: options.pfx },

            /**
             * passphrase
             * @type {Object}
             */
            passphrase: options.passphrase
        });
    },

    /**
     * Checks if the certificate can be applied to a given url
     *
     * @param {String|Url} url The url string for which the certificate is checked for match.
     */
    canApplyTo: function (url) {
        if (_.isEmpty(url)) {
            return false;
        }

        // convert url strings to Url
        (typeof url === STRING) && (url = new Url(url));

        // this ensures we don't proceed any further for any protocol
        // that is not https
        if (url.protocol !== HTTPS) {
            return false;
        }

        // test the input url against allowed matches
        return this.matches.test(url);
    },

    /**
     * Allows the serialization of a {@link Certificate}
     *
     * This is overridden, in order to ensure that certificate contents are not accidentally serialized,
     * which can be a security risk.
     */
    toJSON: function () {
        var obj = PropertyBase.toJSON(this);

        _.unset(obj, 'key.value');
        _.unset(obj, 'cert.value');
        _.unset(obj, 'pfx.value');

        return obj;
    }
});

_.assign(Certificate, /** @lends Certificate */ {
    /**
     * Defines the name of this property for internal use
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Certificate',

    /**
     * Specify the key to be used while indexing this object
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyIndexKey: 'id',

    /**
     * Checks if the given object is a Certificate
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isCertificate: function (obj) {
        return Boolean(obj) && ((obj instanceof Certificate) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Certificate._postman_propertyName));
    }
});

module.exports = {
    Certificate: Certificate
};


/***/ }),

/***/ 4088:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,

    // @todo discontinue in v4
    urlEncoder = __webpack_require__(5307),

    Property = __webpack_require__(3787).Property,
    PropertyList = __webpack_require__(3798).PropertyList,

    AMPERSAND = '&',
    STRING = 'string',
    EQUALS = '=',
    EMPTY = '',
    BRACE_START = '{{',
    BRACE_END = '}}',
    REGEX_BRACE_START = /%7B%7B/g,
    REGEX_BRACE_END = /%7D%7D/g,

    QueryParam;

/**
 * @typedef QueryParam~definition
 * @property {String} key The name ("key") of the query parameter.
 * @property {String} value The value of the parameter.
 */
_.inherit((

    /**
     * Represents a URL query parameter, which can exist in request URL or POST data.
     *
     * @constructor
     * @extends {Property}
     * @param {FormParam~definition|String} options Pass the initial definition of the query parameter. In case of
     * string, the query parameter is parsed using {@link QueryParam.parseSingle}.
     */
    QueryParam = function PostmanQueryParam (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        QueryParam.super_.apply(this, arguments);

        this.update(options);
    }), Property);

_.assign(QueryParam.prototype, /** @lends QueryParam.prototype */ {
    /**
     * Converts the QueryParameter to a single param string.
     *
     * @returns {String}
     */
    toString: function () {
        return QueryParam.unparseSingle(this);
    },

    /**
     * Updates the key and value of the query parameter
     *
     * @param {String|Object} param
     * @param {String} param.key
     * @param {String=} [param.value]
     */
    update: function (param) {
        _.assign(this, /** @lends QueryParam.prototype */ _.isString(param) ? QueryParam.parseSingle(param) : {
            key: _.get(param, 'key'), // we do not replace falsey with blank string since null has a meaning
            value: _.get(param, 'value')
        });
        _.has(param, 'system') && (this.system = param.system);
    },

    valueOf: function () {
        return _.isString(this.value) ? this.value : EMPTY;
    }
});

_.assign(QueryParam, /** @lends QueryParam */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'QueryParam',

    /**
     * Declare the list index key, so that property lists of query parameters work correctly
     *
     * @type {String}
     */
    _postman_propertyIndexKey: 'key',

    /**
     * Query params can have multiple values, so set this to true.
     *
     * @type {Boolean}
     */
    _postman_propertyAllowsMultipleValues: true,

    /**
     * Parse a query string into an array of objects, where each object contains a key and a value.
     *
     * @param {String} query
     * @returns {Array}
     */
    parse: function (query) {
        return _.isString(query) ? query.split(AMPERSAND).map(QueryParam.parseSingle) : [];
    },

    /**
     * Parses a single query parameter.
     *
     * @param {String} param
     * @param {Number} idx
     * @param {String[]} all - array of all params, in case this is being called while parsing multiple params.
     * @returns {{key: string|null, value: string|null}}
     */
    parseSingle: function (param, idx, all) {
        // helps handle weird edge cases such as "/get?a=b&&"
        if (param === EMPTY && // if param is empty
            _.isNumber(idx) && // this and the next condition ensures that this is part of a map call
            _.isArray(all) &&
            idx !== (all && (all.length - 1))) { // not last parameter in the array
            return { key: null, value: null };
        }

        var index = (typeof param === STRING) ? param.indexOf(EQUALS) : -1,
            paramObj = {};

        // this means that there was no value for this key (not even blank, so we store this info) and the value is set
        // to null
        if (index < 0) {
            paramObj.key = param.substr(0, param.length);
            paramObj.value = null;
        }
        else {
            paramObj.key = param.substr(0, index);
            paramObj.value = param.substr(index + 1);
        }

        return paramObj;
    },

    /**
     * Create a query string from array of parameters (or object of key-values). This function ensures that
     * the double braces "{{" and "}}" are not URL-encoded on unparsing, which allows for variable-substitution.
     *
     * @param {Array|Object} params
     * @param {Object=} options
     * @param {?Boolean} [options.encode=false] - Enables URL encoding of the parameters
     * @param {?Boolean} [options.ignoreDisabled=false] - Removes disabled query parameters when set to true.
     * @returns {string}
     *
     * @deprecated since v3.4.6, drop support for `options.encode`
     *
     * @todo - remove disabled arg and flatten params (retain back compat)
     */
    unparse: function (params, options) {
        if (!params) { return EMPTY; }

        var str,
            encode = options && options.encode,
            ignoreDisabled = options && options.ignoreDisabled;

        // Convert hash maps to an array of params
        if (!_.isArray(params) && !PropertyList.isPropertyList(params)) {
            return _.reduce(params, function (result, value, key) {
                result && (result += AMPERSAND);
                return result + QueryParam.unparseSingle({ key: key, value: value }, encode);
            }, EMPTY);
        }

        // construct a query parameter string from the list, with considerations for disabled values
        str = params.reduce(function (result, param) {
            // If disabled parameters are to be ignored, bail out here
            if (ignoreDisabled && (param.disabled === true)) { return result; }

            // If the current unparsed result is non empty, append an ampersand
            result && (result += AMPERSAND);

            return result + QueryParam.unparseSingle(param, encode);
        }, EMPTY);

        encode && (str = str.replace(REGEX_BRACE_START, BRACE_START).replace(REGEX_BRACE_END, BRACE_END));

        return str;
    },

    /**
     * Takes a query param and converts to string
     *
     * @param {Object} obj
     * @param {Boolean} encode
     * @returns {String}
     *
     * @deprecated since v3.4.6, drop support for `encode`
     */
    unparseSingle: function (obj, encode) {
        if (!obj) { return EMPTY; }

        var key = obj.key,
            value = obj.value;

        if (value === undefined) {
            return EMPTY;
        }

        if (key === null) {
            key = EMPTY;
        }

        if (value === null) {
            return encode ? urlEncoder.encode(key) : key;
        }

        if (encode) {
            key = urlEncoder.encode(key);
            value = urlEncoder.encode(value);
        }

        return key + EQUALS + value;
    }
});

module.exports = {
    QueryParam: QueryParam
};


/***/ }),

/***/ 4089:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    Url = __webpack_require__(3837).Url,

    E = '',
    STRING = 'string',
    UNDEFINED = 'undefined',

    MATCH_ALL = '*',
    PREFIX_DELIMITER = '^',
    PROTOCOL_DELIMITER = '+',
    POSTFIX_DELIMITER = '$',
    MATCH_ALL_URLS = '<all_urls>',
    ALLOWED_PROTOCOLS = ['http', 'https', 'file', 'ftp'],
    ALLOWED_PROTOCOLS_REGEX = ALLOWED_PROTOCOLS.join('|'),

    // @todo initialize this and ALLOWED_PROTOCOLS via UrlMatchPattern options
    DEFAULT_PROTOCOL_PORT = {
        ftp: '21',
        http: '80',
        https: '443'
    },

    regexes = {
        escapeMatcher: /[.+^${}()|[\]\\]/g,
        escapeMatchReplacement: '\\$&',
        questionmarkMatcher: /\?/g,
        questionmarkReplacment: '.',
        starMatcher: '*',
        starReplacement: '.*',
        // @todo match valid HOST name
        // @note PATH is required(can be empty '/' or '/*') i.e, {PROTOCOL}://{HOST}/
        patternSplit: '^((' + ALLOWED_PROTOCOLS_REGEX + '|\\*)(\\+(' + ALLOWED_PROTOCOLS_REGEX +
            '))*)://(\\*|\\*\\.[^*/:]+|[^*/:]+)(:\\*|:\\d+)?(/.*)$'
    },

    UrlMatchPattern;

/**
 * UrlMatchPattern allows to create rules to define Urls to match for.
 * It is based on Google's Match Pattern - https://developer.chrome.com/extensions/match_patterns
 *
 * @param {Object} options
 * @example <caption>An example UrlMatchPattern</caption>
 * var matchPattern = new UrlMatchPattern('https://*.google.com/*');
*/
_.inherit((
    UrlMatchPattern = function UrlMatchPattern (options) {
        // called as new UrlMatchPattern('https+http://*.example.com/*')
        if (_.isString(options)) {
            options = { pattern: options };
        }

        // this constructor is intended to inherit and as such the super constructor is required to be executed
        UrlMatchPattern.super_.apply(this, arguments);

        // Assign defaults before proceeding
        _.assign(this, /** @lends UrlMatchPattern */ {
            /**
             * The url match pattern string
             * @type {String}
             */
            pattern: MATCH_ALL_URLS
        });

        this.update(options);
    }), Property);

_.assign(UrlMatchPattern.prototype, /** @lends UrlMatchPattern.prototype */ {
    /**
     * Assigns the given properties to the UrlMatchPattern.
     *
     * @param {{ pattern: (string) }} options
     */
    update: function (options) {
        _.has(options, 'pattern') && (_.isString(options.pattern) && !_.isEmpty(options.pattern)) &&
            (this.pattern = options.pattern);

        // create a match pattern and store it on cache
        this._matchPatternObject = this.createMatchPattern();
    },

    /**
     * Used to generate the match regex object from the match string we have.
     *
     * @private
     * @returns {*} Match regex object
     */
    createMatchPattern: function () {
        var matchPattern = this.pattern,
            // Check the match pattern of sanity and split it into protocol, host and path
            match = matchPattern.match(regexes.patternSplit);

        if (!match) {
            // This ensures it is a invalid match pattern
            return;
        }

        return {
            protocols: _.uniq(match[1].split(PROTOCOL_DELIMITER)),
            host: match[5],
            port: match[6] && match[6].substr(1), // remove leading `:`
            path: this.globPatternToRegexp(match[7])
        };
    },

    /**
     * Converts a given glob pattern into a regular expression.
     *
     * @private
     * @param {String} pattern Glob pattern string
     * @return {RegExp=}
     */
    globPatternToRegexp: function (pattern) {
        // Escape everything except ? and *.
        pattern = pattern.replace(regexes.escapeMatcher, regexes.escapeMatchReplacement);
        pattern = pattern.replace(regexes.questionmarkMatcher, regexes.questionmarkReplacment);
        pattern = pattern.replace(regexes.starMatcher, regexes.starReplacement);
        return new RegExp(PREFIX_DELIMITER + pattern + POSTFIX_DELIMITER);
    },

    /**
     * Tests if the given protocol string, is allowed by the pattern.
     *
     * @param {String=} protocol The protocol to be checked if the pattern allows.
     * @return {Boolean=}
     */
    testProtocol: function (protocol) {
        var matchRegexObject = this._matchPatternObject;

        return _.includes(ALLOWED_PROTOCOLS, protocol) &&
            (_.includes(matchRegexObject.protocols, MATCH_ALL) || _.includes(matchRegexObject.protocols, protocol));
    },

    /**
     * Returns the protocols supported
     *
     * @returns {Array.<String>}
     */
    getProtocols: function () {
        return _.get(this, '_matchPatternObject.protocols') || [];
    },

    /**
     * Tests if the given host string, is allowed by the pattern.
     *
     * @param {String=} host The host to be checked if the pattern allows.
     * @return {Boolean=}
     */
    testHost: function (host) {
        /*
        * For Host match, we are considering the port with the host, hence we are using getRemote() instead of getHost()
        * We need to address three cases for the host urlStr
        * 1. * It matches all the host + protocol,  hence we are not having any parsing logic for it.
        * 2. *.foo.bar.com Here the prefix could be anything but it should end with foo.bar.com
        * 3. foo.bar.com This is the absolute matching needs to done.
        */
        var matchRegexObject = this._matchPatternObject;
        return (
            this.matchAnyHost(matchRegexObject) ||
            this.matchAbsoluteHostPattern(matchRegexObject, host) ||
            this.matchSuffixHostPattern(matchRegexObject, host)
        );
    },

    /**
     * Checks whether the matchRegexObject has the MATCH_ALL host.
     *
     * @private
     * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.
     * @return {Boolean}
     */
    matchAnyHost: function (matchRegexObject) {
        return matchRegexObject.host === MATCH_ALL;
    },


    /**
      * Check for the (*.foo.bar.com) kind of matches with the remote provided.
     *
      * @private
      * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.
      * @param {String=} remote The remote url (host+port) of the url for which the hostpattern needs to checked
      * @return {Boolean}
      */
    matchSuffixHostPattern: function (matchRegexObject, remote) {
        var hostSuffix = matchRegexObject.host.substr(2);
        return matchRegexObject.host[0] === MATCH_ALL && (remote === hostSuffix || remote.endsWith('.' + hostSuffix));
    },

    /**
     * Check for the absolute host match.
     *
     * @private
     * @param {Object=} matchRegexObject The regex object generated by the createMatchPattern function.
     * @param {String=} remote The remote url, host+port of the url for which the hostpattern needs to checked
     * @return {Boolean}
     */
    matchAbsoluteHostPattern: function (matchRegexObject, remote) {
        return matchRegexObject.host === remote;
    },

    /**
     * Tests if the current pattern allows the given port.
     *
     * @param {String} port The port to be checked if the pattern allows.
     * @param {String} protocol Protocol to refer default port.
     * @return {Boolean}
     */
    testPort: function (port, protocol) {
        var portRegex = this._matchPatternObject.port,

            // default port for given protocol
            defaultPort = protocol && DEFAULT_PROTOCOL_PORT[protocol];

        // return true if both given port and match pattern are absent
        if (typeof port === UNDEFINED && typeof portRegex === UNDEFINED) {
            return true;
        }

        // convert integer port to string
        (port && typeof port !== STRING) && (port = String(port));

        // assign default port or portRegex
        !port && (port = defaultPort);
        !portRegex && (portRegex = defaultPort);

        // matches * or specific port
        return (
            portRegex === MATCH_ALL ||
            portRegex === port
        );
    },

    /**
     * Tests if the current pattern allows the given path.
     *
     * @param {String=} path The path to be checked if the pattern allows.
     * @return {Boolean=}
     */
    testPath: function (path) {
        var matchRegexObject = this._matchPatternObject;
        return !_.isEmpty(path.match(matchRegexObject.path));
    },

    /**
      * Tests the url string with the match pattern provided.
      * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching
      *
      * @param {String=} urlStr The url string for which the proxy match needs to be done.
      * @returns {Boolean=}
      */
    test: function (urlStr) {
        /*
        * This function executes the code in the following sequence for early return avoiding the costly regex matches.
        * To avoid most of the memory consuming code.
        * 1. It check whether the match string is <all_urls> in that case, it return immediately without any further
        *    processing.
        * 2. Checks whether the matchPattern follows the rules, https://developer.chrome.com/extensions/match_patterns,
        *    If not then, dont process it.
        * 3. Check for the protocol, as it is a normal array check.
        * 4. Checks the host, as it doesn't involve regex match and has only string comparisons.
        * 5. Finally, checks for the path, which actually involves the Regex matching, the slow process.
        */
        // If the matchPattern is <all_urls> then there is no need for any validations.
        if (this.pattern === MATCH_ALL_URLS) {
            return true;
        }

        var url,
            matchRegexObject = this._matchPatternObject;

        // Empty matchRegexObject represents the match is INVALID match
        if (_.isEmpty(matchRegexObject)) {
            return false;
        }

        try {
            url = new Url(urlStr);
        }
        catch (e) {
            return false;
        }

        return (this.testProtocol(url.protocol) &&
            this.testHost(url.getHost()) &&
            this.testPort(url.port, url.protocol) &&
            this.testPath(url.getPath()));
    },

    /**
     * Returns a string representation of the match pattern
     *
     * @return {String=} pattern
     */
    toString: function () {
        return _.isString(this.pattern) ? this.pattern : E;
    },

    /**
     * Returns the JSON representation.
     *
     * @return {{ pattern: (string) }}
     */
    toJSON: function () {
        var pattern;
        pattern = this.toString();

        return {
            pattern: pattern
        };
    }
});

_.assign(UrlMatchPattern, /** @lends UrlMatchPattern */ {
    /**
     * Defines the name of this property for internal use
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'UrlMatchPattern',

    /**
     * Multiple protocols in the match pattern should be separated by this string
     * @readOnly
     * @type {String}
     */
    PROTOCOL_DELIMITER: PROTOCOL_DELIMITER,

    /**
     * String representation for matching all urls - <all_urls>
     * @readOnly
     * @type {String}
     */
    MATCH_ALL_URLS: MATCH_ALL_URLS
});

module.exports = {
    UrlMatchPattern: UrlMatchPattern
};


/***/ }),

/***/ 4090:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    Event = __webpack_require__(4363).Event,

    EventList;

_.inherit((

    /**
     * A type of {@link PropertyList}, EventList handles resolving events from parents. If an {@link ItemGroup} contains
     * a set of events, each {@link Item} in that group will inherit those events from its parent, and so on.
     *
     * @constructor
     * @param {Object} parent
     * @param {Object[]} populate
     * @extends {PropertyList}
     *
     * This is useful when we need to have a common test across all requests.
     */
    EventList = function PostmanEventList (parent, populate) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        EventList.super_.call(this, Event, parent, populate);
    }), PropertyList);

_.assign(EventList.prototype, /** @lends EventList.prototype */ {
    /**
     * Returns an array of listeners filtered by the listener name
     *
     * @note
     * If one needs to access disabled events, use {@link PropertyList#all} or
     * any other similar {@link PropertyList} method.
     *
     * @param {String} name
     * @returns {Array<Event>}
     */
    listeners: function (name) {
        var all;

        // we first procure all matching events from this list
        all = this.listenersOwn(name);

        this.eachParent(function (parent) {
            var parentEvents;

            // we check that the parent is not immediate mother. then we check whether the non immediate mother has a
            // valid `events` store and only if this store has events with specified listener, we push them to the
            // array we are compiling for return
            (parent !== this.__parent) && EventList.isEventList(parent.events) &&
                (parentEvents = parent.events.listenersOwn(name)) && parentEvents.length &&
                all.unshift.apply(all, parentEvents); // eslint-disable-line prefer-spread
        }, this);

        return all;
    },

    /**
     * Returns all events with specific listeners only within this list. Refer to {@link EventList#listeners} for
     * procuring all inherited events
     *
     * @param {string} name
     * @returns {Array<Event>}
     */
    listenersOwn: function (name) {
        return this.filter(function (event) {
            return (!event.disabled && event.listen === name);
        });
    }
});

_.assign(EventList, /** @lends EventList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'EventList',

    /**
     * Checks if the given object is an EventList.
     *
     * @param {*} obj
     * @returns {boolean}
     */
    isEventList: function (obj) {
        return Boolean(obj) && ((obj instanceof EventList) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', EventList._postman_propertyName));
    }
});

module.exports = {
    EventList: EventList
};


/***/ }),

/***/ 4091:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    Url = __webpack_require__(3837).Url,
    UrlMatchPattern = __webpack_require__(4089).UrlMatchPattern,
    ProxyConfig,
    PROTOCOL_DELIMITER = UrlMatchPattern.PROTOCOL_DELIMITER,
    E = '',
    COLON = ':',
    DEFAULT_PORT = 8080,
    PROTOCOL_HOST_SEPARATOR = '://',
    MATCH_ALL_HOST_AND_PATH = '*:*/*',
    AUTH_CREDENTIALS_SEPARATOR = '@',
    DEFAULT_PROTOCOL = 'http',
    ALLOWED_PROTOCOLS = ['http', 'https'],
    // 'http+https://*:*/*'
    DEFAULT_PATTERN = ALLOWED_PROTOCOLS.join(PROTOCOL_DELIMITER) + PROTOCOL_HOST_SEPARATOR + MATCH_ALL_HOST_AND_PATH;

/**
* The following is the object structure accepted as constructor parameter while calling `new ProxyConfig(...)`. It is
* also the structure exported when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a
* Proxy instance.
* @typedef ProxyConfig~definition
*
* @property {String=} [match = 'http+https://*\/*'] The match for which the proxy needs to be configured.
* @property {String=} [host = ''] The proxy server url.
* @property {Integer=} [port = 8080] The proxy server port number.
* @property {Boolean=} [tunnel = false] The tunneling option for the proxy request.
* @property {Boolean=} [disabled = false] To override the proxy for the particular url, you need to provide true.
* @property {Boolean=} [authenticate = false] To enable authentication for the proxy, you need to provide true.
* @property {String=} [username] The proxy authentication username
* @property {String=} [password] The proxy authentication password
*
* @example <caption>JSON definition of an example proxy object</caption>
* {
*     "match": "http+https://example.com/*",
*     "host": "proxy.com",
*     "port": "8080",
*     "tunnel": true,
*     "disabled": false
* }
*/
_.inherit((

    /**
     * A ProxyConfig definition that represents the proxy configuration for an url match.
     * Properties can then use the `.toObjectResolved` function to procure an object representation of the property with
     * all the variable references replaced by corresponding values.
     *
     * @constructor
     * @extends {Property}
     * @param {ProxyConfig~definition=} [options] - Specifies object with props matches, server and tunnel.
     *
     * @example <caption>Create a new ProxyConfig</caption>
     * var ProxyConfig = require('postman-collection').ProxyConfig,
     *     myProxyConfig = new ProxyConfig({
     *          host: 'proxy.com',
     *          match: 'http+https://example.com/*',
     *          port: 8080,
     *          tunnel: true,
     *          disabled: false
     *     });
     */
    ProxyConfig = function ProxyConfig (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        ProxyConfig.super_.call(this, options);

        // Assign defaults before proceeding
        _.assign(this, /** @lends ProxyConfig */ {
            /**
             * The proxy server host or ip
             * @type {String}
             */
            host: E,

            /**
             * The url mach for which the proxy has been associated with.
             * @type {String}
             */
            match: new UrlMatchPattern(DEFAULT_PATTERN),

            /**
             * The proxy server port number
             * @type {Integer}
             */
            port: DEFAULT_PORT,

            /**
             * This represents whether the tunneling needs to done while proxying this request.
             * @type Boolean
             */
            tunnel: false,

            /**
             * Enable proxy authentication
             * @type {Boolean}
             */
            authenticate: false,

            /**
             * Proxy auth username
             * @type {String}
             */
            username: undefined,

            /**
             * Proxy auth password
             * @type {String}
             */
            password: undefined
        });

        this.update(options);
    }), Property);

_.assign(ProxyConfig.prototype, /** @lends ProxyConfig.prototype */ {
    /**
     * Defines whether this property instances requires an id
     * @private
     * @readOnly
     * @type {Boolean}
     */
    _postman_propertyRequiresId: true,

    /**
     * Updates the properties of the proxy object based on the options provided.
     *
     * @param {ProxyConfig~definition} options The proxy object structure.
     */
    update: function (options) {
        if (!_.isObject(options)) {
            return;
        }

        var parsedUrl,
            port = _.get(options, 'port') >> 0;

        if (_.isString(options.host)) {
            // strip the protocol from given host
            parsedUrl = new Url(options.host);
            this.host = parsedUrl.getHost();
        }

        _.isString(options.match) && (this.match = new UrlMatchPattern(options.match));
        _.isString(_.get(options, 'match.pattern')) && (this.match = new UrlMatchPattern(options.match.pattern));
        port && (this.port = port);
        _.isBoolean(options.tunnel) && (this.tunnel = options.tunnel);
        // todo: Add update method in parent class Property and call that here
        _.isBoolean(options.disabled) && (this.disabled = options.disabled);
        _.isBoolean(options.authenticate) && (this.authenticate = options.authenticate);
        _.isString(options.username) && (this.username = options.username);
        _.isString(options.password) && (this.password = options.password);
    },

    /**
     * Updates the protocols in the match pattern
     *
     * @param {Array.<String>} protocols The array of protocols
     */
    updateProtocols: function (protocols) {
        if (!protocols) {
            return;
        }

        var updatedProtocols,
            hostAndPath = _.split(this.match.pattern, PROTOCOL_HOST_SEPARATOR)[1];

        if (!hostAndPath) {
            return;
        }

        updatedProtocols = _.intersection(ALLOWED_PROTOCOLS, _.castArray(protocols));
        _.isEmpty(updatedProtocols) && (updatedProtocols = ALLOWED_PROTOCOLS);

        this.match.update({
            pattern: updatedProtocols.join(PROTOCOL_DELIMITER) + PROTOCOL_HOST_SEPARATOR + hostAndPath
        });
    },

    /**
     * Tests the url string with the match provided.
     * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching
     *
     * @param {String=} [urlStr] The url string for which the proxy match needs to be done.
     */
    test: function (urlStr) {
        var protocol = Url.isUrl(urlStr) ? urlStr.protocol : (Url.parse(urlStr || E).protocol || E);

        // to allow target URLs without any protocol. e.g.: 'foo.com/bar'
        if (_.isEmpty(protocol)) {
            protocol = DEFAULT_PROTOCOL;
            urlStr = protocol + PROTOCOL_HOST_SEPARATOR + urlStr;
        }

        // this ensures we don't proceed any further for any non-supported protocol
        if (!_.includes(ALLOWED_PROTOCOLS, protocol)) {
            return false;
        }

        return this.match.test(urlStr);
    },

    /**
     * Returns the proxy server url.
     *
     * @returns {String}
     */
    getProxyUrl: function () {
        var auth = E;

        // Add authentication method to URL if the same is requested. We do it this way because
        // this is how `postman-request` library accepts auth credentials in its proxy configuration.
        if (this.authenticate) {
            auth = (this.username || E);

            if (this.password) {
                auth += (COLON + (this.password || E));
            }

            if (auth) {
                auth += AUTH_CREDENTIALS_SEPARATOR;
            }
        }

        return DEFAULT_PROTOCOL + PROTOCOL_HOST_SEPARATOR + auth + this.host + COLON + this.port;
    },

    /**
     * Returns the protocols supported.
     *
     * @returns {Array.<String>}
     */
    getProtocols: function () {
        return this.match.getProtocols();
    }
});

_.assign(ProxyConfig, /** @lends ProxyConfig */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'ProxyConfig',

    /**
     * Check whether an object is an instance of PostmanItem.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isProxyConfig: function (obj) {
        return Boolean(obj) && ((obj instanceof ProxyConfig) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', ProxyConfig._postman_propertyName));
    }
});

module.exports = {
    ProxyConfig: ProxyConfig,
    ALLOWED_PROTOCOLS: ALLOWED_PROTOCOLS,
    DEFAULT_PATTERN: DEFAULT_PATTERN
};


/***/ }),

/***/ 4092:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    Header = __webpack_require__(4093).Header,

    E = '',
    CRLF = '\r\n',
    PROP_NAME = '_postman_propertyName',

    HeaderList;

_.inherit((

    /**
    * Contains a list of header elements
    *
    * @constructor
    * @param {Object} parent
    * @param {Header[]} headers
    * @extends {PropertyList}
    */
    HeaderList = function (parent, headers) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        HeaderList.super_.call(this, Header, parent, headers);
    }), PropertyList);

_.assign(HeaderList.prototype, /** @lends HeaderList.prototype */ {
    /**
     * Gets size of a list of headers excluding standard header prefix.
     *
     * @returns {Number}
     */
    contentSize: function () {
        if (!this.count()) { return 0; }

        var raw = this.reduce(function (acc, header) {
            // unparse header only if it has a valid key and is not disabled
            if (header && !header.disabled) {
                // *( header-field CRLF )
                acc += Header.unparseSingle(header) + CRLF;
            }

            return acc;
        }, E);

        return raw.length;
    }
});

_.assign(HeaderList, /** @lends HeaderList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'HeaderList',

    /**
     * Checks if the given object is a HeaderList
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isHeaderList: function (obj) {
        return Boolean(obj) && ((obj instanceof HeaderList) ||
          _.inSuperChain(obj.constructor, PROP_NAME, HeaderList._postman_propertyName));
    }
});

module.exports = {
    HeaderList: HeaderList
};


/***/ }),

/***/ 4093:
/***/ (function(module, exports, __webpack_require__) {

var util = __webpack_require__(3767),
    _ = util.lodash,

    E = '',
    SPC = ' ',
    HEADER_KV_SEPARATOR = ':',

    Property = __webpack_require__(3787).Property,
    PropertyList = __webpack_require__(3798).PropertyList,
    Header;

/**
 * @typedef Header~definition
 * @property {String} key The Header name (e.g: 'Content-Type')
 * @property {String} value The value of the header.
 *
 * @example <caption>Create a header</caption>
 * var Header = require('postman-collection').Header,
 *     header = new Header({
 *         key: 'Content-Type',
 *         value: 'application/xml'
 *     });
 *
 * console.log(header.toString()) // prints the string representation of the Header.
 */
_.inherit((

    /**
     * Represents an HTTP header, for requests or for responses.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {Header~definition|String} options - Pass the header definition as an object or the value of the header.
     * If the value is passed as a string, it should either be in `name:value` format or the second "name" parameter
     * should be used to pass the name as string
     * @param {String} [name] - optional override the header name or use when the first parameter is the header value as
     * string.
     *
     * @example <caption>Parse a string of headers into an array of Header objects</caption>
     * var Header = require('postman-collection').Header,
     *     headerString = 'Content-Type: application/json\nUser-Agent: MyClientLibrary/2.0\n';
     *
     * var rawHeaders = Header.parse(headerString);
     * console.log(rawHeaders); // [{ 'Content-Type': 'application/json', 'User-Agent': 'MyClientLibrary/2.0' }]
     *
     * var headers = rawHeaders.map(function (h) {
     *     return new Header(h);
     * });
     *
     * function assert(condition, message) {
     *       if (!condition) {
     *           message = message || "Assertion failed";
     *           if (typeof Error !== "undefined") {
     *               throw new Error(message);
     *           }
     *           throw message; //fallback
     *       }
     *       else {
     *           console.log("Assertion passed");
     *       }
     *   }
     *
     * assert(headerString.trim() === Header.unparse(headers).trim());
     */
    Header = function PostmanHeader (options, name) {
        if (_.isString(options)) {
            options = _.isString(name) ? { key: name, value: options } : Header.parseSingle(options);
        }

        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Header.super_.apply(this, arguments);

        this.update(options);
    }), Property);

_.assign(Header.prototype, /** @lends Header.prototype */ {
    /**
     * Converts the header to a single header string.
     *
     * @returns {String}
     */
    toString: function () {
        return this.key + ': ' + this.value;
    },

    /**
     * Return the value of this header.
     *
     * @return {String}
     */
    valueOf: function () {
        return this.value;
    },

    /**
     * Assigns the given properties to the Header
     *
     * @param {Object} options
     * @todo check for allowed characters in header key-value or store encoded.
     */
    update: function (options) {
        /**
         * The header Key
         * @type {String}
         * @todo avoid headers with falsy key.
         */
        this.key = _.get(options, 'key') || E;

        /**
         * The header value
         * @type {String}
         */
        this.value = _.get(options, 'value') || E;

        /**
         * Indicates whether the header was added by internal SDK operations, such as authorizing a request.
         * @type {*|boolean}
         */
        _.has(options, 'system') && (this.system = options.system);

        /**
         * Indicates whether the header should be .
         * @type {*|boolean}
         * @todo figure out whether this should be in property.js
         */
        _.has(options, 'disabled') && (this.disabled = options.disabled);
    }
});

_.assign(Header, /** @lends Header */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Header',

    /**
     * Specify the key to be used while indexing this object
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyIndexKey: 'key',

    /**
     * Specifies whether the index lookup of this property, when in a list is case insensitive or not
     * @private
     * @readOnly
     * @type {boolean}
     */
    _postman_propertyIndexCaseInsensitive: true,

    /**
     * Since each header may have multiple possible values, this is set to true.
     *
     * @private
     * @readOnly
     * @type {Boolean}
     */
    _postman_propertyAllowsMultipleValues: true,

    /**
     * Parses a multi line header string into an array of {@link Header~definition}.
     *
     * @param {String} headerString
     * @returns {Array}
     */
    parse: function (headerString) {
        var headers = [],
            regexes = {
                header: /^(\S+):(.*)$/gm,
                fold: /\r\n([ \t])/g,
                trim: /^\s*(.*\S)?\s*$/
            },
            match = regexes.header.exec(headerString);
        headerString = headerString.toString().replace(regexes.fold, '$1');

        while (match) {
            headers.push({
                key: match[1],
                value: match[2].replace(regexes.trim, '$1')
            });
            match = regexes.header.exec(headerString);
        }
        return headers;
    },

    /**
     * Parses a single Header.
     *
     * @param {String} header
     * @returns {{key: string, value: string}}
     */
    parseSingle: function (header) {
        if (!_.isString(header)) { return { key: E, value: E }; }

        var index = header.indexOf(HEADER_KV_SEPARATOR),
            key,
            value;

        (index < 0) && (index = header.length);

        key = header.substr(0, index);
        value = header.substr(index + 1);

        return {
            key: _.trim(key),
            value: _.trim(value)
        };
    },

    /**
     * Stringifies an Array or {@link PropertyList} of Headers into a single string.
     *
     * @param {Array|PropertyList<Header>} headers
     * @param {String=} separator - Specify a string for separating each header, by default, '\n', but sometimes,
     * it might be more useful to use a carriage return ('\r\n')
     * @returns {string}
     */
    unparse: function (headers, separator) {
        if (!_.isArray(headers) && !PropertyList.isPropertyList(headers)) {
            return E;
        }

        return headers.map(Header.unparseSingle).join(separator ? separator : '\n');
    },

    /**
     * Unparses a single Header.
     *
     * @param {String} header
     * @returns {String}
     */
    unparseSingle: function (header) {
        if (!_.isObject(header)) { return E; }
        return header.key + HEADER_KV_SEPARATOR + SPC + header.value;
    },

    /**
     * Check whether an object is an instance of PostmanHeader.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isHeader: function (obj) {
        return Boolean(obj) && ((obj instanceof Header) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Header._postman_propertyName));
    },

    /* eslint-disable jsdoc/check-param-names */
    /**
     * Create a new header instance
     *
     * @param {Header~definition|String} [value] - Pass the header definition as an object or the value of the header.
     * If the value is passed as a string, it should either be in `name:value` format or the second "name" parameter
     * should be used to pass the name as string
     * @param {String} [name] - optional override the header name or use when the first parameter is the header value as
     * string.
     * @returns {Header}
     */
    create: function () {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(Header);
        return new (Header.bind.apply(Header, args))(); // eslint-disable-line prefer-spread
    }
    /* eslint-enable jsdoc/check-param-names */
});

module.exports = {
    Header: Header
};


/***/ }),

/***/ 4094:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
    return trim ? inputString.trim() : inputString;

  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4095:
/***/ (function(module, exports) {


/**
 * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
 * and trim input if required
 *
 * @param {String} inputString
 * @param {Boolean} [trim] - indicates whether to trim string or not
 * @returns {String}
 */
function sanitize (inputString, trim) {
  if (typeof inputString !== 'string') {
    return '';
  }
  (trim) && (inputString = inputString.trim());
  return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}
module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions,
  addFormParam: addFormParam
};


/***/ }),

/***/ 4096:
/***/ (function(module, exports) {

/**
 * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
 * and trim input if required
 *
 * @param {String} inputString
 * @param {Boolean} [trim] - indicates whether to trim string or not
 * @returns {String}
 */
function sanitize (inputString, trim) {
  if (typeof inputString !== 'string') {
    return '';
  }
  inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
  return trim ? inputString.trim() : inputString;
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}
module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions,
  addFormParam: addFormParam
};


/***/ }),

/***/ 4097:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
    return trim ? inputString.trim() : inputString;

  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4098:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');

    return trim ? inputString.trim() : inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;

    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }

    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4099:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    (trim) && (inputString = inputString.trim());
    return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'').replace(/\n/g, '\\n');
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4100:
/***/ (function(module, exports) {


/**
 * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
 * and trim input if required
 *
 * @param {String} inputString
 * @param {Boolean} [trim] - indicates whether to trim string or not
 * @returns {String}
 */
function sanitize (inputString, trim) {
  if (typeof inputString !== 'string') {
    return '';
  }
  (trim) && (inputString = inputString.trim());
  return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'').replace(/\n/g, '\\n');
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}
module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions
};


/***/ }),

/***/ 4101:
/***/ (function(module, exports) {

module.exports = {
  /**
     * sanitizes input string by handling escape characters eg: converts '''' to '\'\''
     * and trim input if required
     *
     * @param {String} inputString
     * @param {Boolean} [trim] - indicates whether to trim string or not
     * @returns {String}
     */
  sanitize: function (inputString, trim) {
    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"').replace(/\n/g, '\\n');
    return trim ? inputString.trim() : inputString;

  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
   *
   * @param {Array} array - form data array
   * @param {String} key - key of form data param
   * @param {String} type - type of form data param(file/text)
   * @param {String} val - value/src property of form data param
   * @param {String} disabled - Boolean denoting whether the param is disabled or not
   * @param {String} contentType - content type header of the param
   *
   * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4102:
/***/ (function(module, exports) {

module.exports = {
  /**
    * sanitization of values : trim, escape characters
    *
    * @param {String} inputString - input
    * @param {String} escapeCharFor - escape for headers, body: raw, formdata etc
    * @param {Boolean} [inputTrim] - whether to trim the input
    * @returns {String} Sanitized String handling escape characters
    */
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return JSON.stringify(inputString);
        case 'urlencoded':
          return escape(inputString);
        case 'formdata-key':
          // eslint-disable-next-line quotes
          return inputString.replace(/"/g, "'");
        case 'formdata-value':
          // eslint-disable-next-line no-useless-escape
          return inputString.replace(/\\\"/g, '\\\\\"').replace(/\"/g, '\\"');
        case 'header':
          return inputString.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
        default:
          return inputString.replace(/"/g, '\\"');
      }
    }
    return inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4103:
/***/ (function(module, exports) {

/* eslint-disable no-useless-escape */
/**
 * sanitizes input string by handling escape characters eg: converts '''' to '\`'\`''
 * and trim input if required
 *
 * @param {String} inputString
 * @param {Boolean} [trim] - indicates whether to trim string or not
 * @returns {String}
 */
function sanitize (inputString, trim) {
  if (typeof inputString !== 'string') {
    return '';
  }
  inputString = inputString.replace(/\\/g, '\`\\').replace(/\"/g, '\`\"').replace(/\n/g, '\`n');
  return trim ? inputString.trim() : inputString;
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}

module.exports = {
  sanitize: sanitize,
  sanitizeOptions: sanitizeOptions,
  addFormParam: addFormParam
};


/***/ }),

/***/ 4104:
/***/ (function(module, exports) {

module.exports = {
  quote: function (value, mode) {
    if (typeof value !== 'string' || value === '') {
      return '';
    }
    switch (mode) {
      case 'raw':
        return '\'' + value.replace(/\\/g, '\\\\').replace(/'/g, '\'\\\'\'').replace(/%/, '%%') + '\'';
      default:
        return '\'' + value.replace(/\\/g, '\\\\').replace(/'/g, '\'\\\'\'') + '\'';
    }
  },

  /**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  },

  /**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
  addFormParam: function (array, key, type, val, disabled, contentType) {
    if (type === 'file') {
      array.push({
        key: key,
        type: type,
        src: val,
        disabled: disabled,
        contentType: contentType
      });
    }
    else {
      array.push({
        key: key,
        type: type,
        value: val,
        disabled: disabled,
        contentType: contentType
      });
    }
  }
};


/***/ }),

/***/ 4105:
/***/ (function(module, exports) {

module.exports = {
/**
* sanitization of values : trim, escape characters
*
* @param {String} inputString - input
* @param {String} escapeCharFor - escape for headers, body: raw, formdata etc
* @param {Boolean} [inputTrim] - whether to trim the input
* @returns {String}
*/
  sanitize: function (inputString, escapeCharFor, inputTrim) {

    if (typeof inputString !== 'string') {
      return '';
    }
    inputString = inputTrim && typeof inputTrim === 'boolean' ? inputString.trim() : inputString;
    if (escapeCharFor && typeof escapeCharFor === 'string') {
      switch (escapeCharFor) {
        case 'raw':
          return inputString.replace(/'/g, '\'\\\'\'');
        case 'urlencoded':
          return encodeURIComponent(inputString).replace(/'/g, '\'\\\'\'');
        case 'formdata':
          return inputString.replace(/'/g, '\\\'');
          /* istanbul ignore next */
        case 'file':
          return inputString.replace(/\\/g, '\\\\').replace(/'/g, '\\\'');
        case 'header':
          return inputString.replace(/'/g, '\'\\\'\'');
        case 'url':
          return inputString.replace(/'/g, '\'\\\'\'');
        default:
          return inputString.replace(/'/g, '\'');
      }
    }
    return inputString;
  },

  /**
    * sanitizes input options
    *
    * @param {Object} options - Options provided by the user
    * @param {Array} optionsArray - options array received from getOptions function
    *
    * @returns {Object} - Sanitized options object
    */
  sanitizeOptions: function (options, optionsArray) {
    var result = {},
      defaultOptions = {},
      id;
    optionsArray.forEach((option) => {
      defaultOptions[option.id] = {
        default: option.default,
        type: option.type
      };
      if (option.type === 'enum') {
        defaultOptions[option.id].availableOptions = option.availableOptions;
      }
    });

    for (id in options) {
      if (options.hasOwnProperty(id)) {
        if (defaultOptions[id] === undefined) {
          continue;
        }
        switch (defaultOptions[id].type) {
          case 'boolean':
            if (typeof options[id] !== 'boolean') {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'positiveInteger':
            if (typeof options[id] !== 'number' || options[id] < 0) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          case 'enum':
            if (!defaultOptions[id].availableOptions.includes(options[id])) {
              result[id] = defaultOptions[id].default;
            }
            else {
              result[id] = options[id];
            }
            break;
          default:
            result[id] = options[id];
        }
      }
    }

    for (id in defaultOptions) {
      if (defaultOptions.hasOwnProperty(id)) {
        if (result[id] === undefined) {
          result[id] = defaultOptions[id].default;
        }
      }
    }
    return result;
  }
};


/***/ }),

/***/ 4357:
/***/ (function(module, exports) {

module.exports = [["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93]]

/***/ }),

/***/ 4358:
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]

/***/ }),

/***/ 4359:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    marked = __webpack_require__(1078),
    sanitizeHtml = __webpack_require__(740),
    escapeHtml = __webpack_require__(1074),

    E = '',
    DEFAULT_MIMETYPE = 'text/plain',
    MARKDOWN_DEFAULT_OPTIONS = {
        renderer: new marked.Renderer(),
        gfm: true,
        tables: true,
        breaks: false,
        pedantic: false,
        sanitize: false,
        smartLists: true,
        smartypants: false
    },
    HTML_DEFAULT_OPTIONS = {
        allowedTags: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'p', 'a', 'ul', 'ol', 'nl', 'li', 'b', 'i',
            'strong', 'em', 'strike', 'code', 'hr', 'br', 'div', 'table', 'thead', 'caption', 'tbody', 'tr', 'th', 'td',
            'pre', 'img', 'abbr', 'address', 'section', 'article', 'aside', 'dd', 'dl', 'dt', 'tfoot'],
        allowedAttributes: {
            a: ['href'],
            img: ['src', 'width', 'height', 'alt'],
            td: ['align'],
            th: ['align']
        }
    },

    Description;

// Set the default markdown options
marked.setOptions(MARKDOWN_DEFAULT_OPTIONS);

/**
 * @typedef Description~definition
 * @property {String} content
 * @property {String} type
 */
/**
 * This is one of the properties that are (if provided) processed by all other properties. Any property can have an
 * instance of `Description` property assigned to it with the key name `description` and it should be treated as
 * something that "describes" the property within which it belongs. Usually this property is used to generate
 * documentation and other contextual information for a property in a Collection.
 *
 * @constructor
 *
 * @param {Description~definition|String} [definition] The content of the description can be passed as a string when it
 * is in `text/plain` format or otherwise be sent as part of an object adhering to the {@link Description~definition}
 * structure having `content` and `type`.
 *
 * @example <caption>Add a description to an instance of Collection</caption>
 *  var SDK = require('postman-collection'),
 *     Collection = SDK.Collection,
 *     Description = SDK.Description,
 *     mycollection;
 *
 * // create a blank collection
 * myCollection = new Collection();
 * myCollection.description = new Description({
 *     content: '&lt;h1&gt;Hello World&lt;/h1&gt;&lt;p&gt;I am a Collection&lt;/p&gt;',
 *     type: 'text/html'
 * });
 *
 * // alternatively, you could also use the `.describe` method of any property to set or update the description of the
 * // property.
 * myCollection.describe('Hey! This is a cool collection.');
 */
Description = function PostmanPropertyDescription (definition) {
    // if the definition is a string, it implies that this is a get of URL
    _.isString(definition) && (definition = {
        content: definition,
        type: DEFAULT_MIMETYPE
    });

    // populate the description
    definition && this.update(definition);
};

_.assign(Description.prototype, /** @lends Description.prototype */ {
    /**
     * Updates the content of this description property.
     *
     * @param {String|Description~definition} content
     * @param {String=} [type]
     * @todo parse version of description
     */
    update: function (content, type) {
        _.isObject(content) && ((type = content.type), (content = content.content));
        _.assign(this, /** @lends Description.prototype */ {
            /**
             * The raw content of the description
             *
             * @type {String}
             */
            content: content,

            /**
             * The mime-type of the description.
             *
             * @type {String}
             */
            type: type || DEFAULT_MIMETYPE
        });
    },

    /**
     * Processes the Description with the appropriate formatter as defined by {@link Description.type}
     *
     * @returns {String}
     */
    toString: function () {
        var formatter = Description.format[_.isString(this.type) && this.type.toLowerCase()];
        return (formatter ? formatter : escapeHtml)(this.content || E);
    },

    /**
     * Creates a JSON representation of the Description (as a plain Javascript object).
     *
     * @returns {{content: *, type: *, version: (string|*|string)}}
     */
    toJSON: function () {
        return {
            content: this.content,
            type: this.type
        };
    }
});

_.assign(Description, /** @lends Description */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Description',

    /**
     * The default and supported description format handlers.
     * @readOnly
     * @enum {Function}
     * @deprecated since v3.5.0, drop support for description formatter
     */
    format: {
        /**
         * Escapes HTML characters in the description content, and returns the result.
         *
         * @param {String} content
         * @returns {String}
         */
        'text/plain': function (content) {
            return escapeHtml(content); // do not allow HTML
        },

        /**
         * Returns HTML string generated after rendering raw markdown.
         *
         * @param {String} content
         * @returns {String}
         */
        'text/markdown': function (content) {
            return sanitizeHtml(marked(content));
        },

        /**
         * Removes blacklisted HTML tags from the Description.
         *
         * @param {String} content
         * @returns {String}
         */
        'text/html': function (content) {
            return sanitizeHtml(content, HTML_DEFAULT_OPTIONS);
        }
    },

    /**
     * Checks whether a property is an instance of Description object.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isDescription: function (obj) {
        return Boolean(obj) && ((obj instanceof Description) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Description._postman_propertyName));
    }
});

module.exports = {
    Description: Description
};


/***/ }),

/***/ 4360:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,

    E = '',
    ANY = 'any',
    NULL = 'null',
    STRING = 'string',

    Variable;

/**
 * The object representation of a Variable consists the variable value and type. It also optionally includes the `id`
 * and a friendly `name` of the variable. The `id` and the `name` of a variable is usually managed and used when a
 * variable is made part of a {@link VariableList} instance.
 *
 * @typedef {Object} Variable~definition
 * @property {*=} [value] - The value of the variable that will be stored and will be typecast to the `type`
 * set in the variable or passed along in this parameter.
 * @property {String=} [type] - The type of this variable from the list of types defined at {@link Variable.types}.
 *
 * @example
 * {
 *     "id": "my-var-1",
 *     "name": "MyFirstVariable",
 *     "value": "Hello World",
 *     "type": "string"
 * }
 */
_.inherit((

    /**
     * A variable inside a collection is similar to variables in any programming construct. The variable has an
     * identifier name (provided by its id) and a value. A variable is optionally accompanied by a variable type. One
     * or more variables can be associated with a collection and can be referred from anywhere else in the collection
     * using the double-brace {{variable-id}} format. Properties can then use the `.toObjectResolved` function to
     * procure an object representation of the property with all variable references replaced by corresponding values.
     *
     * @constructor
     * @extends {Property}
     * @param {Variable~definition=} [definition] - Specify the initial value and type of the variable.
     */
    Variable = function PostmanVariable (definition) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Variable.super_.apply(this, arguments);

        // check what is the property name for indexing this variable
        var indexer = this.constructor._postman_propertyIndexKey;

        _.assign(this, /** @lends Variable.prototype */ {
            /**
             * @type {Variable.types}
             */
            type: ANY,

            /**
             * @type {*}
             */
            value: undefined
        });

        if (!_.isNil(definition)) {
            /**
             * The name of the variable. This is used for referencing this variable from other locations and scripts
             * @type {String}
             * @name key
             * @memberOf Variable.prototype
             */
            _.has(definition, indexer) && (this[indexer] = definition[indexer]);
            this.update(definition);
        }
    }), Property);

_.assign(Variable.prototype, /** @lends Variable.prototype */ {
    /**
     * Gets the value of the variable.
     *
     * @returns {Variable.types}
     */
    get: function () {
        return _.isFunction(this.value) ? this.castOut(this.value()) : this.castOut(this.value);
    },

    /**
     * Sets the value of the variable.
     *
     * @param {*} value
     */
    set: function (value) {
        // @todo - figure out how secure is this!
        this.value = _.isFunction(value) ? value : this.castIn(value);
    },

    /**
     * An alias of this.get and this.set.
     *
     * @param {*=} [value]
     * @returns {*}
     */
    valueOf: function (value) {
        arguments.length && this.set(value);
        return this.get();
    },

    /**
     * Returns the stringified value of the variable.
     *
     * @returns {String}
     */
    toString: function () {
        var value = this.valueOf();

        // returns empty string if the value is
        // null or undefined or does not implement a toString
        return (!_.isNil(value) && _.isFunction(value.toString)) ? value.toString() : E;
    },

    /**
     * Typecasts a value to the {@link Variable.types} of this {@link Variable}. Returns the value of the variable
     * converted to the type specified in {@link Variable#type}.
     *
     * @param {*} value
     * @returns {*}
     */
    cast: function (value) {
        return this.castOut(value);
    },

    /**
     * Typecasts a value to the {@link Variable.types} of this {@link Variable}. Returns the value of the variable
     * converted to the type specified in {@link Variable#type}.
     *
     * @private
     * @param {*} value
     * @returns {*}
     */
    castIn: function (value) {
        var handler = Variable.types[this.type] || Variable.types.any;
        return _.isFunction(handler) ? handler(value) : handler.in(value);
    },

    /**
     * Typecasts a value from the {@link Variable.types} of this {@link Variable}. Returns the value of the variable
     * converted to the type specified in {@link Variable#type}.
     *
     * @private
     * @param {*} value
     * @returns {*}
     */
    castOut: function (value) {
        var handler = Variable.types[this.type] || Variable.types.any;
        return _.isFunction(handler) ? handler(value) : handler.out(value);
    },

    /**
     * Sets or gets the type of the value.
     *
     * @param {String} typeName
     * @param {Boolean} _noCast
     * @returns {String} - returns the current type of the variable from the list of {@link Variable.types}
     */
    valueType: function (typeName, _noCast) {
        !_.isNil(typeName) && (typeName = typeName.toString().toLowerCase()); // sanitize
        if (!Variable.types[typeName]) {
            return this.type || ANY; // @todo: throw new Error('Invalid variable type.');
        }

        // set type if it is valid
        this.type = typeName;

        // 1. get the current value
        // 2. set the new type if it is valid and cast the stored value
        // 3. then set the interstitial value
        var interstitialCastValue;

        // do not touch value functions
        if (!(_noCast || _.isFunction(this.value))) {
            interstitialCastValue = this.get();
            this.set(interstitialCastValue);
            interstitialCastValue = null; // just a precaution
        }

        return this.type;
    },

    /**
     * Updates the type and value of a variable from an object or JSON definition of the variable.
     *
     * @param {Variable~definition} options
     */
    update: function (options) {
        if (!_.isObject(options)) {
            return;
        }
        // set type and value.
        // @note that we cannot update the key, once created during construction
        options.hasOwnProperty('type') && this.valueType(options.type, options.hasOwnProperty('value'));
        options.hasOwnProperty('value') && this.set(options.value);
        options.hasOwnProperty('system') && (this.system = options.system);
        options.hasOwnProperty('disabled') && (this.disabled = options.disabled);
    }
});

_.assign(Variable, /** @lends Variable */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Variable',

    /**
     * Specify the key to be used while indexing this object
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyIndexKey: 'key',

    /**
     * The possible supported types of a variable is defined here. The keys defined here are the possible values of
     * {@link Variable#type}.
     *
     * Additional variable types can be supported by adding the type-casting function to this enumeration.
     * @enum {Function}
     * @readonly
     */
    types: {
        /**
         * When a variable's `type` is set to "string", it ensures that {@link Variable#get} converts the value of the
         * variable to a string before returning the data.
         */
        string: String,

        /**
         * A boolean type of variable can either be set to `true` or `false`. Any other value set is converted to
         * Boolean when procured from {@link Variable#get}.
         */
        boolean: Boolean,

        /**
         * A "number" type variable ensures that the value is always represented as a number. A non-number type value
         * is returned as `NaN`.
         */
        number: Number,

        /**
         * A "json" type value stores JSON data format
         * @deprecated Use "object" or "array" type instead. To be removed in 4.0.
         */
        json: {
            /**
             * @param {Object|Array} val
             * @returns {String}
             */
            in: function (val) {
                try {
                    // @todo: should we check if `val` is a valid JSON string?
                    val = typeof val === STRING ? val : JSON.stringify(val);
                }
                catch (e) {
                    val = NULL;
                }

                return val;
            },

            /**
             * A "json" type value stores JSON data format
             *
             * @param {String} val
             * @returns {Object}
             */
            out: function (val) {
                try {
                    val = JSON.parse(val);
                }
                catch (e) {
                    val = null;
                }

                return val;
            }
        },

        /**
         * A "array" type value stores Array data format
         */
        array: {
            /**
             * @param {Array} val
             * @returns {String}
             */
            in: function (val) {
                var value;

                try {
                    // @todo: should we check if `val` is a valid Array or Array string?
                    value = typeof val === STRING ? val : JSON.stringify(val);
                }
                catch (e) {
                    value = NULL;
                }

                return value;
            },

            /**
             * A "array" type value stores Array data format
             *
             * @param {String} val
             * @returns {Object}
             */
            out: function (val) {
                var value;

                try {
                    value = JSON.parse(val);
                }
                catch (e) {
                    value = undefined;
                }

                return Array.isArray(value) ? value : undefined;
            }
        },

        /**
         * A "object" type value stores Object data format
         */
        object: {
            /**
             * @param {Object} val
             * @returns {String}
             */
            in: function (val) {
                var value;

                try {
                    // @todo: should we check if `val` is a valid JSON string?
                    value = typeof val === STRING ? val : JSON.stringify(val);
                }
                catch (e) {
                    value = NULL;
                }

                return value;
            },

            /**
             * A "object" type value stores Object data format
             *
             * @param {String} val
             * @returns {Object}
             */
            out: function (val) {
                var value;

                try {
                    value = JSON.parse(val);
                }
                catch (e) {
                    value = undefined;
                }

                return (value instanceof Object && !Array.isArray(value)) ? value : undefined;
            }
        },

        /**
         * Free-form type of a value. This is the default for any variable, unless specified otherwise. It ensures that
         * the variable can store data in any type and no conversion is done while using {@link Variable#get}.
         */
        any: {
            /**
             * @param {*} val
             * @returns {*}
             */
            in: function (val) {
                return val; // pass through
            },

            /**
             * @param {*} val
             * @returns {*}
             */
            out: function (val) {
                return val; // pass through
            }
        }
    },

    /**
     * @param {*} obj
     * @returns {Boolean}
     */
    isVariable: function (obj) {
        return Boolean(obj) && ((obj instanceof Variable) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Variable._postman_propertyName));
    }
});

module.exports = {
    Variable: Variable
};


/***/ }),

/***/ 4361:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    Url = __webpack_require__(3837).Url,
    UrlMatchPattern = __webpack_require__(4089).UrlMatchPattern,

    MATCH_ALL_URLS = UrlMatchPattern.MATCH_ALL_URLS,

    UrlMatchPatternList;

/**
 * UrlMatchPattern is a list of UrlMatchPatterns.
 * This allows you to test for any url over a list of match patterns.
 *
 * @param {Object} parent
 * @param {String[]} list
 * @example <caption>An example UrlMatchPatternList</caption>
 * var matchPatternList = new UrlMatchPatternList(['https://*.google.com/*']);
*/
_.inherit((
    UrlMatchPatternList = function (parent, list) {
        UrlMatchPatternList.super_.call(this, UrlMatchPattern, parent, list);
    }), PropertyList);

_.assign(UrlMatchPatternList.prototype, /** @lends UrlMatchPatternList.prototype */ {

    /**
     * Allows this property to be serialised into its plural form.
     * This is here because Property.prototype.toJSON() tries to singularise
     * the keys which are PropertyLists.
     * i.e. when a property has a key - `matches = new PropertyList()`,
     * toJSON on the property tries to singularise 'matches' and ends up with 'matche'.
     *
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_proprtyIsSerialisedAsPlural: true,

    /**
      * Tests the url string with the match pattern list provided to see if it matches any of it.
      * Follows the https://developer.chrome.com/extensions/match_patterns pattern for pattern validation and matching
      *
      * @param {String=} [urlStr] The url string for which the proxy match needs to be done.
      * @returns {Boolean=}
      */
    test: function (urlStr) {
        /*
         * Similar to the UrlMatchPattern.test, however instead of testing
         * MATCH_ALL_URLS and Regex conditions serially with each of the pattern,
         * this method first searches for MATCH_ALL_URLS in all patterns
         * and then moves on to the slower Regex based searches.
         */
        var url,
            matchAllUrlsPattern,
            matchedSpecificPattern;

        matchAllUrlsPattern = this.find(function (urlMatchPattern) {
            return urlMatchPattern.pattern === MATCH_ALL_URLS;
        });

        if (_.isObject(matchAllUrlsPattern)) {
            return true;
        }

        try {
            url = new Url(urlStr);
        }
        catch (e) {
            return false;
        }

        matchedSpecificPattern = this.find(function (urlMatchPattern) {
            var matchRegexObject = urlMatchPattern._matchPatternObject;
            // Empty matchRegexObject represents the match is INVALID match
            if (_.isEmpty(matchRegexObject)) {
                return false;
            }

            return (urlMatchPattern.testProtocol(url.protocol) &&
                urlMatchPattern.testHost(url.getHost()) &&
                urlMatchPattern.testPort(url.port, url.protocol) &&
                urlMatchPattern.testPath(url.getPath()));
        });

        return Boolean(matchedSpecificPattern);
    }
});

_.assign(UrlMatchPatternList, /** @lends UrlMatchPatternList */ {
    /**
     * Defines the name of this property for internal use
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'UrlMatchPatternList'
});

module.exports = {
    UrlMatchPatternList: UrlMatchPatternList
};


/***/ }),

/***/ 4362:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    PropertyList = __webpack_require__(3798).PropertyList,
    EventList = __webpack_require__(4090).EventList,
    Item = __webpack_require__(4365).Item,
    Request = __webpack_require__(3978).Request,
    RequestAuth = __webpack_require__(3979).RequestAuth,

    ItemGroup,

    /**
     * @private
     * @type {String}
     */
    OBJECT = 'object';

/**
 * The following defines the object (or JSON) structure that one can pass to the ItemGroup while creating a new
 * ItemGroup instance. This is also the object structure returned when `.toJSON()` is called on an ItemGroup instance.
 *
 * @typedef ItemGroup~definition
 * @property {Array<ItemGroup~definition|Item~definition>=} [item]
 * @property {RequestAuth~definition=} [auth]
 * @property {Array<Event~definition>=} [event]
 *
 * @example
 * {
 *     "name": "Echo Get Requests",
 *     "id": "echo-get-requests",
 *     "item": [{
 *         "request": "https://postman-echo.com/get"
 *     }, {
 *         "request": "https://postman-echo.com/headers"
 *     }],
 *     "auth": {
 *         "type": "basic",
 *         "basic": {
 *             "username": "jean",
 *             "password": "{{somethingsecret}}"
 *         }
 *     },
 *     "event": [{
 *         "listen": "prerequest",
 *         "script": {
 *             "type": "text/javascript",
 *             "exec": "console.log(new Date())"
 *         }
 *     }]
 * }
 */
_.inherit((

    /**
     * An ItemGroup represents a composite list of {@link Item} or ItemGroup. In terms of Postman App, ItemGroup
     * represents a "Folder". This allows one to group Items into subsets that can have their own meaning. An
     * ItemGroup also allows one to define a subset of common properties to be applied to each Item within it. For
     * example, a `test` event defined on an ItemGroup is executed while testing any Item that belongs to that group.
     * Similarly, ItemGroups can have a common {@RequestAuth} defined so that every {@link Request}, when processed,
     * requires to be authenticated using the `auth` defined in the group.
     *
     * Essentially, {@link Collection} too is a special type of ItemGroup ;-).
     *
     * @constructor
     * @extends {Property}
     *
     * @param {ItemGroup~definition=} [definition] While creating a new instance of ItemGroup, one can provide the
     * initial configuration of the item group with the requests it contains, the authentication applied to all
     * requests, events that the requests responds to, etc.
     *
     * @example <caption>Add a new ItemGroup to a collection instance</caption>
     * var Collection = require('postman-collection').Collection,
     *     ItemGroup = require('postman-collection').ItemGroup,
     *     myCollection;
     *
     * myCollection = new Collection(); // create an empty collection
     * myCollection.items.add(new ItemGroup({ // add a folder called "blank folder"
     *     "name": "This is a blank folder"
     * }));
     */
    ItemGroup = function PostmanItemGroup (definition) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        ItemGroup.super_.apply(this, arguments);

        _.mergeDefined(this, /** @lends ItemGroup.prototype */ {
            /**
             * This is a {@link PropertyList} that holds the list of {@link Item}s or {@link ItemGroup}s belonging to a
             * {@link Collection} or to an {@link ItemGroup}. Operation on an individual item in this list can be
             * performed using various functions available to a {@link PropertyList}.
             *
             * @type {PropertyList<(Item|ItemGroup)>}
             *
             * @example <caption>Fetch empty ItemGroups in a list loaded from a file</caption>
             * var fs = require('fs'), // needed to read JSON file from disk
             *     Collection = require('postman-collection').Collection,
             *     myCollection,
             *     emptyGroups;

             * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)
             * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));
             *
             * // Filter items in Collection root that is an empty ItemGroup
             * emptyGroups = myCollection.items.filter(function (item) {
             *     return item && item.items && (item.items.count() === 0);
             * });
             *
             * // Log the emptyGroups array to check it's contents
             * console.log(emptyGroups);
             */
            items: new PropertyList(ItemGroup._createNewGroupOrItem, this, definition && definition.item),

            /**
             * One can define the default authentication method required for every item that belongs to this list.
             * Individual {@link Request}s can override this in their own definitions. More on how to define an
             * authentication method is outlined in the {@link RequestAuth} property.
             *
             * @type {RequestAuth}
             *
             * @example <caption>Define an entire ItemGroup (folder) or Collection to follow Basic Auth</caption>
             * var fs = require('fs'),
             *     Collection = require('postman-collection').Collection,
             *     RequestAuth = require('postman-collection').RequestAuth,
             *     mycollection;
             *
             * // Create a collection having two requests
             * myCollection = new Collection();
             * myCollection.items.add([
             *     { name: 'GET Request', request: 'https://postman-echo.com/get?auth=basic' },
             *     { name: 'PUT Request', request: 'https://postman-echo.com/put?auth=basic' }
             * ]);
             *
             * // Add basic auth to the Collection, to be applied on all requests.
             * myCollection.auth = new RequestAuth({
             *     type: 'basic',
             *     username: 'postman',
             *     password: 'password'
             * });
             */
            // auth is a special case, empty RequestAuth should not be created for falsy values
            // to allow inheritance from parent
            auth: definition && definition.auth ? new RequestAuth(definition.auth) : undefined,

            /**
             * In this list, one can define the {@link Script}s to be executed when an event is triggered. Events are
             * triggered before certain actions are taken on a Collection, Request, etc. For example, executing a
             * request causes the `prerequest` and the `test` events to be triggered.
             *
             * @type {EventList}
             * @memberOf Collection.prototype
             *
             * @example <caption>Executing a common test script for all requests in a collection</caption>
             * var fs = require('fs'), // needed to read JSON file from disk
             *     Collection = require('postman-collection').Collection,
             *     myCollection;
             *
             * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)
             * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));
             *
             * // Add an event listener to the collection that listens to the `test` event.
             * myCollection.events.add({
             *     listen: 'test',
             *     script: {
             *         exec: 'tests["Status code is 200"] = (responseCode.code === 200)'
             *     }
             * });
             */
            events: new EventList(this, definition && definition.event),

            /**
             * Set of configurations used to alter the usual behavior of sending the request.
             *
             * @type {Object}
             * @property {Boolean} disableBodyPruning Disable body pruning for request methods like GET, HEAD etc.
             */
            protocolProfileBehavior: definition && typeof definition.protocolProfileBehavior === OBJECT ?
                definition.protocolProfileBehavior : undefined
        });
    }), Property);

_.assign(ItemGroup.prototype, /** @lends ItemGroup.prototype */ {
    /**
     * Defines that this property requires an ID field
     * @private
     * @readonly
     */
    _postman_propertyRequiresId: true,

    /**
     * Calls the callback for each item belonging to itself. If any ItemGroups are encountered,
     * they will call the callback on their own Items.
     *
     * @private
     * @param {Function} callback
     */
    forEachItem: function forEachItem (callback) {
        this.items.each(function (item) {
            return ItemGroup.isItemGroup(item) ? item.forEachItem(callback) : callback(item, this);
        }, this);
    },

    /**
     * Calls the callback for each itemgroup belonging to itself. All ItemGroups encountered will also,
     * call the callback on their own ItemGroups
     *
     * @private
     * @param {Function} callback
     */
    forEachItemGroup: function forEachItemGroup (callback) {
        this.items.each(function (item) {
            if (ItemGroup.isItemGroup(item)) {
                item.forEachItemGroup(callback);
                callback(item, this); // eslint-disable-line callback-return
            }
        }, this);
    },

    /**
     * Finds the first item with the given name or id in the current ItemGroup.
     *
     * @param {String} idOrName
     */
    oneDeep: function (idOrName) {
        if (!_.isString(idOrName)) { return; }

        var item;

        this.items.each(function (eachItem) {
            if (eachItem.id === idOrName || eachItem.name === idOrName) {
                item = eachItem;
                return false; // we found something, so bail out of the for loop.
            }

            if (ItemGroup.isItemGroup(eachItem)) {
                item = eachItem.oneDeep(idOrName);
                return !item; // bail out of the for loop if we found anything
            }
        });

        return item;
    },

    /**
     * Fetches protocol profile behavior for the current ItemGroup
     *
     * @private
     * @returns {Object}
     *
     * @note This will not inherit protocol profile behaviors from parent,
     * use `getProtocolProfileBehaviorResolved` to achieve that behavior.
     */
    getProtocolProfileBehavior: Item.prototype.getProtocolProfileBehavior,

    /**
     * Fetches protocol profile behavior applicable for the current ItemGroup,
     * inherited from parent ItemGroups(s).
     *
     * @private
     * @returns {Object}
     */
    getProtocolProfileBehaviorResolved: Item.prototype.getProtocolProfileBehaviorResolved,

    /**
     * Set or update protocol profile behavior for the current ItemGroup.
     *
     * @example <caption> Set or update protocol profile behavior </caption>
     * itemGroup.setProtocolProfileBehavior('strictSSL', false);
     *
     * @private
     * @param {String} key - protocol profile behavior name
     * @param {*} value - protocol profile behavior value
     * @returns {ItemGroup}
     */
    setProtocolProfileBehavior: Item.prototype.setProtocolProfileBehavior,

    /**
     * Unset or delete protocol profile behavior for the current ItemGroup.
     *
     * @example <caption> Unset protocol profile behavior </caption>
     * itemGroup.unsetProtocolProfileBehavior('strictSSL');
     *
     * @private
     * @param {String} key - protocol profile behavior name to unset
     * @returns {ItemGroup}
     */
    unsetProtocolProfileBehavior: Item.prototype.unsetProtocolProfileBehavior,

    /**
     * Sets authentication method for all the items within this group
     *
     * @param {?String|RequestAuth~definition} type
     * @param {VariableList~definition=} [options]
     *
     * @note This function was previously (in v2 of SDK) used to clone request and populate headers. Now it is used to
     * only set auth information to request
     */
    authorizeRequestsUsing: Request.prototype.authorizeUsing
});

_.assign(ItemGroup, /** @lends ItemGroup */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'ItemGroup',

    /**
     * Iterator function to update an itemgroup's item array with appropriate objects from definition.
     *
     * @private
     * @this {ItemGroup}
     * @param {Object} item - the definition of an item or group
     * @returns {ItemGroup|Item}
     * @note
     * This function is intended to be used in scope of an instance of a {@link ItemGroup).
     */
    _createNewGroupOrItem: function (item) {
        if (Item.isItem(item) || ItemGroup.isItemGroup(item)) { return item; }

        return item && item.item ? new ItemGroup(item) : new Item(item);
    },

    /**
     * Check whether an object is an instance of {@link ItemGroup}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isItemGroup: function (obj) {
        return Boolean(obj) && ((obj instanceof ItemGroup) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', ItemGroup._postman_propertyName));
    }
});

module.exports = {
    ItemGroup: ItemGroup
};


/***/ }),

/***/ 4363:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    Script = __webpack_require__(4364).Script,

    Event;

/**
 * @typedef Event~definition
 * @property {String} listen The event-name that this script will be called for. Usually either "test" or "prerequest"
 * @property {Script|String} script A {@link Script} instance that will be executed on this event. In case of a
 * string, a new {@link Script} is created.
 * @example <caption>Constructing an event</caption>
 * var Event = require('postman-collection').Event,
 *     rawEvent = {
 *         listen: 'test',
 *         script: 'tests["response code is 401"] = responseCode.code === 401'
 *     },
 *     myEvent;
 * myEvent = new Event(rawEvent);
 */
_.inherit((

    /**
     * A Postman event definition that refers to an event to be listened to and a script reference or definition to be
     * executed.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {Event~definition} definition Pass the initial definition of the event as the options parameter.
     */
    Event = function PostmanEvent (definition) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Event.super_.call(this, definition);
        // set initial values of this event
        definition && this.update(definition);
    }), Property);

_.assign(Event.prototype, /** @lends Event.prototype */ {
    /**
     * Update an event.
     *
     * @param {Event~definition} definition
     */
    update: function (definition) {
        if (!definition) {
            return;
        }

        var result,
            script = definition.script;

        if (Script.isScript(script)) {
            result = script;
        }
        else if (_.isArray(script) || _.isString(script)) {
            result = new Script({ exec: script });
        }
        else if (_.isObject(script)) {
            result = new Script(script);
        }

        _.mergeDefined(this, /** @lends Event.prototype */ {
            /**
             * Name of the event that this instance is intended to listen to.
             * @type {String}
             */
            listen: _.isString(definition.listen) ? definition.listen.toLowerCase() : undefined,

            /**
             * The script that is to be executed when this event is triggered.
             * @type {Script}
             */
            script: result
        });
    }
});

_.assign(Event, /** @lends Event */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Event'
});

module.exports = {
    Event: Event
};


/***/ }),

/***/ 4364:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    Url = __webpack_require__(3837).Url,

    Script,

    SCRIPT_NEWLINE_PATTERN = /\r?\n/g;

_.inherit((

    /**
     * Postman scripts that are executed upon events on a collection  / request such as test and pre request.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {Object} options
     */
    Script = function PostmanScript (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Script.super_.apply(this, arguments);

        options && this.update(options);
    }), Property);

_.assign(Script.prototype, /** @lends Script.prototype */ {
    /**
     * Defines whether this property instances requires an id
     * @private
     * @readOnly
     * @type {Boolean}
     */
    _postman_propertyRequiresId: true,

    /**
     * Converts the script lines array to a single source string.
     *
     * @returns {String}
     */
    toSource: function () {
        return this.exec ? this.exec.join('\n') : undefined;
    },

    /**
     * Updates the properties of a Script.
     *
     * @param {Object} [options]
     * @param {String} [options.type] Script type
     * @param {String} [options.src] Script source url
     * @param {String[]|String} [options.exec] Script to execute
     */
    update: function (options) {
        // no splitting is being done here, as string scripts are split right before assignment below anyway
        (_.isString(options) || _.isArray(options)) && (options = { exec: options });

        if (!options) { return; } // in case definition object is missing, there is no point moving forward

        // create the request property
        /**
         * @augments {Script.prototype}
         * @type {string}
         */
        this.type = options.type || 'text/javascript';
        options.hasOwnProperty('src') && (

            /**
             * @augments {Script.prototype}
             * @type {Url}
             */
            this.src = new Url(options.src)
        );

        if (!this.src && options.hasOwnProperty('exec')) { // eslint-disable-line no-prototype-builtins
            /**
             * @augments {Script.prototype}
             * @type {Array<string>}
             */
            this.exec = _.isString(options.exec) ? options.exec.split(SCRIPT_NEWLINE_PATTERN) :
                _.isArray(options.exec) ? options.exec : undefined;
        }
    }
});

_.assign(Script, /** @lends Script */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Script',

    /**
     * Check whether an object is an instance of {@link ItemGroup}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isScript: function (obj) {
        return Boolean(obj) && ((obj instanceof Script) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Script._postman_propertyName));
    }
});

module.exports = {
    Script: Script
};


/***/ }),

/***/ 4365:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    PropertyList = __webpack_require__(3798).PropertyList,
    EventList = __webpack_require__(4090).EventList,
    Request = __webpack_require__(3978).Request,
    RequestAuth = __webpack_require__(3979).RequestAuth,
    Response = __webpack_require__(4368).Response,

    Item,

    /**
     * @private
     * @type {String}
     */
    OBJECT = 'object',

    /**
     * @private
     * @type {String}
     */
    STRING = 'string',

    /**
     * Extracts `auth` from an entity. Checks if `auth` is present and it is not falsy type.
     *
     * @private
     *
     * @param {Object} [entity]
     */
    extractAuth = function (entity) {
        var auth;

        return (entity && (auth = entity.auth) && RequestAuth.isValidType(auth.type)) ? auth : undefined;
    },

    /**
     * Extracts `protocolProfileBehavior` from an entity.
     *
     * @private
     *
     * @param {Item|ItemGroup} entity
     * @returns {Object}
     */
    extractProtocolProfileBehavior = function (entity) {
        var protocolProfileBehavior = entity && entity.protocolProfileBehavior;

        return typeof protocolProfileBehavior === OBJECT ? protocolProfileBehavior : {};
    };

/**
 * The following defines the object (or JSON) structure that one can pass to the Item while creating a new Item
 * instance. This is also the object structure returned when `.toJSON()` is called on an Item instance.
 * @typedef Item~definition
 *
 * @property {Request~definition=} [request] A request represents an HTTP request. If a string, the string is assumed to
 * be the request URL and the method is assumed to be 'GET'.
 * @property {Array<Response~definition>=} [responses] Sample responses for this request can be stored along with the
 * item definition.
 * @property {Array<Event~definition>=} [events] Postman allows you to configure scripts to run when specific events
 * occur. These scripts are stored here, and can be referenced in the collection by their id.
 *
 * @example
 * {
 *     "name": "Get Headers from Echo",
 *     "id": "my-request-1",
 *     "description": "Makes a GET call to echo service and returns the client headers that were sent",
 *
 *     "request": {
 *         "url": "https://postman-echo.com/headers",
 *         "method": "GET"
 *     }
 * }
 *
 * @todo add response and event to example
 */
_.inherit((

    /**
     * A Postman Collection Item that holds your request definition, responses and other stuff. An Item essentially is
     * a HTTP request definition along with the sample responses and test scripts clubbed together. One or more of these
     * items can be grouped together and placed in an {@link ItemGroup} and as such forms a {@link Collection} of
     * requests.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {Item~definition=} [definition] While creating a new instance of Item, one can provide the initial
     * configuration of the item with the the request it sends, the expected sample responses, tests, etc
     *
     * @example <caption>Add a new Item to a folder in a collection instance</caption>
     * var Collection = require('postman-collection').Collection,
     *     Item = require('postman-collection').Item,
     *     myCollection;
     *
     * myCollection = new Collection({
     *     "item": [{
     *         "id": "my-folder-1",
     *         "name": "The solo folder in this collection",
     *         "item": [] // blank array indicates this is a folder
     *     }]
     * }); // create a collection with an empty folder
     * // add a request to "my-folder-1" that sends a GET request
     * myCollection.items.one("my-folder-1").items.add(new Item({
     *     "name": "Send a GET request",
     *     "id": "my-get-request",
     *     "request": {
     *         "url": "https://postman-echo.com/get",
     *         "method": "GET"
     *     }
     * }));
     */
    Item = function PostmanItem (definition) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Item.super_.apply(this, arguments);

        _.mergeDefined(this, /** @lends Item.prototype */ {
            /**
             * The instance of the {@link Request} object inside an Item defines the HTTP request that is supposed to be
             * sent. It further contains the request method, url, request body, etc.
             * @type {Request}
             */
            request: definition && (new Request(definition.request)),

            /**
             * An Item also contains a list of sample responses that is expected when the request defined in the item is
             * executed. The sample responses are useful in elaborating API usage and is also useful for other
             * integrations that use the sample responses to do something - say a mock service.
             * @type {PropertyList<Response>}
             */
            responses: new PropertyList(Response, this, definition && definition.response),

            /**
             * Events are a set of of {@link Script}s that are executed when certain activities are triggered on an
             * Item. For example, on defining an event that listens to the "test" event, would cause the associated
             * script of the event to be executed when the test runs.
             * @type {EventList}
             *
             * @example <caption>Add a script to be executed on "prerequest" event</caption>
             * var Collection = require('postman-collection').Collection,
             *     Item = require('postman-collection').Item,
             *     myCollection;
             *
             * myCollection = new Collection({
             *     "item": [{
             *         "name": "Send a GET request",
             *         "id": "my-get-request",
             *         "request": {
             *             "url": "https://postman-echo.com/get",
             *             "method": "GET"
             *         }
             *     }]
             * }); // create a collection with one request
             *
             * // add a pre-request script to the event list
             * myCollection.items.one('my-get-request').events.add({
             *     "listen": "prerequest",
             *     "script": {
             *         "type": "text/javascript",
             *         "exec": "console.log(new Date())"
             *     }
             * });
             */
            events: new EventList(this, definition && definition.event),

            /**
             * Set of configurations used to alter the usual behavior of sending the request.
             *
             * @type {Object}
             */
            protocolProfileBehavior: definition && typeof definition.protocolProfileBehavior === OBJECT ?
                definition.protocolProfileBehavior : undefined
        });
    }), Property);

_.assign(Item.prototype, /** @lends Item.prototype */ {
    /**
     * Defines whether this property instances requires an id
     * @private
     * @readOnly
     * @type {Boolean}
     */
    _postman_propertyRequiresId: true,

    /**
     * Fetches applicable AuthType from the current item.
     *
     * @returns {RequestAuth}
     *
     * @note Since v3.0 release, this returns the entire auth RequestAuth, instead of just the parameters
     *
     * @todo Deprecate this and use getAuthResolved instead
     */
    getAuth: function () {
        var requestAuth;

        // find auth on request, if not found or empty auth, lookup in the parents
        // eslint-disable-next-line no-cond-assign
        return (requestAuth = extractAuth(this.request)) ? requestAuth : this.findInParents('auth', extractAuth);
    },

    /**
     * Fetches protocol profile behavior for the current Item
     *
     * @private
     * @returns {Object}
     *
     * @note This will not inherit protocol profile behaviors from parent,
     * use `getProtocolProfileBehaviorResolved` to achieve that behavior.
     */
    getProtocolProfileBehavior: function () {
        return extractProtocolProfileBehavior(this);
    },

    /**
     * Fetches protocol profile behavior applicable for the current Item,
     * inherited from parent ItemGroup(s).
     *
     * @private
     * @returns {Object}
     */
    getProtocolProfileBehaviorResolved: function () {
        var protocolProfileBehavior = extractProtocolProfileBehavior(this);

        // inherit protocolProfileBehavior from ItemGroup(s)
        this.forEachParent({ withRoot: true }, function (entity) {
            protocolProfileBehavior = Object.assign(extractProtocolProfileBehavior(entity), protocolProfileBehavior);
        });

        return protocolProfileBehavior;
    },

    /**
     * Set or update protocol profile behavior for the current Item.
     *
     * @example <caption> Set or update protocol profile behavior </caption>
     * item.setProtocolProfileBehavior('strictSSL', false);
     *
     * @private
     * @param {String} key - protocol profile behavior name
     * @param {*} value - protocol profile behavior value
     * @returns {Item}
     */
    setProtocolProfileBehavior: function (key, value) {
        // bail out if key is non-string
        if (typeof key !== STRING) { return this; }

        !this.protocolProfileBehavior && (this.protocolProfileBehavior = {});

        this.protocolProfileBehavior[key] = value;

        return this;
    },

    /**
     * Unset or delete protocol profile behavior for the current Item.
     *
     * @example <caption> Unset protocol profile behavior </caption>
     * item.unsetProtocolProfileBehavior('strictSSL');
     *
     * @private
     * @param {String} key - protocol profile behavior name to unset
     * @returns {Item}
     */
    unsetProtocolProfileBehavior: function (key) {
        // bail out if property protocolProfileBehavior is not set or key is non-string
        if (!(typeof this.protocolProfileBehavior === OBJECT && typeof key === STRING)) {
            return this;
        }

        if (this.protocolProfileBehavior.hasOwnProperty(key)) {
            delete this.protocolProfileBehavior[key];
        }

        return this;
    },

    /**
     * Returns {@link Event}s corresponding to a particular event name. If no name is given, returns all events. This
     * is useful when you want to trigger all associated scripts for an event.
     *
     * @param {String} name - one of the available event types such as `test`, `prerequest`, `postrequest`, etc.
     * @returns {Array<Event>}
     *
     * @example <caption>Get all events for an item and evaluate their scripts</caption>
     * var fs = require('fs'), // needed to read JSON file from disk
     *     Collection = require('postman-collection').Collection,
     *     myCollection;
     *
     * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)
     * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));
     *
     * // assuming the collection has a request called "my-request-1" in root, we get it's test events
     * myCollection.items.one("my-request-1").getEvents("test").forEach(function (event) {
     *     event.script && eval(event.script.toSource());
     * });
     *
     * @todo decide appropriate verb names based on the fact that it gets events for a specific listener name
     * @draft
     */
    getEvents: function (name) {
        if (!name) {
            return this.events.all(); // return all events if name is not provided.
        }
        return this.events.filter(function (ev) {
            return ev.listen === name;
        });
    },

    /**
     * Sets authentication method for the request within this item
     *
     * @param {?String|RequestAuth~definition} type
     * @param {VariableList~definition=} [options]
     *
     * @note This function was previously (in v2 of SDK) used to clone request and populate headers. Now it is used to
     * only set auth information to request
     */
    authorizeRequestUsing: function (type, options) {
        if (!this.request) { this.request = new Request(); } // worst case
        return this.request.authorizeUsing(type, options);
    }
});

_.assign(Item, /** @lends Item */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Item',

    /**
     * Check whether an object is an instance of PostmanItem.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isItem: function (obj) {
        return Boolean(obj) && ((obj instanceof Item) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Item._postman_propertyName));
    }
});

module.exports = {
    Item: Item
};


/***/ }),

/***/ 4366:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyBase = __webpack_require__(3813).PropertyBase,
    PropertyList = __webpack_require__(3798).PropertyList,
    QueryParam = __webpack_require__(4088).QueryParam,
    FormParam = __webpack_require__(4367).FormParam,

    EMPTY = '',

    RequestBody;

_.inherit((

    /**
     * RequestBody holds data related to the request body. By default, it provides a nice wrapper for url-encoded,
     * form-data, and raw types of request bodies.
     *
     * @constructor
     * @extends {PropertyBase}
     *
     * @param {Object} options
     */
    RequestBody = function PostmanRequestBody (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        RequestBody.super_.apply(this, arguments);
        if (!options) { return; } // in case definition object is missing, there is no point moving forward

        this.update(options);
    }), PropertyBase);

_.assign(RequestBody.prototype, /** @lends RequestBody.prototype */ {
    /**
     * Set the content of this request data
     *
     * @param {Object} options
     */
    update: function (options) {
        _.isString(options) && (options = { mode: 'raw', raw: options });
        if (!options.mode) { return; } // need a valid mode @todo raise error?

        var mode = RequestBody.MODES[options.mode.toString().toLowerCase()] || RequestBody.MODES.raw,
            urlencoded = options.urlencoded,
            formdata = options.formdata,
            graphql = options.graphql,
            file = options.file,
            raw = options.raw;

        // Handle URL Encoded data
        if (options.urlencoded) {
            _.isString(options.urlencoded) && (urlencoded = QueryParam.parse(options.urlencoded));
            // @todo: The fallback in the ternary expression will never be hit, as urlencoded points to
            // @todo: options.urlencoded
            urlencoded = urlencoded ? new PropertyList(QueryParam, this, urlencoded) :
                new PropertyList(QueryParam, this, []);
        }

        // Handle Form data
        if (options.formdata) {
            // @todo: The fallback in the ternary expression will never be hit, as formdata points to
            // @todo: options.formdata
            formdata = formdata ? new PropertyList(FormParam, this, options.formdata) :
                new PropertyList(FormParam, this, []);
        }

        // Handle GraphQL data
        if (options.graphql) {
            graphql = {
                query: graphql.query,
                operationName: graphql.operationName,
                variables: graphql.variables
            };
        }

        _.isString(options.file) && (file = { src: file });

        // If mode is raw but options does not give raw content, set it to empty string
        (mode === RequestBody.MODES.raw && !raw) && (raw = '');

        // If mode is urlencoded but options does not provide any content, set it to an empty property list
        (mode === RequestBody.MODES.urlencoded && !urlencoded) && (urlencoded = new PropertyList(QueryParam, this, []));

        // If mode is formdata but options does not provide any content, set it to an empty property list
        (mode === RequestBody.MODES.formdata && !formdata) && (formdata = new PropertyList(FormParam, this, []));

        // If mode is graphql but options does not provide any content, set empty query
        (mode === RequestBody.MODES.graphql && !graphql) && (graphql = {});

        _.assign(this, /** @lends RequestBody.prototype */ {

            /**
             * Indicates the type of request data to use.
             *
             * @type {String}
             */
            mode: mode,

            /**
             * If the request has raw body data associated with it, the data is held in this field.
             *
             * @type {String}
             */
            raw: raw,

            /**
             * Any URL encoded body params go here.
             *
             * @type {PropertyList<QueryParam>}
             */
            urlencoded: urlencoded,

            /**
             * Form data parameters for this request are held in this field.
             *
             * @type {PropertyList<FormParam>}
             */
            formdata: formdata,

            /**
             * Holds a reference to a file which should be read as the RequestBody. It can be a file path (when used
             * with Node) or a unique ID (when used with the browser).
             *
             * @note The reference stored here should be resolved by a resolver function (which should be provided to
             * the Postman Runtime).
             */
            file: file,

            /**
             * If the request has raw graphql data associated with it, the data is held in this field.
             *
             * @type {Object}
             */
            graphql: graphql,

            /**
             * Indicates whether to include body in request or not.
             *
             * @type {Boolean}
             */
            disabled: options.disabled
        });
    },

    /**
     * Stringifies and returns the request body.
     *
     * @note FormData is not supported yet.
     * @returns {*}
     */
    toString: function () {
        // Formdata. Goodluck.
        if (this.mode === RequestBody.MODES.formdata || this.mode === RequestBody.MODES.file) {
            // @todo: implement this, check if we need to return undefined or something.
            return EMPTY;
        }

        if (this.mode === RequestBody.MODES.urlencoded) {
            return PropertyList.isPropertyList(this.urlencoded) ? QueryParam.unparse(this.urlencoded.all()) :
                ((this.urlencoded && _.isFunction(this.urlencoded.toString)) ? this.urlencoded.toString() : EMPTY);
        }

        if (this.mode === RequestBody.MODES.raw) {
            return (this.raw && _.isFunction(this.raw.toString)) ? this.raw.toString() : EMPTY;
        }

        return EMPTY;
    },

    /**
     * If the request body is set to a mode, but does not contain data, then we should not be sending it.
     *
     * @returns {Boolean}
     */
    isEmpty: function () {
        var mode = this.mode,
            data = mode && this[mode];

        // bail out if there's no data for the selected mode
        if (!data) {
            return true;
        }

        // Handle file mode
        // @note this is a legacy exception. ideally every individual data mode
        // in future would declare its "empty state".
        if (mode === RequestBody.MODES.file) {
            return !(data.src || data.content);
        }

        if (_.isString(data)) {
            return (data.length === 0);
        }

        if (_.isFunction(data.count)) { // handle for property lists
            return (data.count() === 0);
        }

        return _.isEmpty(data); // catch all for remaining data modes
    }
});

_.assign(RequestBody, /** @lends RequestBody **/{
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'RequestBody',

    /**
     * @enum {string} MODES
     */
    MODES: {
        file: 'file',
        formdata: 'formdata',
        graphql: 'graphql',
        raw: 'raw',
        urlencoded: 'urlencoded'
    }
});

module.exports = {
    RequestBody: RequestBody
};


/***/ }),

/***/ 4367:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,

    FormParam;

/**
 * @typedef FormParam~definition
 * @property {String} key The name ("key") of the form data parameter.
 * @property {String} value The value of the parameter.
 */
_.inherit((

    /**
     * Represents a Form Data parameter, which can exist in request body.
     *
     * @constructor
     * @param {FormParam~definition} options Pass the initial definition of the form data parameter.
     */
    FormParam = function PostmanFormParam (options) {
        FormParam.super_.apply(this, arguments);

        // @todo avoid using _.get
        this.key = _.get(options, 'key') || '';
        this.value = _.get(options, 'value') || '';
        this.type = _.get(options, 'type');
        this.src = _.get(options, 'src');
        this.contentType = _.get(options, 'contentType');
    }), Property);

_.assign(FormParam.prototype, /** @lends FormParam.prototype */ {
    /**
     * Converts the FormParameter to a single param string.
     *
     * @returns {String}
     */
    toString: function () {
        return this.key + '=' + this.value;
    },

    /**
     * Returns the value of the form parameter (if any).
     *
     * @returns {*|string}
     */
    valueOf: function () {
        return this.value; // can be multiple types, so just return whatever we have instead of being too clever
    }
});

_.assign(FormParam, /** @lends FormParam */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'FormParam',

    /**
     * Declare the list index key, so that property lists of form parameters work correctly
     *
     * @type {String}
     */
    _postman_propertyIndexKey: 'key',

    /**
     * Form params can have multiple values, so set this to true.
     *
     * @type {Boolean}
     */
    _postman_propertyAllowsMultipleValues: true,

    /**
     * Parse a form data string into an array of objects, where each object contains a key and a value.
     * @todo implement this, not implemented yet.
     * @param formdata {String}
     * @returns {Array}
     */
    parse: _.noop
});

module.exports = {
    FormParam: FormParam
};


/***/ }),

/***/ 4368:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(3767),
    _ = util.lodash,
    fileType = __webpack_require__(600),
    mimeType = __webpack_require__(1069),
    mimeFormat = __webpack_require__(601),
    httpReasons = __webpack_require__(741),
    LJSON = __webpack_require__(1076),
    Property = __webpack_require__(3787).Property,
    PropertyBase = __webpack_require__(3813).PropertyBase,
    Request = __webpack_require__(3978).Request,
    Header = __webpack_require__(4093).Header,
    CookieList = __webpack_require__(4369).CookieList,
    HeaderList = __webpack_require__(4092).HeaderList,
    contentInfo = __webpack_require__(5310).contentInfo,

    /**
     * @private
     * @const
     * @type {string}
     */
    E = '',

    /**
     * @private
     * @const
     * @type {string}
     */
    DOT = '.',

    /**
     * @private
     * @const
     * @type {String}
     */
    HEADER = 'header',

    /**
     * @private
     * @const
     * @type {String}
     */
    BODY = 'body',

    /**
     * @private
     * @const
     * @type {String}
     */
    GZIP = 'gzip',

    /**
     * @private
     * @const
     * @type {String}
     */
    CONTENT_ENCODING = 'Content-Encoding',

    /**
     * @private
     * @const
     * @type {String}
     */
    CONTENT_LENGTH = 'Content-Length',

    /**
     * @private
     * @const
     * @type {string}
     */
    DEFAULT_RESPONSE_FILENAME = 'response',

    /**
     * @private
     * @const
     * @type {string}
     */
    UTF8 = 'utf8',

    /**
     * @private
     * @const
     * @type {string}
     */
    BUFFER = 'Buffer',

    /**
     * @private
     * @const
     * @type {string}
     */
    FUNCTION = 'function',

    /**
     * @private
     * @const
     * @type {String}
     */
    HTTP_X_X = 'HTTP/X.X',

    /**
     * @private
     * @const
     * @type {String}
     */
    SP = ' ',

    /**
     * @private
     * @const
     * @type {String}
     */
    CRLF = '\r\n',

    /**
     * @private
     * @const
     * @type {RegExp}
     */
    REGEX_JSONP_LEFT = /^[^{(].*\(/,

    /**
     * @private
     * @const
     * @type {RegExp}
     */
    REGEX_JSONP_RIGHT = /\)[^}].*$|\)$/,

    /**
     * Remove JSON padded string to pure JSON
     *
     * @param {String} str
     * @returns {String}
     */
    stripJSONP = function (str) {
        return str.replace(REGEX_JSONP_LEFT, E).replace(REGEX_JSONP_RIGHT, E);
    },

    /**
     * @private
     * @type {Boolean}
     */
    supportsBuffer = (typeof Buffer !== undefined) && _.isFunction(Buffer.byteLength),

    /**
     * Normalises an input Buffer or buffer.toJSON() into a Buffer or ArrayBuffer.
     *
     * @private
     * @param {Buffer|Object} stream - An instance of Buffer of an object representation of Buffer(Buffer.toJSON())
     * @returns {Buffer|ArrayBuffer|undefined}
     */
    normaliseStream = function (stream) {
        if (stream && stream.type === BUFFER && _.isArray(stream.data)) {
            // @todo Add tests for Browser environments, where ArrayBuffer is returned instead of Buffer
            return typeof Buffer === FUNCTION ? new Buffer(stream.data) : new Uint8Array(stream.data).buffer;
        }
        return stream;
    },

    Response; // constructor

/**
 * @typedef Response~definition
 * @property {Number} code - define the response code
 * @property {String=} [reason] - optionally, if the response has a non-standard response code reason, provide it here
 * @property {Array<Header~definition>} [header]
 * @property {Array<Cookie~definition>} [cookie]
 * @property {String} [body]
 * @property {Buffer|ByteArray} [stream]
 * @property {Number} responseTime
 *
 * @todo pluralise `header`, `cookie`
 */
_.inherit((

    /**
     * Response holds data related to the request body. By default, it provides a nice wrapper for url-encoded,
     * form-data, and raw types of request bodies.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {Response~definition} options
     */
    Response = function PostmanResponse (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Response.super_.apply(this, arguments);
        this.update(options || {});
    }), Property);

_.assign(Response.prototype, /** @lends Response.prototype */ {
    update: function (options) {
        // options.stream accepts new Buffer() as well as new Buffer().toJSON()
        var stream = normaliseStream(options.stream);

        _.mergeDefined((this._details = _.clone(httpReasons.lookup(options.code))), {
            name: _.choose(options.reason, options.status),
            code: options.code,
            standardName: this._details.name
        });

        _.mergeDefined(this, /** @lends Response.prototype */ {
            /**
             * @type {Request}
             */
            originalRequest: options.originalRequest ? new Request(options.originalRequest) : undefined,

            /**
             * @type {String}
             * @deprecated use .reason()
             */
            status: this._details.name,

            /**
             * @type {Number}
             */
            code: options.code,

            /**
             * @type {HeaderList}
             */
            headers: new HeaderList(this, options.header),

            /**
             * @type {String}
             */
            body: options.body,

            /**
             * @private
             *
             * @type {Buffer|UInt8Array}
             */
            stream: options.body && !_.isString(options.body) && _.isObject(options.body) ?
                options.body : stream,

            /**
             * @type {CookieList}
             */
            cookies: new CookieList(this, options.cookie),

            /**
             * Time taken for the request to complete.
             *
             * @type {Number}
             */
            responseTime: options.responseTime,

            /**
             * @private
             * @type {Number}
             */
            responseSize: stream && stream.byteLength
        });
    }
});

_.assign(Response.prototype, /** @lends Response.prototype */ {
    /**
     * Defines that this property requires an ID field
     * @private
     * @readOnly
     */
    _postman_propertyRequiresId: true,

    /**
     * Convert this response into a JSON serialisable object. The _details meta property is omitted.
     *
     * @returns {Object}
     */
    toJSON: function () {
        var response = PropertyBase.toJSON(this);

        response._details && (delete response._details);
        return response;
    },

    /**
     * Get the http response reason phrase based on the current response code.
     *
     * @returns {String|undefined}
     */
    reason: function () {
        return this.status || httpReasons.lookup(this.code).name;
    },

    /**
     * Creates a JSON representation of the current response details, and returns it.
     *
     * @returns {Object} A set of response details, including the custom server reason.
     * @private
     */
    details: function () {
        if (!this._details || this._details.code !== this.code) {
            this._details = _.clone(httpReasons.lookup(this.code));
            this._details.code = this.code;
            this._details.standardName = this._details.name;
        }
        return _.clone(this._details);
    },

    /**
     * Get the response body as a string/text.
     *
     * @returns {String|undefined}
     */
    text: function () {
        return (this.stream ? util.bufferOrArrayBufferToString(this.stream, this.mime().charset) : this.body);
    },

    /**
     * Get the response body as a JavaScript object. Note that it throws an error if the response is not a valid JSON
     *
     * @param {Function=} [reviver]
     * @param {Boolean} [strict=false] Specify whether JSON parsing will be strict. This will fail on comments and BOM
     * @example
     * // assuming that the response is stored in a collection instance `myCollection`
     * var response = myCollection.items.one('some request').responses.idx(0),
     *     jsonBody;
     * try {
     *     jsonBody = response.json();
     * }
     * catch (e) {
     *     console.log("There was an error parsing JSON ", e);
     * }
     * // log the root-level keys in the response JSON.
     * console.log('All keys in json response: ' + Object.keys(json));
     *
     * @returns {Object}
     */
    json: function (reviver, strict) {
        return LJSON.parse(this.text(), reviver, strict);
    },

    /**
     * Get the JSON from response body that reuturns JSONP response.
     *
     * @param {Function=} [reviver]
     * @param {Boolean} [strict=false] Specify whether JSON parsing will be strict. This will fail on comments and BOM
     *
     * @throws {JSONError} when response body is empty
     */
    jsonp: function (reviver, strict) {
        return LJSON.parse(stripJSONP(this.text() || E), reviver, strict);
    },

    /**
     * Extracts mime type, format, charset, extension and filename of the response content
     * A fallback of default filename is given, if filename is not present in content-disposition header
     *
     * @returns {Response~ResponseContentInfo} - contentInfo for the response
     */
    contentInfo: function () {
        return contentInfo(this);
    },

    /**
     * @private
     *
     * @param {String|Header} contentType - override the content-type of the response using this parameter before
     * computing the mime  type.
     * @param {String|Header} contentDisposition - override the content-disposition of the response before calculating
     * mime info.
     *
     * @returns {Object}
     *
     * @note example object returned
     * {
     *   source: string // 'header', 'content', 'default' or 'forced'
     *   type: normalised.type, // sanitised mime type base
     *   format: normalised.format, // format specific to the type returned
     *   name: DEFAULT_RESPONSE_FILENAME,
     *   ext: mimeType.extension(normalised.source) || E, // file extension from sanitised content type
     *   filename: name + ext,
     *   // also storing some meta info for possible debugging
     *   _originalContentType: type, // the user provided mime type
     *   _sanitisedContentType: normalised.source, // sanitised mime type
     *   _accuratelyDetected: !normalised.orphan // this being true implies worse case (raw render)
     *   detected: {} // same as root object, but based on what is detected from content
     * }
     * @deprecated To be removed in 4.0. Use {@link Response#contentInfo} contentInfo instead.
     */
    mime: function (contentType, contentDisposition) {
        var detected = fileType(this.stream || this.body), // detect the mime from response body
            source = 'forced',
            mime;

        // if no overrides provided, we take the values from headers
        !contentDisposition && (contentDisposition = this.headers.one('content-disposition'));
        if (!contentType) {
            contentType = this.headers.one('content-type') && this.headers.one('content-type').value;
            source = HEADER;
        }

        // if content type is not found in header, we fall back to the mime type detected
        if (!contentType && detected) {
            contentType = detected.mime;
            source = BODY;
        }

        // if still not found, then we use default text
        if (!contentType) {
            contentType = 'text/plain';
            source = 'default';
        }

        mime = Response.mimeInfo(contentType, contentDisposition);
        mime.source = source;
        mime.detected = detected && Response.mimeInfo(detected.mime, contentDisposition);

        return mime;
    },

    /**
     * Converts the response to a dataURI that can be used for storage or serialisation. The data URI is formed using
     * the following syntax `data:<content-type>;baseg4, <base64-encoded-body>`.
     *
     * @returns {String}
     * @todo write unit tests
     */
    dataURI: function () {
        var mime = this.mime();

        // if there is no mime detected, there is no accurate way to render this thing
        if (!this.mime) {
            return E;
        }

        // we create the body string first from stream and then fallback to body
        return 'data:' + mime._sanitisedContentType + ';base64, ' + ((!_.isNil(this.stream) &&
            util.bufferOrArrayBufferToBase64(this.stream)) || (!_.isNil(this.body) && util.btoa(this.body)) || E);
    },

    /**
     * Get the response size by computing the same from content length header or using the actual response body.
     *
     * @returns {Number}
     * @todo write unit tests
     */
    size: function () {
        var sizeInfo = {
                body: 0,
                header: 0,
                total: 0
            },

            contentEncoding = this.headers.get(CONTENT_ENCODING),
            contentLength = this.headers.get(CONTENT_LENGTH),
            isCompressed = false,
            byteLength;

        // if server sent encoded data, we should first try deriving length from headers
        if (_.isString(contentEncoding)) {
            // desensitise case of content encoding
            contentEncoding = contentEncoding.toLowerCase();
            // eslint-disable-next-line lodash/prefer-includes
            isCompressed = (contentEncoding.indexOf('gzip') > -1) || (contentEncoding.indexOf('deflate') > -1);
        }

        // if 'Content-Length' header is present and encoding is of type gzip/deflate, we take body as declared by
        // server. else we need to compute the same.
        if (contentLength && isCompressed && util.isNumeric(contentLength)) {
            sizeInfo.body = _.parseInt(contentLength, 10);
        }
        // if there is a stream defined which looks like buffer, use it's data and move on
        else if (this.stream) {
            byteLength = this.stream.byteLength;
            sizeInfo.body = util.isNumeric(byteLength) ? byteLength : 0;
        }
        // otherwise, if body is defined, we try get the true length of the body
        else if (!_.isNil(this.body)) {
            sizeInfo.body = supportsBuffer ? Buffer.byteLength(this.body.toString()) : this.body.toString().length;
        }

        // size of header is added
        // https://tools.ietf.org/html/rfc7230#section-3
        // HTTP-message   = start-line (request-line / status-line)
        //                  *( header-field CRLF )
        //                  CRLF
        //                  [ message-body ]
        // status-line = HTTP-version SP status-code SP reason-phrase CRLF
        sizeInfo.header = (HTTP_X_X + SP + this.code + SP + this.reason() + CRLF + CRLF).length +
            this.headers.contentSize();

        // compute the approximate total body size by adding size of header and body
        sizeInfo.total = (sizeInfo.body || 0) + (sizeInfo.header || 0);
        return sizeInfo;
    },

    /**
     * Returns the response encoding defined as header or detected from body.
     *
     * @private
     * @returns {Object} - {format: string, source: string}
     */
    encoding: function () {
        var contentEncoding = this.headers.get(CONTENT_ENCODING),
            body = this.stream || this.body,
            source;

        if (contentEncoding) {
            source = HEADER;
        }

        // if the encoding is not found, we check
        else if (body) { // @todo add detection for deflate
            // eslint-disable-next-line lodash/prefer-matches
            if (body[0] === 0x1F && body[1] === 0x8B && body[2] === 0x8) {
                contentEncoding = GZIP;
            }

            if (contentEncoding) {
                source = BODY;
            }
        }

        return {
            format: contentEncoding,
            source: source
        };
    }
});

_.assign(Response, /** @lends Response */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Response',

    /**
     * Check whether an object is an instance of {@link ItemGroup}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isResponse: function (obj) {
        return Boolean(obj) && ((obj instanceof Response) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Response._postman_propertyName));
    },

    /**
     * Converts the response object from the request module to the postman responseBody format
     *
     * @param {Object} response The response object, as received from the request module
     * @param {Object} cookies
     * @returns {Object} The transformed responseBody
     * @todo Add a key: `originalRequest` to the returned object as well, referring to response.request
     */
    createFromNode: function (response, cookies) {
        return new Response({
            cookie: cookies,
            body: response.body.toString(),
            stream: response.body,
            header: response.headers,
            code: response.statusCode,
            status: response.statusMessage,
            responseTime: response.elapsedTime
        });
    },

    /**
     * @private
     *
     * @param {String|Header} type
     * @param {String|Header} disposition
     * @returns {Object}
     *
     * @deprecated To be removed in 4.0. Use {@link Response#contentInfo} contentInfo instead.
     */
    mimeInfo: function (type, disposition) {
        Header.isHeader(type) && (type = type.value);
        Header.isHeader(disposition) && (disposition = disposition.value);

        // validate that the content type exists
        if (!(type && _.isString(type))) { return; }

        var normalised = mimeFormat.lookup(type),
            info = {};

        _.assign(info, {
            type: normalised.type, // sanitised mime type base
            format: normalised.format, // format specific to the type returned
            name: DEFAULT_RESPONSE_FILENAME,
            ext: mimeType.extension(normalised.source) || E, // file extension from sanitised content type
            charset: normalised.charset || UTF8,

            // also storing some meta info for possible debugging
            _originalContentType: type, // the user provided mime type
            _sanitisedContentType: normalised.source, // sanitised mime type
            _accuratelyDetected: !normalised.orphan // this being true implies worse case (raw render)
        });

        // build the file name from extension
        info.filename = info.name;
        info.ext && (info.filename += (DOT + info.ext));

        return info;
    },

    /**
     * Returns the durations of each request phase in milliseconds
     *
     * @typedef Response~timings
     * @property {Number} start - timestamp of the request sent from the client (in Unix Epoch milliseconds)
     * @property {Object} offset - event timestamps in millisecond resolution relative to start
     * @property {Number} offset.request - timestamp of the start of the request
     * @property {Number} offset.socket - timestamp when the socket is assigned to the request
     * @property {Number} offset.lookup - timestamp when the DNS has been resolved
     * @property {Number} offset.connect - timestamp when the server acknowledges the TCP connection
     * @property {Number} offset.secureConnect - timestamp when secure handshaking process is completed
     * @property {Number} offset.response -  timestamp when the first bytes are received from the server
     * @property {Number} offset.end - timestamp when the last bytes of the response are received
     * @property {Number} offset.done - timestamp when the response is received at the client
     *
     * @note If there were redirects, the properties reflect the timings
     *       of the final request in the redirect chain
     *
     * @param {Response~timings} timings
     * @returns {Object}
     *
     * @example Output
     * Request.timingPhases(timings);
     * {
     *     prepare: Number,         // duration of request preparation
     *     wait: Number,            // duration of socket initialization
     *     dns: Number,             // duration of DNS lookup
     *     tcp: Number,             // duration of TCP connection
     *     secureHandshake: Number, // duration of secure handshake
     *     firstByte: Number,       // duration of HTTP server response
     *     download: Number,        // duration of HTTP download
     *     process: Number,         // duration of response processing
     *     total: Number            // duration entire HTTP round-trip
     * }
     *
     * @note if there were redirects, the properties reflect the timings of the
     *       final request in the redirect chain.
     */
    timingPhases: function (timings) {
        // bail out if timing information is not provided
        if (!(timings && timings.offset)) {
            return;
        }

        var phases,
            offset = timings.offset;

        // REFER: https://github.com/postmanlabs/postman-request/blob/v2.88.1-postman.5/request.js#L996
        phases = {
            prepare: offset.request,
            wait: offset.socket - offset.request,
            dns: offset.lookup - offset.socket,
            tcp: offset.connect - offset.lookup,
            firstByte: offset.response - offset.connect,
            download: offset.end - offset.response,
            process: offset.done - offset.end,
            total: offset.done
        };

        if (offset.secureConnect) {
            phases.secureHandshake = offset.secureConnect - offset.connect;
            phases.firstByte = offset.response - offset.secureConnect;
        }

        return phases;
    }
});

module.exports = {
    Response: Response
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))

/***/ }),

/***/ 4369:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    Cookie = __webpack_require__(4370).Cookie,

    CookieList;

_.inherit((

    /**
     * Contains a list of header elements
     *
     * @constructor
     * @param {Object} parent
     * @param {Object[]} cookies
     * @extends {PropertyList}
     */
    CookieList = function (parent, cookies) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        CookieList.super_.call(this, Cookie, parent, cookies);
    }), PropertyList);

// _.assign(CookieList.prototype, /** @lends CookieList.prototype */ {
// });

_.assign(CookieList, /** @lends CookieList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'CookieList',

    /**
     * Checks if the given object is a CookieList
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isCookieList: function (obj) {
        return Boolean(obj) && ((obj instanceof CookieList) ||
          _.inSuperChain(obj.constructor, '_postman_propertyName', CookieList._postman_propertyName));
    }
});

module.exports = {
    CookieList: CookieList
};


/***/ }),

/***/ 4370:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyBase = __webpack_require__(3813).PropertyBase,

    E = '',
    EQ = '=',
    PAIR_SPLIT_REGEX = /; */,
    COOKIES_SEPARATOR = '; ',

    /**
     * Enum for all the Cookie attributes.
     * @private
     * @readonly
     * @enum {string} CookieAttributes
     */
    cookieAttributes = {
        httponly: 'httpOnly',
        secure: 'secure',
        domain: 'domain',
        path: 'path',
        'max-age': 'maxAge',
        session: 'session',
        expires: 'expires'
    },

    Cookie;

/**
 * The following is the object structure accepted as constructor parameter while calling `new Cookie(...)`. It is
 * also the structure exported when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a
 * Cookie instance.
 * @typedef Cookie~definition
 *
 * @property {String=} [key] The name of the cookie. Some call it the "name".
 * @property {String=} [value] The value stored in the Cookie
 * @property {String=} [expires] Expires sets an expiry date for when a cookie gets deleted. It should either be a
 * date object or timestamp string of date.
 * @property {Number=} [maxAge] Max-age sets the time in seconds for when a cookie will be deleted.
 * @property {String=} [domain] Indicates the domain(s) for which the cookie should be sent.
 * @property {String=} [path] Limits the scope of the cookie to a specified path, e.g: "/accounts"
 * @property {Boolean=} [secure] A secure cookie will only be sent to the server when a request is made using SSL and
 * the HTTPS protocol.
 * The idea that the contents of the cookie are of high value and could be potentially damaging to transmit
 * as clear text.
 * @property {Boolean=} [httpOnly] The idea behind HTTP-only cookies is to instruct a browser that a cookie should never
 * be accessible via JavaScript through the document.cookie property. This feature was designed as a security measure
 * to help prevent cross-site scripting (XSS) attacks perpetrated by stealing cookies via JavaScript.
 * @property {Boolean=} [hostOnly] Indicates that this cookie is only valid for the given domain (and not its parent or
 * child domains.)
 * @property {Boolean=} [session] Indicates whether this is a Session Cookie. (A transient cookie, which is deleted at
 * the end of an HTTP session.)
 * @property {Array=} [extensions] Any extra attributes that are extensions to the original Cookie specification can be
 * specified here.
 * @property {String} [extensions[].key] Name of the extension.
 * @property {String} [extensions[].value] Value of the extension
 *
 * @example <caption>JSON definition of an example cookie</caption>
 * {
 *     "key": "my-cookie-name",
 *     "expires": "1464769543832",
 *      // UNIX timestamp, in *milliseconds*
 *     "maxAge": "300",
 *      // In seconds. In this case, the Cookie is valid for 5 minutes
 *     "domain": "something.example.com",
 *     "path": "/",
 *     "secure": false,
 *     "httpOnly": true,
 *     "session": false,
 *     "value": "my-cookie-value",
 *     "extensions": [{
 *         "key": "Priority",
 *         "value": "HIGH"
 *     }]
 * }
 */
_.inherit((

    /**
     * A Postman Cookie definition that comprehensively represents an HTTP Cookie.
     *
     * @constructor
     * @extends {PropertyBase}
     *
     * @param {Cookie~definition} [options] Pass the initial definition of the Cookie.
     * @example <caption>Create a new Cookie</caption>
     * var Cookie = require('postman-collection').Cookie,
     *     myCookie = new Cookie({
     *          name: 'my-cookie-name',
     *          expires: '1464769543832', // UNIX timestamp, in *milliseconds*
     *          maxAge: '300',  // In seconds. In this case, the Cookie is valid for 5 minutes
     *          domain: 'something.example.com',
     *          path: '/',
     *          secure: false,
     *          httpOnly: true,
     *          session: false,
     *          value: 'my-cookie-value',
     *          extensions: [{
     *              key: 'Priority',
     *              value: 'HIGH'
     *          }]
     *     });
     *
     * @example <caption>Parse a Cookie Header</caption>
     * var Cookie = require('postman-collection').Cookie,
     *     rawHeader = 'myCookie=myValue;Path=/;Expires=Sun, 04-Feb-2018 14:18:27 GMT;Secure;HttpOnly;Priority=HIGH'
     *     myCookie = new Cookie(rawHeader);
     *
     * console.log(myCookie.toJSON());
     */
    Cookie = function PostmanCookie (options) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Cookie.super_.call(this, options);

        _.isString(options) && (options = Cookie.parse(options));

        options && this.update(options);
    }), PropertyBase);

_.assign(Cookie.prototype, /** @lends Cookie.prototype */ {
    update: function (options) {
        _.mergeDefined(this, /** @lends Cookie.prototype */ {
            /**
             * The name of the cookie.
             * @type {String}
             */
            name: _.choose(options.name, options.key),

            /**
             * Expires sets an expiry date for when a cookie gets deleted. It should either be a date object or
             * timestamp string of date.
             * @type {Date|String}
             *
             * @note
             * The value for this option is a date in the format Wdy, DD-Mon-YYYY HH:MM:SS GMT such as
             * "Sat, 02 May 2009 23:38:25 GMT". Without the expires option, a cookie has a lifespan of a single session.
             * A session is defined as finished when the browser is shut down, so session cookies exist only while the
             * browser remains open. If the expires option is set to a date that appears in the past, then the cookie is
             * immediately deleted in browser.
             *
             * @todo Accept date object and convert stringified date (timestamp only) to date object
             * @todo Consider using Infinity as a default
             */
            expires: _.isString(options.expires) ? new Date(options.expires) : options.expires,

            /**
             * Max-age sets the time in seconds for when a cookie will be deleted.
             * @type {Number}
             */
            maxAge: _.has(options, 'maxAge') ? Number(options.maxAge) : undefined,

            /**
             * Indicates the domain(s) for which the cookie should be sent.
             * @type {String}
             *
             * @note
             * By default, domain is set to the host name of the page setting the cookie, so the cookie value is sent
             * whenever a request is made to the same host name. The value set for the domain option must be part of the
             * host name that is sending the Set-Cookie header. The SDK does not perform this check, but the underlying
             * client that actually sends the request could do it automatically.
             */
            domain: options.domain,

            /**
             * @type {String}
             *
             * @note
             * On server, the default value for the path option is the path of the URL that sent the Set-Cookie header.
             */
            path: options.path,

            /**
             * A secure cookie will only be sent to the server when a request is made using SSL and the HTTPS protocol.
             * The idea that the contents of the cookie are of high value and could be potentially damaging to transmit
             * as clear text.
             * @type: {Boolean}
             */
            secure: _.has(options, 'secure') ? Boolean(options.secure) : undefined,

            /**
             * The idea behind HTTP-only cookies is to instruct a browser that a cookie should never be accessible via
             * JavaScript through the document.cookie property. This feature was designed as a security measure to help
             * prevent cross-site scripting (XSS) attacks perpetrated by stealing cookies via JavaScript.
             * @type: {Boolean}
             */
            httpOnly: _.has(options, 'httpOnly') ? Boolean(options.httpOnly) : undefined,

            /**
             * @type: {Boolean}
             */
            hostOnly: _.has(options, 'hostOnly') ? Boolean(options.hostOnly) : undefined,

            /**
             * Indicates whether this is a Session Cookie.
             * @type: {Boolean}
             */
            session: _.has(options, 'session') ? Boolean(options.session) : undefined,

            /**
             * @note The commonly held belief is that cookie values must be URL-encoded, but this is a fallacy even
             * though it is the de facto implementation. The original specification indicates that only three types of
             * characters must be encoded: semicolon, comma, and white space. The specification indicates that URL
             * encoding may be used but stops short of requiring it. The RFC makes no mention of encoding whatsoever.
             * Still, almost all implementations perform some sort of URL encoding on cookie values.
             * @type {String}
             */
            value: options.value ? _.ensureEncoded(options.value) : undefined,

            /**
             * Any extra parameters that are not strictly a part of the Cookie spec go here.
             * @type {Array}
             */
            extensions: options.extensions || undefined
        });
    },

    /**
     * Get the value of this cookie.
     *
     * @return {String}
     */
    valueOf: function () {
        return decodeURIComponent(this.value);
    },

    /**
     * Converts the Cookie to a single Set-Cookie header string.
     *
     * @returns {String}
     */
    toString: function () {
        var str = Cookie.unparseSingle(this);

        if (this.expires && this.expires instanceof Date) {
            // check for valid date
            if (!Number.isNaN(this.expires.getTime())) {
                str += '; Expires=' + this.expires.toUTCString();
            }
        }
        else if (this.expires) {
            str += '; Expires=' + this.expires;
        }

        if (this.maxAge && this.maxAge !== Infinity) {
            str += '; Max-Age=' + this.maxAge;
        }

        if (this.domain && !this.hostOnly) {
            str += '; Domain=' + this.domain;
        }

        if (this.path) {
            str += '; Path=' + this.path;
        }

        if (this.secure) {
            str += '; Secure';
        }

        if (this.httpOnly) {
            str += '; HttpOnly';
        }

        if (this.extensions) {
            this.extensions.forEach(function (ext) {
                str += '; ' + ext;
            });
        }

        return str;
    }
});

_.assign(Cookie, /** @lends Cookie */ {

    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Cookie',

    // define behaviour of this object when put in list
    _postman_propertyIndexKey: 'name',
    _postman_propertyIndexCaseInsensitive: true,
    _postman_propertyAllowsMultipleValues: true,

    /**
     * Check whether an object is an instance of PostmanCookie.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isCookie: function (obj) {
        return Boolean(obj) && ((obj instanceof Cookie) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Cookie._postman_propertyName));
    },

    /**
     * Stringifies an Array or {@link PropertyList} of Cookies into a single string.
     *
     * @param {[Cookie]} cookies - List of cookie definition object
     * @returns {String}
     */
    unparse: function (cookies) {
        if (!_.isArray(cookies) && !PropertyList.isPropertyList(cookies)) {
            return E;
        }

        return cookies.map(Cookie.unparseSingle).join(COOKIES_SEPARATOR);
    },

    /**
     * Unparses a single Cookie.
     *
     * @param {Cookie} cookie - Cookie definition object
     * @returns {String}
     */
    unparseSingle: function (cookie) {
        if (!_.isObject(cookie)) { return E; }

        var value = _.isNil(cookie.value) ? E : cookie.value;

        // for the empty name, return just the value to match the browser behavior
        if (!cookie.name) {
            return value;
        }

        return cookie.name + EQ + value;
    },

    /**
     * Cookie header parser
     *
     * @param {String} str
     * @returns {*} A plain cookie options object, use it to create a new Cookie
     */
    parse: function (str) {
        if (!_.isString(str)) {
            return str;
        }

        var obj = {},
            pairs = str.split(PAIR_SPLIT_REGEX),
            nameval;

        nameval = Cookie.splitParam(pairs.shift()); // The first kvp is the name and value
        obj.key = nameval.key;
        obj.value = nameval.value;

        pairs.forEach(function (pair) {
            var keyval = Cookie.splitParam(pair),
                value = keyval.value,
                keyLower = keyval.key.toLowerCase();

            if (cookieAttributes[keyLower]) {
                obj[cookieAttributes[keyLower]] = value;
            }
            else {
                obj.extensions = obj.extensions || [];
                obj.extensions.push(keyval);
            }
        });
        // Handle the hostOnly flag
        if (!obj.domain) {
            obj.hostOnly = true;
        }
        return obj;
    },

    /**
     * Converts the Cookie to a single Set-Cookie header string.
     *
     * @param {Cookie} cookie - Cookie definition object
     * @returns {String}
     */
    stringify: function (cookie) {
        return Cookie.prototype.toString.call(cookie);
    },

    /**
     * Splits a Cookie parameter into a key and a value
     *
     * @private
     * @param {String} param
     * @returns {{key: *, value: (boolean|*)}}
     */
    splitParam: function (param) {
        var split = param.split('='),
            key, value;
        key = split[0].trim();
        value = (split[1]) ? split[1].trim() : true;

        if (_.isString(value) && value[0] === '"') {
            value = value.slice(1, -1);
        }

        return { key: key, value: value };
    }
});

module.exports = {
    Cookie: Cookie
};


/***/ }),

/***/ 4371:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    semver = __webpack_require__(5311),
    PropertyBase = __webpack_require__(3813).PropertyBase,

    Version;

_.inherit((

    /**
     * Defines a Version.
     *
     * @constructor
     * @extends {PropertyBase}
     * @param {Object|String} options
     */
    Version = function PostmanPropertyVersion (options) {
        // in case definition object is missing, there is no point moving forward
        if (!options) { return; }

        // call the setter to process the version string and assign it to this object
        this.set(options);
    }), PropertyBase);

_.assign(Version.prototype, /** @lends Version.prototype */ {
    /**
     * Set the version value as string or object with separate components of version
     *
     * @draft
     * @param {object|string} value
     */
    set: function (value) {
        // extract the version logic and in case it failes and value passed is an object, we use that assuming parsed
        // value has been sent.
        var ver = semver.parse(value) || value || {};

        _.assign(this, /** @lends Version.prototype */ {
            /**
             * The raw URL string. If {@link Version#set} is called with a string parameter, the string is saved here
             * before parsing various Version components.
             *
             * @type {String}
             */
            raw: ver.raw,

            /**
             * @type {String}
             */
            major: ver.major,

            /**
             * @type {String}
             */
            minor: ver.minor,

            /**
             * @type {String}
             */
            patch: ver.patch,

            /**
             * @type {String}
             */
            prerelease: ver.prerelease && ver.prerelease.join && ver.prerelease.join() || ver.prerelease,

            /**
             * @type {String}
             */
            build: ver.build && ver.build.join && ver.build.join() || ver.build,

            /**
             * @type {String}
             */
            string: ver.version
        });
    },

    toString: function () {
        // TODO: is this enough? should we build the semver back up?
        return this.string || this.raw;
    }
});

_.assign(Version, /** @lends Version */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Version'
});

module.exports = {
    Version: Version
};


/***/ }),

/***/ 4372:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyBase = __webpack_require__(3813).PropertyBase,

    /**
     * Primitive mutation types.
     *
     * @private
     * @constant
     * @type {Object}
     */
    PRIMITIVE_MUTATIONS = {
        SET: 'set',
        UNSET: 'unset'
    },

    /**
     * Detects if the mutation is a primitive mutation type. A primitive mutation is the simplified mutation structure.
     *
     * @returns {Boolean}
     */
    isPrimitiveMutation = function (mutation) {
        return mutation && mutation.length <= 2;
    },

    /**
     * Applies a single mutation on a target.
     *
     * @private
     * @param {*} target
     * @param {MutationTracker~mutation} mutation
     */
    applyMutation = function applyMutation (target, mutation) {
        // only `set` and `unset` instructions are supported
        // for non primitive mutations, the instruction would have to be extracted from mutation
        if (!isPrimitiveMutation(mutation)) {
            return;
        }

        // extract instruction from the mutation
        var operation = mutation.length > 1 ? PRIMITIVE_MUTATIONS.SET : PRIMITIVE_MUTATIONS.UNSET;

        // now hand over applying mutation to the target
        // @todo: primitive mutations have not more than two items
        // though spread would be more future proof
        // switch to array spread once we drop support for node v4
        target.applyMutation(operation, mutation[0], mutation[1]);
    },

    MutationTracker;

/**
 * A JSON representation of a mutation on an object. Here objects mean instances of postman-collection classes.
 * This captures the instruction and the parameters of the instruction so that it can be replayed on a different object.
 * Mutations can be any change on an object. For example setting a key or unsetting a key.
 *
 * For example, the mutation to set `name` on an object to 'Bruce Wayne' would look like ['name', 'Bruce Wayne']. Where
 * the first item is the key path and second item is the value. To add a property `punchLine` to the object it would be
 * the same as updating the property i.e. ['punchLine', 'I\'m Batman']. To remove a property `age` the mutation would
 * look like ['age'].
 *
 * This format of representing changes is derived from
 * {@link http://json-delta.readthedocs.io/en/latest/philosophy.html}.
 *
 * The `set` and `unset` are primitive instructions and can be derived from the mutation without explicitly stating the
 * instruction. For more complex mutation the instruction would have to be explicitly stated.
 *
 * @typedef {Array} MutationTracker~mutation
 */

/**
 * A JSON representation of the MutationTracker.
 *
 * @typedef MutationTracker~definition
 *
 * @property {Array} stream contains the stream mutations tracked
 * @property {Object} compacted contains a compacted version of the mutations
 * @property {Boolean} [autoCompact=false] when set to true, all new mutations would be compacted immediately
 */
_.inherit((

    /**
     * A MutationTracker allows to record mutations on any of object and store them. This stored mutations can be
     * transported for reporting or to replay on similar objects.
     *
     * @constructor
     * @extends {PropertyBase}
     *
     * @param {MutationTracker~definition} definition serialized mutation tracker
     */
    MutationTracker = function MutationTracker (definition) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        MutationTracker.super_.call(this, definition);

        definition = definition || {};

        // initialize options
        this.autoCompact = Boolean(definition.autoCompact);

        // restore mutations
        this.stream = Array.isArray(definition.stream) ? definition.stream : [];
        this.compacted = _.isPlainObject(definition.compacted) ? definition.compacted : {};
    }), PropertyBase);

_.assign(MutationTracker.prototype, /** @lends MutationTracker.prototype */ {

    /**
     * Records a new mutation.
     *
     * @private
     * @param {MutationTracker~mutation} mutation
     */
    addMutation: function (mutation) {
        // bail out for empty or unsupported mutations
        if (!(mutation && isPrimitiveMutation(mutation))) {
            return;
        }

        // if autoCompact is set, we need to compact while adding
        if (this.autoCompact) {
            this.addAndCompact(mutation);
            return;
        }

        // otherwise just push to the stream of mutations
        this.stream.push(mutation);
    },

    /**
     * Records a mutation compacting existing mutations for the same key path.
     *
     * @private
     * @param {MutationTracker~mutation} mutation
     */
    addAndCompact: function (mutation) {
        // for `set` and `unset` mutations the key to compact with is the `keyPath`
        var key = mutation[0];

        // convert `keyPath` to a string
        key = Array.isArray(key) ? key.join('.') : key;

        this.compacted[key] = mutation;
    },

    /**
     * Track a mutation.
     *
     * @param {String} instruction the type of mutation
     */
    track: function (instruction) {
        // @todo: use argument spread here once we drop support for node v4
        var payload = Array.prototype.slice.call(arguments, 1);

        // invalid call
        if (!(instruction && payload)) {
            return;
        }

        // unknown instruction
        if (!(instruction === PRIMITIVE_MUTATIONS.SET || instruction === PRIMITIVE_MUTATIONS.UNSET)) {
            return;
        }

        // for primitive mutations the arguments form the mutation object
        // if there is more complex mutation, we have to use a processor to create a mutation for the instruction
        this.addMutation(payload);
    },

    /**
     * Compacts the recorded mutations removing duplicate mutations that apply on the same key path.
     */
    compact: function () {
        // for each of the mutation, add to compacted list
        this.stream.forEach(this.addAndCompact.bind(this));

        // reset the `stream`, all the mutations are now recorded in the `compacted` storage
        this.stream = [];
    },

    /**
     * Returns the number of mutations tracked so far.
     *
     * @returns {Number}
     */
    count: function () {
        // the total count of mutations is the sum of
        // mutations in the stream
        var mutationCount = this.stream.length;

        // and the compacted mutations
        mutationCount += Object.keys(this.compacted).length;

        return mutationCount;
    },

    /**
     * Applies all the recorded mutations on a target object.
     *
     * @param {*} target Target to apply mutations. Must implement `applyMutation`.
     */
    applyOn: function (target) {
        if (!(target && target.applyMutation)) {
            return;
        }

        var applyIndividualMutation = function applyIndividualMutation (mutation) {
            applyMutation(target, mutation);
        };

        // mutations move from `stream` to `compacted`, so we apply the compacted mutations first
        // to ensure FIFO of mutations

        // apply the compacted mutations first
        _.forEach(this.compacted, applyIndividualMutation);

        // apply the mutations in the stream
        _.forEach(this.stream, applyIndividualMutation);
    }
});

_.assign(MutationTracker, /** @lends MutationTracker */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'MutationTracker',

    /**
     * Check whether an object is an instance of {@link MutationTracker}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isMutationTracker: function (obj) {
        return Boolean(obj) && ((obj instanceof MutationTracker) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', MutationTracker._postman_propertyName));
    }
});

module.exports = {
    MutationTracker: MutationTracker
};


/***/ }),

/***/ 4373:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4374),

  parseRequest = __webpack_require__(5318),
  sanitize = __webpack_require__(3980).sanitize,
  sanitizeOptions = __webpack_require__(3980).sanitizeOptions,
  addFormParam = __webpack_require__(3980).addFormParam,
  self;

/**
 * Generates snippet in csharp-restsharp by parsing data from Postman-SDK request object
 *
 * @param {Object} request - Postman SDK request object
 * @param {Object} options - Options to tweak code snippet
 * @returns {String} csharp-restsharp code snippet for given request object
 */
function makeSnippet (request, options) {
  const UNSUPPORTED_METHODS_LIKE_POST = ['LINK', 'UNLINK', 'LOCK', 'PROPFIND'],
    UNSUPPORTED_METHODS_LIKE_GET = ['PURGE', 'UNLOCK', 'VIEW', 'COPY'];

  var snippet = `var client = new RestClient("${sanitize(request.url.toString())}");\n`,
    isUnSupportedMethod = UNSUPPORTED_METHODS_LIKE_GET.includes(request.method) ||
            UNSUPPORTED_METHODS_LIKE_POST.includes(request.method);
  if (options.requestTimeout) {
    snippet += `client.Timeout = ${options.requestTimeout};\n`;
  }
  else {
    snippet += 'client.Timeout = -1;\n';
  }
  if (!options.followRedirect) {
    snippet += 'client.FollowRedirects = false;\n';
  }
  snippet += `var request = new RestRequest(${isUnSupportedMethod ? '' : ('Method.' + request.method)});\n`;
  if (request.body && request.body.mode === 'graphql' && !request.headers.has('Content-Type')) {
    request.addHeader({
      key: 'Content-Type',
      value: 'application/json'
    });
  }
  snippet += parseRequest.parseHeader(request.toJSON(), options.trimRequestBody);
  if (request.body && request.body.mode === 'formdata') {
    let isFile = false,
      formdata = request.body.formdata,
      formdataArray = [];
    request.body.toJSON().formdata.forEach((data) => {
      if (!data.disabled && data.type === 'file') {
        isFile = true;
      }
    });
    // The following statement needs to be added else the multipart/form-data request where there is no file
    // is being sent as x-www-form-urlencoded by default
    if (!isFile) {
      snippet += 'request.AlwaysMultipartFormData = true;\n';
    }

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  snippet += parseRequest.parseBody(request, options.trimRequestBody);
  if (isUnSupportedMethod) {
    (UNSUPPORTED_METHODS_LIKE_GET.includes(request.method)) &&
            (snippet += `IRestResponse response = client.ExecuteAsGet(request, "${request.method}");\n`);
    (UNSUPPORTED_METHODS_LIKE_POST.includes(request.method)) &&
            (snippet += `IRestResponse response = client.ExecuteAsPost(request, "${request.method}");\n`);
  }
  else {
    snippet += 'IRestResponse response = client.Execute(request);\n';
  }
  snippet += 'Console.WriteLine(response.Content);';

  return snippet;
}

self = module.exports = {
  /**
     * Used in order to get additional options for generation of C# code snippet (i.e. Include Boilerplate code)
     *
     * @module getOptions
     *
     * @returns {Array} Additional options specific to generation of csharp-restsharp code snippet
     */
  getOptions: function () {
    return [
      {
        name: 'Include boilerplate',
        id: 'includeBoilerplate',
        type: 'boolean',
        default: false,
        description: 'Include class definition and import statements in snippet'
      },
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        availableOptions: ['Tab', 'Space'],
        default: 'Space',
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response ' +
          'before timing out (use 0 for infinity)'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      }
    ];
  },

  /**
     * Converts Postman sdk request object to csharp-restsharp code snippet
     *
     * @module convert
     *
     * @param {Object} request - Postman-SDK request object
     * @param {Object} options - Options to tweak code snippet generated in C#
     * @param {String} options.indentType - type for indentation eg: Space, Tab (default: Space)
     * @param {String} options.indentCount - number of spaces or tabs for indentation. (default: 4 for indentType:
                                                                         Space, default: 1 for indentType: Tab)
     * @param {Boolean} [options.includeBoilerplate] - indicates whether to include class defination in C#
     * @param {Boolean} options.followRedirect - whether to enable followredirect
     * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not (default: false)
     * @param {Number} options.requestTimeout - time in milli-seconds after which request will bail out
                                                     (default: 0 -> never bail out)
     * @param {Function} callback - Callback function with parameters (error, snippet)
     * @returns {String} Generated C# snippet via callback
     */
  convert: function (request, options, callback) {

    if (!_.isFunction(callback)) {
      throw new Error('C#-RestSharp-Converter: Callback is not valid function');
    }

    //  String representing value of indentation required
    var indentString,

      //  snippets to include C# class definition according to options
      headerSnippet = '',
      footerSnippet = '',

      //  snippet to create request in csharp-restsharp
      snippet = '';

    options = sanitizeOptions(options, self.getOptions());

    indentString = options.indentType === 'Tab' ? '\t' : ' ';
    indentString = indentString.repeat(options.indentCount);

    if (options.includeBoilerplate) {
      headerSnippet = 'using System;\n' +
                            'using RestSharp;\n' +
                            'namespace HelloWorldApplication {\n' +
                            indentString + 'class HelloWorld {\n' +
                            indentString.repeat(2) + 'static void Main(string[] args) {\n';
      footerSnippet = indentString.repeat(2) + '}\n' + indentString + '}\n}\n';
    }

    snippet = makeSnippet(request, options);

    //  if boilerplate is included then two more indentString needs to be added in snippet
    (options.includeBoilerplate) &&
        (snippet = indentString.repeat(3) + snippet.split('\n').join('\n' + indentString.repeat(3)) + '\n');

    return callback(null, headerSnippet + snippet + footerSnippet);
  }
};


/***/ }),

/***/ 4374:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4375:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4376),

  parseRequest = __webpack_require__(5331),
  sanitize = __webpack_require__(3981).sanitize,
  addFormParam = __webpack_require__(3981).addFormParam,
  sanitizeOptions = __webpack_require__(3981).sanitizeOptions;

//  Since Java OkHttp requires to add extralines of code to handle methods with body
const METHODS_WITHOUT_BODY = ['GET', 'HEAD', 'COPY', 'UNLOCK', 'UNLINK', 'PURGE', 'LINK', 'VIEW'];

/**
 * retuns snippet of java okhttp by parsing data from Postman-SDK request object
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required for code snippet
 * @param {Object} options - Options to tweak code snippet
 * @returns {String} - java okhttp code snippet for given request object
 */
function makeSnippet (request, indentString, options) {

  var isBodyRequired = !(_.includes(METHODS_WITHOUT_BODY, request.method)),
    snippet = 'OkHttpClient client = new OkHttpClient().newBuilder()\n',
    requestBody;

  if (options.requestTimeout > 0) {
    snippet += indentString + `.setConnectTimeout(${options.requestTimeout}, TimeUnit.MILLISECONDS)\n`;
  }

  if (!options.followRedirect) {
    snippet += indentString + '.followRedirects(false)\n';
  }

  snippet += indentString + '.build();\n';

  if (isBodyRequired) {
    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        if (type === 'file') {
          if (typeof param.src !== 'string') {
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    requestBody = (request.body ? request.body.toJSON() : {});
    //  snippet for creating mediatype object in java based on content-type of request
    snippet += `MediaType mediaType = MediaType.parse("${parseRequest.parseContentType(request)}");\n`;
    snippet += parseRequest.parseBody(requestBody, indentString, options.trimRequestBody);
  }

  snippet += 'Request request = new Request.Builder()\n';
  snippet += indentString + `.url("${sanitize(request.url.toString())}")\n`;
  snippet += indentString + `.method("${request.method}", ${isBodyRequired ? 'body' : 'null'})\n`;
  if (request.body && request.body.mode === 'graphql' && !request.headers.has('Content-Type')) {
    request.addHeader({
      key: 'Content-Type',
      value: 'application/json'
    });
  }
  //  java-okhttp snippet for adding headers to request
  snippet += parseRequest.parseHeader(request, indentString);

  snippet += indentString + '.build();\n';
  snippet += 'Response response = client.newCall(request).execute();';

  return snippet;
}

/**
 * Used in order to get options for generation of Java okhattp code snippet (i.e. Include Boilerplate code)
 *
 * @module getOptions
 *
 * @returns {Array} Options specific to generation of Java okhattp code snippet
 */
function getOptions () {
  return [
    {
      name: 'Include boilerplate',
      id: 'includeBoilerplate',
      type: 'boolean',
      default: false,
      description: 'Include class definition and import statements in snippet'
    },
    {
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response ' +
        'before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
 * Converts Postman sdk request object to java okhttp code snippet
 *
 * @module convert
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options - Options to tweak code snippet generated in Java-OkHttp
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} [options.includeBoilerplate] - indicates whether to include class defination in java
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
function convert (request, options, callback) {

  if (_.isFunction(options)) {
    callback = options;
    options = {};
  }
  else if (!_.isFunction(callback)) {
    throw new Error('Java-OkHttp-Converter: callback is not valid function');
  }
  options = sanitizeOptions(options, getOptions());
  //  String representing value of indentation required
  var indentString,

    //  snippets to include java class definition according to options
    headerSnippet = '',
    footerSnippet = '',

    //  snippet to create request in java okhttp
    snippet = '';

  indentString = options.indentType === 'Tab' ? '\t' : ' ';
  indentString = indentString.repeat(options.indentCount);

  if (options.includeBoilerplate) {
    headerSnippet = 'import java.io.*;\n' +
                        'import okhttp3.*;\n' +
                        'public class main {\n' +
                        indentString + 'public static void main(String []args) throws IOException{\n';
    footerSnippet = indentString.repeat(2) + 'System.out.println(response.body().string());\n' +
                        indentString + '}\n}\n';
  }

  snippet = makeSnippet(request, indentString, options);

  //  if boilerplate is included then two more indentString needs to be added in snippet
  (options.includeBoilerplate) &&
    (snippet = indentString.repeat(2) + snippet.split('\n').join('\n' + indentString.repeat(2)) + '\n');

  return callback(null, headerSnippet + snippet + footerSnippet);
}
module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 4376:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.indexOf(value) !== -1; // eslint-disable-line lodash/prefer-includes
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4377:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4378),
  sanitizeOptions = __webpack_require__(4095).sanitizeOptions,
  addFormParam = __webpack_require__(4095).addFormParam,

  parseRequest = __webpack_require__(5334);

//  Methods supported by Java Unirest Library
const SUPPORTED_METHODS = ['GET', 'POST', 'PUT', 'HEAD', 'PATCH', 'DELETE', 'OPTIONS'];

/**
 * parses request and returns java unirest code snippet
 *
 * @param {Object} request - Postman SDK Request Object
 * @param {String} indentString - indentation required for code snippet
 * @param {Object} options
 * @return {String} - java unirest code snippet
 */
function makeSnippet (request, indentString, options) {
  var snippet = '',
    urlString = parseRequest.getUrlStringfromUrlObject(request.url);

  if (options.requestTimeout > 0) {
    snippet += `Unirest.setTimeouts(0, ${options.requestTimeout});\n`;
  }
  else {
    snippet += 'Unirest.setTimeouts(0, 0);\n';
  }

  if (!options.followRedirect) {
    snippet += 'Unirest.setHttpClient(org.apache.http.impl.client.HttpClients.custom()\n' +
                   indentString + '.disableRedirectHandling()\n' +
                   indentString + '.build());\n';
  }

  snippet += 'HttpResponse<String> response = Unirest.';

  //  since unirest supports only six HTTP request methods
  if (_.includes(SUPPORTED_METHODS, request.method)) {
    snippet += `${request.method.toLowerCase()}("${urlString}")\n`;
  }
  else {
    console.warn(request.method + ' method isn\'t supported by Unirest java library');
    snippet += `get("${urlString}")\n`;
  }
  if (request.body && request.body.mode === 'graphql' && !request.headers.has('Content-Type')) {
    request.addHeader({
      key: 'Content-Type',
      value: 'application/json'
    });
  }
  snippet += parseRequest.parseHeader(request, indentString);

  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  snippet += parseRequest.parseBody(request, indentString, options.trimRequestBody);
  snippet += indentString + '.asString();\n';

  return snippet;
}

/**
 * Specifies the additional options applicable to this code generator other than standard options
 *
 * @returns {Array} - Array of the particular options applicable to java unirest
 */
function getOptions () {
  return [
    {
      name: 'Include boilerplate',
      id: 'includeBoilerplate',
      type: 'boolean',
      default: false,
      description: 'Include class definition and import statements in snippet'
    },
    {
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response ' +
        'before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
 * Converts postman sdk request object into http snippet for java unirest
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} [options.includeBoilerplate] - indicates whether to include class defination in java
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters as (error, snippet)
 */
function convert (request, options, callback) {

  if (!_.isFunction(callback)) {
    throw new Error('Java-Unirest-Converter: callback is not valid function');
  }
  options = sanitizeOptions(options, getOptions());
  //  String representing value of indentation required
  var indentString,

    //  code snippets to include java class definition according to options
    headerSnippet = '',
    footerSnippet = '',

    //  code snippet to create request using java unirest
    snippet = '';

  indentString = options.indentType === 'Tab' ? '\t' : ' ';
  indentString = indentString.repeat(options.indentCount);

  if (options.includeBoilerplate) {
    headerSnippet = 'import com.mashape.unirest.http.*;\n' +
                        'import java.io.*;\n' +
                        'public class main {\n' +
                        indentString + 'public static void main(String []args) throws Exception{\n';
    footerSnippet = indentString.repeat(2) + 'System.out.println(response.getBody());\n' +
                        indentString + '}\n}\n';
  }

  snippet = makeSnippet(request, indentString, options);

  //  if boilerplate is included then two more indentString needs to be added in snippet
  (options.includeBoilerplate) &&
    (snippet = indentString.repeat(2) + snippet.split('\n').join('\n' + indentString.repeat(2)) + '\n');

  return callback(null, headerSnippet + snippet + footerSnippet);
}
module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 4378:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.indexOf(value) !== -1; // eslint-disable-line lodash/prefer-includes
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4379:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4380),
  parseBody = __webpack_require__(5340),
  sanitize = __webpack_require__(3982).sanitize,
  sanitizeOptions = __webpack_require__(3982).sanitizeOptions,
  addFormParam = __webpack_require__(3982).addFormParam,
  path = __webpack_require__(15),
  self;

/**
     * Used to parse the request headers
     *
     * @param  {Object} request - postman SDK-request object
     * @param  {String} indent - used for indenting snippet's structure
     * @returns {String} - request headers in the desired format
     */
function getHeaders (request, indent) {
  var headerObject = request.getHeaders({ enabled: true}),
    headerMap;

  if (!_.isEmpty(headerObject)) {
    headerMap = _.map(Object.keys(headerObject), function (key) {
      if (Array.isArray(headerObject[key])) {
        var headerValues = [];
        _.forEach(headerObject[key], (value) => {
          headerValues.push(`"${sanitize(value, 'header')}"`);
        });
        return `${indent.repeat(2)}"${sanitize(key, 'header', true)}": ` +
          `[${headerValues.join(', ')}]`;
      }
      return `${indent.repeat(2)}"${sanitize(key, 'header', true)}": ` +
          `"${sanitize(headerObject[key], 'header')}"`;
    });
    return `${indent}"headers": {\n${headerMap.join(',\n')}\n${indent}},\n`;
  }
  return '';
}

/**
     * Used to get the form-data
     *
     * @param  {Object} request - postman SDK-request object
     * @param  {String} trimRequestBody - whether to trim request body fields
     * @returns {String} - form-data in the desired format
     */
function createForm (request, trimRequestBody) {
  var form = '',
    enabledFormList,
    formMap;

  form += 'var form = new FormData();\n';
  enabledFormList = _.reject(request.body[request.body.mode], 'disabled');
  if (!_.isEmpty(enabledFormList)) {
    formMap = _.map(enabledFormList, function (value) {
      if (value.type === 'text') {
        return (`form.append("${sanitize(value.key, request.body.mode, trimRequestBody)}", "` +
                    `${sanitize(value.value, request.body.mode, trimRequestBody)}");`);
      }
      var pathArray = value.src.split(path.sep),
        fileName = pathArray[pathArray.length - 1];
      return (`form.append("${sanitize(value.key, request.body.mode, trimRequestBody)}", fileInput.files[0], ` +
                    `"${sanitize(fileName, request.body.mode, trimRequestBody)}");`);
    });
    form += `${formMap.join('\n')}\n\n`;
  }
  return form;
}

self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @returns {Array}
     */
  getOptions: function () {
    return [{
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }];
  },

  /**
    * Used to convert the postman sdk-request object in php-curl request snippet
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.trimRequestBody : whether to trim request body fields (default: false)
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var jQueryCode = '',
      indentType = '',
      indent = '';

    if (_.isFunction(options)) {
      callback = options;
      options = null;
    }
    else if (!_.isFunction(callback)) {
      throw new Error('js-jQuery~convert: Callback is not a function');
    }
    options = sanitizeOptions(options, self.getOptions());
    indentType = (options.indentType === 'Tab') ? '\t' : ' ';

    indent = indentType.repeat(options.indentCount);

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        if (type === 'file') {
          if (typeof param.src !== 'string') {
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
      jQueryCode = createForm(request.toJSON(), options.trimRequestBody);
    }
    jQueryCode += 'var settings = {\n';
    jQueryCode += `${indent}"url": "${sanitize(request.url.toString(), 'url')}",\n`;
    jQueryCode += `${indent}"method": "${request.method}",\n`;
    jQueryCode += `${indent}"timeout": ${options.requestTimeout},\n`;
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    jQueryCode += `${getHeaders(request, indent)}`;
    jQueryCode += `${parseBody(request.toJSON(), options.trimRequestBody, indent,
      request.headers.get('Content-Type'))}};\n\n`;
    jQueryCode += `$.ajax(settings).done(function (response) {\n${indent}console.log(response);\n});`;

    return callback(null, jQueryCode);
  }
};


/***/ }),

/***/ 4380:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4381:
/***/ (function(module, exports, __webpack_require__) {

const _ = __webpack_require__(4382),
  sanitizeOptions = __webpack_require__(4099).sanitizeOptions,
  addFormParam = __webpack_require__(4099).addFormParam,

  parseRequest = __webpack_require__(5349);
var self;

/**
 * retuns snippet of nodejs(native) by parsing data from Postman-SDK request object
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required for code snippet
 * @param {Object} options
 * @returns {String} - nodejs(native) code snippet for given request object
 */
function makeSnippet (request, indentString, options) {
  var nativeModule = (request.url.protocol === 'http' ? 'http' : 'https'),
    snippet = `var ${nativeModule} = require('${nativeModule}');\n`,
    optionsArray = [],
    postData = '';

  if (options.followRedirect) {
    snippet = `var ${nativeModule} = require('follow-redirects').${nativeModule};\n`;
  }
  snippet += 'var fs = require(\'fs\');\n\n';
  if (_.get(request, 'body.mode') && request.body.mode === 'urlencoded') {
    snippet += 'var qs = require(\'querystring\');\n\n';
  }

  snippet += 'var options = {\n';

  /**
     * creating string to represent options object using optionArray.join()
     * example:
     *  options: {
     *      method: 'GET',
     *      hostname: 'www.google.com',
     *      path: '/x?a=10',
     *      headers: {
     *          'content-type': 'multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW'
     *      }
     *  }
     */

  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  if (request.body && request.body[request.body.mode]) {
    postData += parseRequest.parseBody(request.body.toJSON(), indentString, options.trimRequestBody,
      request.headers.get('Content-Type'));
  }
  if (request.body && !request.headers.has('Content-Type')) {
    if (request.body.mode === 'file') {
      request.addHeader({
        key: 'Content-Type',
        value: 'text/plain'
      });
    }
    else if (request.body.mode === 'graphql') {
      request.addHeader({
        key: 'Content-Type',
        value: 'application/json'
      });
    }
  }

  parseRequest.parseURLVariable(request);

  optionsArray.push(indentString + `'method': '${request.method}'`);
  optionsArray.push(parseRequest.parseHost(request, indentString));
  if (request.url.port) {
    optionsArray.push(parseRequest.parsePort(request, indentString));
  }
  optionsArray.push(parseRequest.parsePath(request, indentString));
  optionsArray.push(parseRequest.parseHeader(request, indentString));
  if (options.followRedirect) {
    optionsArray.push(indentString + '\'maxRedirects\': 20');
  }

  snippet += optionsArray.join(',\n') + '\n';
  snippet += '};\n\n';

  snippet += `var req = ${nativeModule}.request(options, function (res) {\n`;

  snippet += indentString + 'var chunks = [];\n\n';
  snippet += indentString + 'res.on("data", function (chunk) {\n';
  snippet += indentString.repeat(2) + 'chunks.push(chunk);\n';
  snippet += indentString + '});\n\n';

  snippet += indentString + 'res.on("end", function (chunk) {\n';
  snippet += indentString.repeat(2) + 'var body = Buffer.concat(chunks);\n';
  snippet += indentString.repeat(2) + 'console.log(body.toString());\n';
  snippet += indentString + '});\n\n';

  snippet += indentString + 'res.on("error", function (error) {\n';
  snippet += indentString.repeat(2) + 'console.error(error);\n';
  snippet += indentString + '});\n';

  snippet += '});\n\n';

  if (request.body && !(_.isEmpty(request.body)) && postData.length) {
    snippet += `var postData = ${postData};\n\n`;

    if (request.method === 'DELETE') {
      snippet += 'req.setHeader(\'Content-Length\', postData.length);\n\n';
    }

    if (request.body.mode === 'formdata') {
      snippet += 'req.setHeader(\'content-type\',' +
            ' \'multipart/form-data; boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW\');\n\n';
    }

    snippet += 'req.write(postData);\n\n';
  }

  if (options.requestTimeout) {
    snippet += `req.setTimeout(${options.requestTimeout}, function() {\n`;
    snippet += indentString + 'req.abort();\n';
    snippet += '});\n\n';
  }

  snippet += 'req.end();';
  return snippet;
}

/**
 * Converts Postman sdk request object to nodejs native code snippet
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @returns {Array}
     */
  getOptions: function () {
    return [{
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }];
  },

  convert: function (request, options, callback) {
    if (!_.isFunction(callback)) {
      throw new Error('NodeJS-Request-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());

    //  String representing value of indentation required
    var indentString;

    indentString = options.indentType === 'Tab' ? '\t' : ' ';
    indentString = indentString.repeat(options.indentCount);

    return callback(null, makeSnippet(request, indentString, options));
  }
};


/***/ }),

/***/ 4382:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4383:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4384),

  parseRequest = __webpack_require__(5352),
  sanitize = __webpack_require__(4100).sanitize,
  sanitizeOptions = __webpack_require__(4100).sanitizeOptions;

/**
 * retuns snippet of nodejs(request) by parsing data from Postman-SDK request object
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required for code snippet
 * @param {Object} options
 * @returns {String} - nodejs(request) code snippet for given request object
 */
function makeSnippet (request, indentString, options) {
  var snippet = 'var request = require(\'request\');\n',
    optionsArray = [],
    isFormDataFile = false;
  if (request.body && request.body.mode === 'formdata') {
    _.forEach(request.body.toJSON().formdata, function (data) {
      if (!data.disabled && data.type === 'file') {
        isFormDataFile = true;
      }
    });
  }
  if (isFormDataFile) {
    snippet += 'var fs = require(\'fs\');\n';
  }
  snippet += 'var options = {\n';

  /**
     * creating string to represent options object using optionArray.join()
     * example:
     *  options: {
     *      method: 'GET',
     *      url: 'www.google.com',
     *      timeout: 1000
     *  }
     */
  optionsArray.push(indentString + `'method': '${request.method}'`);
  optionsArray.push(indentString + `'url': '${sanitize(request.url.toString())}'`);
  if (request.body && !request.headers.has('Content-Type')) {
    if (request.body.mode === 'file') {
      request.addHeader({
        key: 'Content-Type',
        value: 'text/plain'
      });
    }
    else if (request.body.mode === 'graphql') {
      request.addHeader({
        key: 'Content-Type',
        value: 'application/json'
      });
    }
  }
  optionsArray.push(parseRequest.parseHeader(request, indentString));

  if (request.body && request.body[request.body.mode]) {
    optionsArray.push(
      indentString + parseRequest.parseBody(request.body.toJSON(), indentString, options.trimRequestBody,
        request.headers.get('Content-Type'))
    );
  }
  if (options.requestTimeout) {
    optionsArray.push(indentString + `timeout: ${options.requestTimeout}`);
  }
  if (options.followRedirect === false) {
    optionsArray.push(indentString + 'followRedirect: false');
  }
  snippet += optionsArray.join(',\n') + '\n';
  snippet += '};\n';

  snippet += 'request(options, function (error, response) { \n';
  snippet += indentString + 'if (error) throw new Error(error);\n';
  snippet += indentString + 'console.log(response.body);\n';
  snippet += '});\n';
  return snippet;
}

/**
 * Used to get the options specific to this codegen
 *
 * @returns {Array} - Returns an array of option objects
 */
function getOptions () {
  return [
    {
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
 * Converts Postman sdk request object to nodejs request code snippet
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
function convert (request, options, callback) {
  if (!_.isFunction(callback)) {
    throw new Error('NodeJS-Request-Converter: callback is not valid function');
  }
  options = sanitizeOptions(options, getOptions());

  //  String representing value of indentation required
  var indentString;

  indentString = options.indentType === 'Tab' ? '\t' : ' ';
  indentString = indentString.repeat(options.indentCount);

  return callback(null, makeSnippet(request, indentString, options));
}

module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 4384:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4385:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4386),
  sanitize = __webpack_require__(3983).sanitize,
  sanitizeOptions = __webpack_require__(3983).sanitizeOptions,
  addFormParam = __webpack_require__(3983).addFormParam,

  parseRequest = __webpack_require__(5355);

/**
 * retuns snippet of nodejs(unirest) by parsing data from Postman-SDK request object
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required for code snippet
 * @param {Object} options
 * @returns {String} - nodejs(unirest) code snippet for given request object
 */
function makeSnippet (request, indentString, options) {
  var snippet = 'var unirest = require(\'unirest\');\n';

  snippet += `var req = unirest('${request.method}', '${sanitize(request.url.toString())}')\n`;
  if (request.body && !request.headers.has('Content-Type')) {
    if (request.body.mode === 'file') {
      request.addHeader({
        key: 'Content-Type',
        value: 'text/plain'
      });
    }
    else if (request.body.mode === 'graphql') {
      request.addHeader({
        key: 'Content-Type',
        value: 'application/json'
      });
    }
  }

  snippet += parseRequest.parseHeader(request, indentString);

  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  if (request.body) {
    snippet += parseRequest.parseBody(request.body.toJSON(), indentString, options.trimRequestBody,
      request.headers.get('Content-Type'));
  }
  if (options.requestTimeout) {
    snippet += indentString + `.timeout(${options.requestTimeout})`;
  }
  if (options.followRedirect === false) {
    snippet += indentString + '.followRedirect(false)\n';
  }

  snippet += indentString + '.end(function (res) { \n';
  snippet += indentString.repeat(2) + 'if (res.error) throw new Error(res.error); \n';
  snippet += indentString.repeat(2) + 'console.log(res.raw_body);\n';
  snippet += indentString + '});\n';

  return snippet;
}

/**
 * Used to get the options specific to this codegen
 *
 * @returns {Array} - Returns an array of option objects
 */
function getOptions () {
  return [
    {
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
 * Converts Postman sdk request object to nodejs(unirest) code snippet
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
function convert (request, options, callback) {
  if (!_.isFunction(callback)) {
    throw new Error('Nodejs-Unirest-Converter: callback is not valid function');
  }
  options = sanitizeOptions(options, getOptions());

  //  String representing value of indentation required
  var indentString;

  indentString = options.indentType === 'Tab' ? '\t' : ' ';
  indentString = indentString.repeat(options.indentCount);

  return callback(null, makeSnippet(request, indentString, options));
}

module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 4386:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4387:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5361),
  sanitize = __webpack_require__(4102).sanitize,
  sanitizeOptions = __webpack_require__(4102).sanitizeOptions,
  addFormParam = __webpack_require__(4102).addFormParam,
  self;

/**
 * Parses Raw data from request to fetch syntax
 *
 * @param {Object} body - Raw body data
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @returns {String} request body in the desired format
 */
function parseRawBody (body, mode, trim) {
  var bodySnippet;
  bodySnippet = `let postData = ref ${sanitize(body, mode, trim)};;\n\n`;
  return bodySnippet;
}

/**
 * Parses graphql data from request to fetch syntax
 *
 * @param {Object} body - graphql body data
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @returns {String} request body in the desired format
 */
function parseGraphQL (body, mode, trim) {
  let query = body.query,
    graphqlVariables,
    bodySnippet;
  try {
    graphqlVariables = JSON.parse(body.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  bodySnippet = `let postData = ref ${sanitize(JSON.stringify({
    query: query,
    variables: graphqlVariables
  }), mode, trim)};;\n\n`;
  return bodySnippet;
}

/**
 * Parses URLEncoded body from request to fetch syntax
 *
 * @param {Object} body - URLEncoded Body
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @returns {String} request body in the desired format
 */
function parseURLEncodedBody (body, mode, trim) {
  var payload, bodySnippet;
  payload = _.reduce(body, function (accumulator, data) {
    if (!data.disabled) {
      accumulator.push(`${sanitize(data.key, mode, trim)}=${sanitize(data.value, mode, trim)}`);
    }
    return accumulator;
  }, []).join('&');

  bodySnippet = `let postData = ref "${payload}";;\n\n`;
  return bodySnippet;
}

/**
 * Parses formData body from request to fetch syntax
 *
 * @param {Object} body - formData Body
 * @param {boolean} trim - trim body option
 * @param {String} indent - indentation string
 * @returns {String} request body in the desired format
 */
function parseFormData (body, trim, indent) {
  var parameters = '[|\n' + _.reduce(body, (accumalator, data) => {
      if (!data.disabled || data.disabled === false) {
        const key = sanitize(data.key, 'formdata-key', trim);

        /* istanbul ignore next */
        if (data.type === 'file') {
          const filename = data.src;
          accumalator.push(`${indent}[| ("name", "${key}"); ("fileName", "${filename}") |]`);
        }
        else {
          const value = sanitize(data.value, 'formdata-value', trim);
          accumalator.push(`${indent}[| ("name", "${key}"); ("value", "${value}") |]`);
        }
      }
      return accumalator;
      // eslint-disable-next-line no-useless-escape
    }, []).join(';\n') + '\n|];;',
    bodySnippet = '';

  bodySnippet = `let parameters = ${parameters}\n`;
  bodySnippet += 'let boundary = "----WebKitFormBoundary7MA4YWxkTrZu0gW";;\n';
  bodySnippet += 'let postData = ref "";;\n\n';
  bodySnippet += 'for x = 0 to Array.length parameters - 1 do\n';
  bodySnippet += `${indent}let (_, paramName) = parameters.(x).(0) in\n`;
  bodySnippet += `${indent}let (paramType, _) = parameters.(x).(1) in\n`;
  bodySnippet += `${indent}let accum = "--" ^ boundary ^ "\\r\\n" ^ "Content-Disposition: form-data; `;
  bodySnippet += 'name=\\"" ^ paramName ^ "\\"" in\n';
  bodySnippet += `${indent}if paramType = "value" then (\n`;
  bodySnippet += `${indent.repeat(2)}let (_, paramValue) = parameters.(x).(1) in\n`;
  bodySnippet += `${indent.repeat(2)}postData := !postData ^ accum ^ "\\r\\n\\r\\n" ^ paramValue ^ "\\r\\n";\n`;
  bodySnippet += `${indent})\n`;
  bodySnippet += `${indent}else if paramType = "fileName" then (\n`;
  bodySnippet += `${indent.repeat(2)}let (_, filepath) = parameters.(x).(1) in\n`;
  bodySnippet += `${indent.repeat(2)}postData := !postData ^ accum ^ "; filename=\\""^ filepath ^"\\"\\r\\n";\n`;
  bodySnippet += `${indent.repeat(2)}let ch = open_in filepath in\n`;
  bodySnippet += `${indent.repeat(3)}let fileContent = really_input_string ch (in_channel_length ch) in\n`;
  bodySnippet += `${indent.repeat(3)}close_in ch;\n`;
  bodySnippet += `${indent.repeat(2)}postData := !postData ^ "Content-Type: {content-type header}`;
  bodySnippet += `\\r\\n\\r\\n"^ fileContent ^"\\r\\n";\n${indent})\n`;
  bodySnippet += 'done;;\n';
  bodySnippet += 'postData := !postData ^ "--" ^ boundary ^ "--"\n\n';
  return bodySnippet;
}

/* istanbul ignore next */
/**
 * Parses file body from the Request
 *
 * @returns {String} request body in the desired format
 */
function parseFile () {
  // var bodySnippet = 'let load_file f =\n';
  // bodySnippet += `${indent}let ic = open_in f in\n`;
  // bodySnippet += `${indent}let n = in_channel_length ic in\n`;
  // bodySnippet += `${indent}let s = Bytes.create n in\n`;
  // bodySnippet += `${indent}really_input ic s 0 n;\n`;
  // bodySnippet += `${indent}close_in ic;\n${indent}(s)\n\n`;
  // bodySnippet += 'let postData = ref "";;\n';
  // bodySnippet += 'postData := load_file("{Insert_File_Name}");;\n\n';
  var bodySnippet = 'let postData = ref "<file contents here>";;\n\n';
  return bodySnippet;
}

/**
 * Parses Body from the Request using
 *
 * @param {Object} body - body object from request.
 * @param {boolean} trim - trim body option
 * @param {String} indent - indentation string
 * @returns {String} utility function for getting request body in the desired format
 */
function parseBody (body, trim, indent) {
  if (!_.isEmpty(body) && (!_.isEmpty(body[body.mode]))) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded, body.mode, trim);
      case 'raw':
        return parseRawBody(body.raw, body.mode, trim);
      case 'graphql':
        return parseGraphQL(body.graphql, 'raw', trim);
      case 'formdata':
        return parseFormData(body.formdata, trim, indent);
        /* istanbul ignore next */
      case 'file':
        return parseFile(indent);
      default:
        return '';
    }
  }
  return '';
}

/**
 * Parses headers from the request.
 *
 * @param {String} bodyMode - request body type i.e. formdata, file etc.
 * @param {Object} headers - headers from the request.
 * @param {String} indent - indent indent string
 * @returns {String} request headers in the desired format
 */
function parseHeaders (bodyMode, headers, indent) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    headers = _.reject(headers, 'disabled');
    headerSnippet += `${indent}let headers = Header.init ()\n`;
    _.forEach(headers, function (header) {
      headerSnippet += `${indent.repeat(2)}|> fun h -> Header.add h "${sanitize(header.key, 'header', true)}" `;
      headerSnippet += `"${sanitize(header.value, 'header')}"\n`;
    });
  }
  if (bodyMode === 'formdata') {
    if (headerSnippet === '') {
      headerSnippet += `${indent}let headers = Header.init ()\n`;
    }
    headerSnippet += `${indent.repeat(2)}|> fun h -> Header.add h "content-type" "multipart/form-data;`;
    headerSnippet += ' boundary=----WebKitFormBoundary7MA4YWxkTrZu0gW"\n';
  }
  return headerSnippet;
}

/**
 * Gets request method argument to pass for ocaml call function
 *
 * @param {String} method - method type of request
 * @returns {String} Method argument for ocaml call function
 */
function getMethodArg (method) {
  var methodArg = '',
    supportedMethods = ['GET', 'POST', 'PUT', 'PATCH', 'DELETE', 'HEAD'],
    flag = false;

  _.forEach(supportedMethods, (value) => {
    if (value === method) {
      flag = true;
    }
  });

  if (flag) {
    methodArg = '`' + method;
  }
  else {
    methodArg = `(Code.method_of_string "${method}")`;
  }
  return methodArg;
}

self = module.exports = {
  /**
     * Used in order to get options for generation of OCaml code snippet
     *
     * @module getOptions
     *
     * @returns {Array} Options specific to generation of OCaml-Cohttp code snippet
     */
  getOptions: function () {
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        availableOptions: ['Tab', 'Space'],
        default: 'Space',
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      }
    ];
  },

  /**
    * Used to convert the postman sdk-request object in OCaml-Cohttp request snippet
    *
    * @module convert
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout - time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.trimRequestBody - whether to trim request body fields (default: false)
    * @param {Boolean} options.followRedirect - whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    * @returns {String} - returns generated Ocaml snippet via callback
    */
  convert: function (request, options, callback) {

    if (_.isFunction(options)) {
      callback = options;
      options = {};
    }
    else if (!_.isFunction(callback)) {
      throw new Error('OCaml-Cohttp-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());

    var codeSnippet, indent, trim, finalUrl, methodArg, // timeout, followRedirect,
      bodySnippet = '',
      headerSnippet = '',
      requestBody,
      requestBodyMode = (request.body ? request.body.mode : 'raw');

    indent = options.indentType === 'Tab' ? '\t' : ' ';
    indent = indent.repeat(options.indentCount);
    // timeout = options.requestTimeout;
    // followRedirect = options.followRedirect;
    trim = options.trimRequestBody;
    finalUrl = encodeURI(request.url.toString());
    methodArg = getMethodArg(request.method);
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    headerSnippet += parseHeaders(requestBodyMode, request.toJSON().header, indent);

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }

    requestBody = (request.body ? request.body.toJSON() : {});
    bodySnippet = parseBody(requestBody, trim, indent);

    // Starting to add in codeSnippet
    codeSnippet = 'open Lwt\nopen Cohttp\nopen Cohttp_lwt_unix\n\n';
    if (bodySnippet !== '') {
      codeSnippet += bodySnippet;
    }
    codeSnippet += 'let reqBody = \n';
    codeSnippet += `${indent}let uri = Uri.of_string "${finalUrl}" in\n`;
    if (headerSnippet !== '') {
      codeSnippet += headerSnippet;
      codeSnippet += `${indent}in\n`;
    }
    if (bodySnippet !== '') {
      codeSnippet += `${indent}let body = Cohttp_lwt.Body.of_string !postData in\n\n`;
    }
    codeSnippet += `${indent}Client.call `;
    if (headerSnippet !== '') {
      codeSnippet += '~headers ';
    }
    if (bodySnippet !== '') {
      codeSnippet += '~body ';
    }
    codeSnippet += `${methodArg} uri >>= fun (resp, body) ->\n`;
    codeSnippet += `${indent}body |> Cohttp_lwt.Body.to_string >|= fun body -> body\n\n`;
    codeSnippet += 'let () =\n';
    codeSnippet += `${indent}let respBody = Lwt_main.run reqBody in\n`;
    codeSnippet += `${indent}print_endline (respBody)`;
    return callback(null, codeSnippet);
  }
};


/***/ }),

/***/ 4388:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4389),
  parseBody = __webpack_require__(5364),
  sanitize = __webpack_require__(3984).sanitize,
  sanitizeOptions = __webpack_require__(3984).sanitizeOptions,
  addFormParam = __webpack_require__(3984).addFormParam,
  self;

/**
 * Used to parse the request headers
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request headers in the desired format
 */
function getHeaders (request, indentation) {
  var headerArray = request.toJSON().header,
    headerMap;

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerMap = _.map(headerArray, function (header) {
      return `${indentation.repeat(2)}"${sanitize(header.key, 'header', true)}: ` +
            `${sanitize(header.value, 'header')}"`;
    });
    return `${indentation}CURLOPT_HTTPHEADER => array(\n${headerMap.join(',\n')}\n${indentation}),\n`;
  }
  return '';
}

self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @returns {Array}
     */
  getOptions: function () {
    return [{
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }];
  },

  /**
    * Used to convert the postman sdk-request object in php-curl request snippet
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.trimRequestBody : whether to trim request body fields (default: false)
    * @param {Boolean} options.followRedirect : whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var snippet = '',
      indentation = '',
      identity = '',
      finalUrl;

    if (_.isFunction(options)) {
      callback = options;
      options = null;
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Php-Curl~convert: Callback is not a function');
    }
    options = sanitizeOptions(options, self.getOptions());

    identity = options.indentType === 'Tab' ? '\t' : ' ';
    indentation = identity.repeat(options.indentCount);
    // concatenation and making up the final string
    finalUrl = request.url.toString();
    if (finalUrl !== encodeURI(finalUrl)) {
      // needs to be encoded
      finalUrl = encodeURI(finalUrl);
    }
    snippet = '<?php\n\n$curl = curl_init();\n\n';
    snippet += 'curl_setopt_array($curl, array(\n';
    snippet += `${indentation}CURLOPT_URL => "${sanitize(finalUrl, 'url')}",\n`;
    snippet += `${indentation}CURLOPT_RETURNTRANSFER => true,\n`;
    snippet += `${indentation}CURLOPT_ENCODING => "",\n`;
    snippet += `${indentation}CURLOPT_MAXREDIRS => 10,\n`;
    snippet += `${indentation}CURLOPT_TIMEOUT => ${options.requestTimeout},\n`;
    snippet += `${indentation}CURLOPT_FOLLOWLOCATION => ${options.followRedirect},\n`;
    snippet += `${indentation}CURLOPT_HTTP_VERSION => CURL_HTTP_VERSION_1_1,\n`;
    snippet += `${indentation}CURLOPT_CUSTOMREQUEST => "${request.method}",\n`;

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    snippet += `${parseBody(request.toJSON(), options.trimRequestBody, indentation)}`;
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    snippet += `${getHeaders(request, indentation)}`;
    snippet += '));\n\n';
    snippet += '$response = curl_exec($curl);\n\n';
    snippet += 'curl_close($curl);\n';
    snippet += 'echo $response;\n';

    return callback(null, snippet);
  }
};


/***/ }),

/***/ 4389:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4390:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4391:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4392),
  parseBody = __webpack_require__(5370),
  sanitize = __webpack_require__(3986).sanitize,
  sanitizeOptions = __webpack_require__(3986).sanitizeOptions,
  addFormParam = __webpack_require__(3986).addFormParam,
  self;

/**
 * Used to get the headers and put them in the desired form of the language
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request headers in the desired format
 */
function getHeaders (request, indentation) {
  var headerArray = request.toJSON().header,
    headerMap;

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerMap = _.map(headerArray, function (header) {
      return `${indentation}'${sanitize(header.key, true)}' => ` +
            `'${sanitize(header.value)}'`;
    });
    return `$request->setHeaders(array(\n${headerMap.join(',\n')}\n));`;
  }
  return '';
}


self = module.exports = {
  /**
     * @returns {Array} plugin specific options
     */
  getOptions: function () {
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        default: 'Space',
        availableOptions: ['Tab', 'Space'],
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      }
    ];
  },

  /**
     * @param  {Object} request - postman SDK-request object
     * @param  {Object} options
     * @param  {String} options.indentType - type of indentation eg: spaces/Tab (default: Space)
     * @param  {String} options.indentCount - frequency of indent (default: 4 for indentType: Space,
     *                                                               default: 2 for indentType: Tab)
     * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
     * @param {Boolean} options.trimRequestBody : whether to trim request body fields (default: false)
     * @param {Boolean} options.followRedirect : whether to allow redirects of a request
     * @param  {Function} callback - function with parameters (error, snippet)
     */
  convert: function (request, options, callback) {
    var snippet = '',
      indentation = '',
      identity = '';

    if (_.isFunction(options)) {
      callback = options;
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Php-Pecl(HTTP)~convert: Callback is not a function');
    }
    options = sanitizeOptions(options, self.getOptions());

    identity = options.indentType === 'Tab' ? '\t' : ' ';
    indentation = identity.repeat(options.indentCount);

    snippet = '<?php\n';
    snippet += '$client = new http\\Client;\n';
    snippet += '$request = new http\\Client\\Request;\n';
    snippet += `$request->setRequestUrl('${sanitize(request.url.toString())}');\n`;
    snippet += `$request->setRequestMethod('${request.method}');\n`;
    if (!_.isEmpty(request.body)) {

      // The following code handles multiple files in the same formdata param.
      // It removes the form data params where the src property is an array of filepath strings
      // Splits that array into different form data params with src set as a single filepath string
      if (request.body.mode === 'formdata') {
        let formdata = request.body.formdata,
          formdataArray = [];
        formdata.members.forEach((param) => {
          let key = param.key,
            type = param.type,
            disabled = param.disabled,
            contentType = param.contentType;
            // check if type is file or text
          if (type === 'file') {
            // if src is not of type string we check for array(multiple files)
            if (typeof param.src !== 'string') {
              // if src is an array(not empty), iterate over it and add files as separate form fields
              if (Array.isArray(param.src) && param.src.length) {
                param.src.forEach((filePath) => {
                  addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
                });
              }
              // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
              else {
                addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
              }
            }
            // if src is string, directly add the param with src as filepath
            else {
              addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
            }
          }
          // if type is text, directly add it to formdata array
          else {
            addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
          }
        });
        request.body.update({
          mode: 'formdata',
          formdata: formdataArray
        });
      }
      snippet += '$body = new http\\Message\\Body;\n';
      snippet += `${parseBody(request.toJSON(), indentation, options.trimRequestBody)}`;
      snippet += '$request->setBody($body);\n';
    }
    snippet += '$request->setOptions(array(';
    snippet += options.requestTimeout === 0 ? '' : `'connecttimeout' => ${options.requestTimeout}`;
    snippet += options.followRedirect ? '' : ', \'redirect\' => false';
    snippet += '));\n';
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    snippet += `${getHeaders(request, indentation)}\n`;
    snippet += '$client->enqueue($request)->send();\n';
    snippet += '$response = $client->getResponse();\n';
    snippet += 'echo $response->getBody();\n';

    return callback(null, snippet);
  }
};


/***/ }),

/***/ 4392:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4393:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4394),
  sanitize = __webpack_require__(3987).sanitize,
  sanitizeOptions = __webpack_require__(3987).sanitizeOptions,
  addFormParam = __webpack_require__(3987).addFormParam,
  parseBody = __webpack_require__(5376),
  self;

/**
 * Used to parse the request headers
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request headers in the desired format
 */
function getheaders (request, indentation) {
  var headerArray = request.toJSON().header,
    requestBodyMode = (request.body ? request.body.mode : 'raw'),
    headerMap;

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerMap = _.map(headerArray, function (header) {
      return `${indentation}'${sanitize(header.key, 'header', true)}': ` +
            `'${sanitize(header.value, 'header')}'`;
    });
    if (requestBodyMode === 'formdata') {
      headerMap.push(`${indentation}'Content-type': 'multipart/form-data; boundary={}'.format(boundary)`);
    }
    return `headers = {\n${headerMap.join(',\n')}\n}\n`;
  }
  if (requestBodyMode === 'formdata') {
    return `headers = {\n${indentation} 'Content-type': ` +
             '\'multipart/form-data; boundary={}\'.format(boundary) \n}\n';
  }
  return 'headers = {}\n';
}

/**
 * Generates URL's path with query string
 *
 * @param {Object} requestUrl - Postman Sdk Request's Url object
 * @returns {String} - Url path with query (no host)
 */
function getUrlPathWithQuery (requestUrl) {
  var path = requestUrl.getPath(),
    query = requestUrl.getQueryString({ ignoreDisabled: true }),
    urlPathWithQuery = '';

  urlPathWithQuery += (path === '/' ? '' : path);
  if (query !== '') {
    urlPathWithQuery += '?' + sanitize(query);
  }
  return urlPathWithQuery;
}

self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @module getOptions
     *
     * @returns {Array}
     */
  getOptions: function () {
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        default: 'Space',
        availableOptions: ['Tab', 'Space'],
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      }
    ];
  },

  /**
    * Used to convert the postman sdk-request object in python-httpclient reuqest snippet
    *
    * @module convert
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options - Options to tweak code snippet generated in Python
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.requestBodyTrim : whether to trim request body fields (default: false)
    * @param {Boolean} options.followRedirect : whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var snippet = '',
      indentation = '',
      identity = '';

    if (_.isFunction(options)) {
      callback = options;
      options = {};
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Python-Http.Client~convert: Callback is not a function');
    }
    options = sanitizeOptions(options, self.getOptions());

    identity = options.indentType === 'Tab' ? '\t' : ' ';
    indentation = identity.repeat(options.indentCount);

    snippet += 'import http.client\n';
    snippet += 'import mimetypes\n';
    snippet += `conn = http.client.HTTPSConnection("${request.url.host ? request.url.host.join('.') : ''}"`;
    snippet += request.url.port ? `, ${request.url.port}` : '';
    snippet += options.requestTimeout !== 0 ? `, timeout = ${options.requestTimeout})\n` : ')\n';

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    snippet += parseBody(request.toJSON(), indentation, options.requestBodyTrim);
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    snippet += getheaders(request, indentation);
    snippet += `conn.request("${request.method}", "${getUrlPathWithQuery(request.url)}", payload, headers)\n`;
    snippet += 'res = conn.getresponse()\n';
    snippet += 'data = res.read()\n';
    snippet += 'print(data.decode("utf-8"))';

    return callback(null, snippet);
  }
};


/***/ }),

/***/ 4394:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4395:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4396),
  parseBody = __webpack_require__(5379),
  sanitize = __webpack_require__(3988).sanitize,
  sanitizeOptions = __webpack_require__(3988).sanitizeOptions,
  addFormParam = __webpack_require__(3988).addFormParam,
  self;

/**
 * Used to parse the request headers
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request headers in the desired format
 */
function getheaders (request, indentation) {
  var headerArray = request.toJSON().header,
    headerMap;

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerMap = _.map(headerArray, function (header) {
      return `${indentation}'${sanitize(header.key, 'header', true)}': ` +
            `'${sanitize(header.value, 'header')}'`;
    });
    return `headers = {\n${headerMap.join(',\n')}\n}\n`;
  }
  return 'headers= {}\n';
}

self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @returns {Array}
     */
  getOptions: function () {
    return [{
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }];
  },

  /**
    * Used to convert the postman sdk-request object to python request snippet
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.trimRequestBody : whether to trim request body fields (default: false)
    * @param {Boolean} options.followRedirect : whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var snippet = '',
      indentation = '',
      identity = '';

    if (_.isFunction(options)) {
      callback = options;
      options = null;
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Python-Requests~convert: Callback is not a function');
    }
    options = sanitizeOptions(options, self.getOptions());

    identity = options.indentType === 'Tab' ? '\t' : ' ';
    indentation = identity.repeat(options.indentCount);
    snippet += 'import requests\n\n';
    snippet += `url = "${sanitize(request.url.toString(), 'url')}"\n\n`;

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    snippet += `${parseBody(request.toJSON(), indentation, options.trimRequestBody)}`;
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    snippet += `${getheaders(request, indentation)}\n`;
    snippet += `response = requests.request("${request.method}", url, headers=headers`;

    snippet += request.body && request.body.mode && request.body.mode === 'formdata' ?
      ', data = payload, files = files' : ', data = payload';
    snippet += !options.followRedirect ? ', allow_redirects = False' : '';
    snippet += options.requestTimeout !== 0 ? `, timeout=${options.requestTimeout}` : '';
    snippet += ')\n\n';
    snippet += 'print(response.text.encode(\'utf8\'))\n';

    callback(null, snippet);
  }
};


/***/ }),

/***/ 4396:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4397:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4398),
  parseBody = __webpack_require__(5382),
  sanitize = __webpack_require__(3989).sanitize,
  sanitizeOptions = __webpack_require__(3989).sanitizeOptions,
  addFormParam = __webpack_require__(3989).addFormParam,
  self;

/**
 * Used to parse the request headers
 *
 * @param  {Object} headers - postman SDK-request object
 * @returns {String} - request headers in the desired format
 */
function parseHeaders (headers) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    _.forEach(headers, function (value, key) {
      if (Array.isArray(value)) {
        var headerValues = [];
        _.forEach(value, (singleValue) => {
          headerValues.push(`"${sanitize(singleValue, 'header')}"`);
        });
        headerSnippet += `request["${sanitize(key, 'header', true)}"] = [${headerValues.join(', ')}]\n`;
      }
      else {
        headerSnippet += `request["${sanitize(key, 'header', true)}"] = "${sanitize(value, 'header')}"\n`;
      }
    });
  }
  return headerSnippet;
}

self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @returns {Array}
     */
  getOptions: function () {
    return [{
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }];
  },

  /**
    * Used to convert the postman sdk-request object in ruby request snippet
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.trimRequestBody : whether to trim request body fields (default: false)
    * @param {Boolean} options.followRedirect : whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var snippet = '',
      indentation = '',
      identity = '',
      headerSnippet = '',
      methods = ['GET', 'POST', 'HEAD', 'DELETE', 'PATCH', 'PROPFIND',
        'PROPPATCH', 'PUT', 'OPTIONS', 'COPY', 'LOCK', 'UNLOCK', 'MOVE', 'TRACE'];

    if (_.isFunction(options)) {
      callback = options;
      options = null;
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Ruby~convert: Callback is not a function');
    }
    options = sanitizeOptions(options, self.getOptions());

    identity = options.indentType === 'Tab' ? '\t' : ' ';
    indentation = identity.repeat(options.indentCount);
    // concatenation and making up the final string
    snippet = 'require "uri"\n';
    snippet += 'require "net/http"\n\n';
    if (!_.includes(methods, request.method)) {
      snippet += `class Net::HTTP::${_.capitalize(request.method)} < Net::HTTPRequest\n`;
      snippet += `${indentation}METHOD = "${request.method}"\n`;
      snippet += `${indentation}REQUEST_HAS_BODY = ${!_.isEmpty(request.body)}\n`;
      snippet += `${indentation}RESPONSE_HAS_BODY = true\n`;
      snippet += 'end\n\n';
    }
    snippet += `url = URI("${sanitize(request.url.toString(), 'url')}")\n\n`;
    if (sanitize(request.url.toString(), 'url').startsWith('https')) {
      snippet += 'https = Net::HTTP.new(url.host, url.port);\n';
      snippet += 'https.use_ssl = true\n\n';
      if (options.requestTimeout) {
        snippet += `https.read_timeout = ${Math.ceil(options.requestTimeout / 1000)}\n`;
      }
      snippet += `request = Net::HTTP::${_.capitalize(request.method)}.new(url)\n`;
      headerSnippet = parseHeaders(request.getHeaders({enabled: true}));
      if (headerSnippet !== '') {
        snippet += headerSnippet;
      }

      // The following code handles multiple files in the same formdata param.
      // It removes the form data params where the src property is an array of filepath strings
      // Splits that array into different form data params with src set as a single filepath string
      if (request.body && request.body.mode === 'formdata') {
        let formdata = request.body.formdata,
          formdataArray = [];
        formdata.members.forEach((param) => {
          let key = param.key,
            type = param.type,
            disabled = param.disabled,
            contentType = param.contentType;
            // check if type is file or text
          if (type === 'file') {
            // if src is not of type string we check for array(multiple files)
            if (typeof param.src !== 'string') {
              // if src is an array(not empty), iterate over it and add files as separate form fields
              if (Array.isArray(param.src) && param.src.length) {
                param.src.forEach((filePath) => {
                  addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
                });
              }
              // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
              else {
                addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
              }
            }
            // if src is string, directly add the param with src as filepath
            else {
              addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
            }
          }
          // if type is text, directly add it to formdata array
          else {
            addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
          }
        });
        request.body.update({
          mode: 'formdata',
          formdata: formdataArray
        });
      }
      snippet += `${parseBody(request.toJSON(), options.trimRequestBody)}\n`;
      snippet += 'response = https.request(request)\n';
      snippet += 'puts response.read_body\n';
    }
    else {
      snippet += 'http = Net::HTTP.new(url.host, url.port);\n';
      if (options.requestTimeout) {
        snippet += `http.read_timeout = ${Math.ceil(options.requestTimeout / 1000)}\n`;
      }
      snippet += `request = Net::HTTP::${_.capitalize(request.method)}.new(url)\n`;
      if (request.body && !request.headers.has('Content-Type')) {
        if (request.body.mode === 'file') {
          request.addHeader({
            key: 'Content-Type',
            value: 'text/plain'
          });
        }
        else if (request.body.mode === 'graphql') {
          request.addHeader({
            key: 'Content-Type',
            value: 'application/json'
          });
        }
      }
      headerSnippet = parseHeaders(request.getHeaders({enabled: true}));

      if (headerSnippet !== '') {
        snippet += headerSnippet;
      }
      snippet += `${parseBody(request.toJSON(), options.trimRequestBody)}\n`;
      snippet += 'response = http.request(request)\n';
      snippet += 'puts response.read_body\n';
    }

    return callback(null, snippet);
  }
};


/***/ }),

/***/ 4398:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.indexOf(value) !== -1; // eslint-disable-line lodash/prefer-includes
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4399:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4400),
  Helpers = __webpack_require__(5385),
  sanitizeOptions = __webpack_require__(4104).sanitizeOptions,
  addFormParam = __webpack_require__(4104).addFormParam,
  self;

const GAP = ' ',
  URLENCODED = 'urlencoded',
  FORM_DATA = 'formdata',
  RAW = 'raw',
  GRAPHQL = 'graphql',
  FILE = 'file';

self = module.exports = {
  /**
   * Used to return options which are specific to a particular plugin
   *
   * @returns {Array}
   */
  getOptions: function () {
    return [
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      }
    ];
  },

  /**
    * Used to convert the postman sdk-request object in shell-httpie reuqest snippet
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.followRedirect : whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var snippet = '',
      parsedBody,
      parsedHeaders,
      bodyMode,
      timeout,
      url = '',
      handleRedirect = (enableRedirect) => { if (enableRedirect) { return GAP + '--follow' + GAP; } return GAP; },
      handleRequestTimeout = (time) => {
        if (time) {
          return '--timeout ' + (time / 1000) + GAP;
        }
        return '--timeout 3600' + GAP;
      };

    // check whether options was passed or not
    if (_.isFunction(options)) {
      callback = options;
      options = null;
    }
    else if (!_.isFunction(callback)) { // check whether callback is a function
      throw new Error('Shell-Httpie~convert: Callback not a function');
    }

    options = sanitizeOptions(options, self.getOptions());

    Helpers.parseURLVariable(request);
    url = Helpers.addHost(request) + Helpers.addPort(request) + Helpers.addPathandQuery(request);
    timeout = options.requestTimeout;
    if (request.body && request.body.mode === 'graphql' && !request.headers.has('Content-Type')) {
      request.addHeader({
        key: 'Content-Type',
        value: 'application/json'
      });
    }
    parsedHeaders = Helpers.addHeaders(request);

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    // snippet construction based on the request body
    if (request.hasOwnProperty('body')) {
      if (request.body.hasOwnProperty('mode')) {
        bodyMode = request.body.mode;
        parsedBody = Helpers.getRequestBody(request.body[bodyMode], bodyMode);
        // handling every type of content-disposition
        switch (bodyMode) {
          case URLENCODED:
            snippet += 'http --ignore-stdin --form' + handleRedirect(options.followRedirect);
            snippet += handleRequestTimeout(timeout);
            snippet += request.method + GAP + url + ' \\\n';
            snippet += parsedBody + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
            break;

          case FORM_DATA:
            snippet += 'http --ignore-stdin --form' + handleRedirect(options.followRedirect);
            snippet += handleRequestTimeout(timeout);
            snippet += request.method + GAP + url + ' \\\n';
            snippet += parsedBody + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
            break;

          case RAW:
            if (parsedBody) {
              snippet += 'printf ' + parsedBody + '| ';
            }
            snippet += 'http ' + handleRedirect(options.followRedirect) + handleRequestTimeout(timeout);
            snippet += request.method + GAP + url + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
            break;
          case GRAPHQL:
            if (parsedBody) {
              snippet += 'printf ' + parsedBody + '| ';
            }
            snippet += 'http ' + handleRedirect(options.followRedirect) + handleRequestTimeout(timeout);
            snippet += request.method + GAP + url + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
            break;
          case FILE:
            snippet += `cat ${parsedBody} | `;
            snippet += 'http ' + handleRedirect(options.followRedirect) + handleRequestTimeout(timeout);
            snippet += request.method + GAP + url + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
            break;
          default:
            return callback('Shell-Httpie~convert: Not a valid Content-Type in request body', null);
        }
      }
      else {
        snippet += 'http' + handleRedirect(options.followRedirect) + handleRequestTimeout(timeout);
        snippet += request.method + GAP + url + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
      }
    }
    else { // forming a request without a body
      snippet += 'http' + handleRedirect(options.followRedirect) + handleRequestTimeout(timeout);
      snippet += request.method + GAP + url + (parsedHeaders ? (' \\\n' + parsedHeaders) : '');
    }

    callback(null, snippet);
  }
};



/***/ }),

/***/ 4400:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4401:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4402),
  parseBody = __webpack_require__(5388),
  sanitize = __webpack_require__(4105).sanitize,
  sanitizeOptions = __webpack_require__(4105).sanitizeOptions,
  self;

/**
 * Used to parse the request headers
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request headers in the desired format
 */
function getHeaders (request, indentation) {
  var headerArray = request.toJSON().header,
    headerMap;

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerMap = _.map(headerArray, function (header) {
      return `${indentation}--header '${sanitize(header.key, 'header', true)}: ` +
            `${sanitize(header.value, 'header')}' \\`;
    });
    return headerMap.join('\n');
  }
  return `${indentation}--header '' \\`;
}

self = module.exports = {
  /**
     * Used to return options which are specific to a particular plugin
     *
     * @module getOptions
     *
     * @returns {Array}
     */
  getOptions: function () {
    // options can be added for this for no certificate check and silent so no output is logged.
    // Also, place where to log the output if required.
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        availableOptions: ['Tab', 'Space'],
        default: 'Space',
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      }
    ];
  },

  /**
    * Used to convert the postman sdk-request object in php-curl reuqest snippet
    *
    * @module convert
    *
    * @param  {Object} request - postman SDK-request object
    * @param  {Object} options
    * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
    * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                    default: 1 for indentType: Tab)
    * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
                                                (default: 0 -> never bail out)
    * @param {Boolean} options.trimRequestBody : whether to trim request body fields (default: false)
    * @param {Boolean} options.followRedirect : whether to allow redirects of a request
    * @param  {Function} callback - function with parameters (error, snippet)
    */
  convert: function (request, options, callback) {
    var snippet = '',
      indentation = '',
      identity = '',
      isFormDataFile = false;

    if (_.isFunction(options)) {
      callback = options;
      options = {};
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Shell-wget~convert: Callback is not a function');
    }

    options = sanitizeOptions(options, self.getOptions());

    identity = options.indentType === 'Tab' ? '\t' : ' ';
    indentation = identity.repeat(options.indentCount);
    // concatenation and making up the final string

    if (request.body && request.body.mode === 'formdata') {
      _.forEach(request.body.toJSON().formdata, (data) => {
        if (!data.disabled && data.type === 'file') {
          isFormDataFile = true;
        }
      });
    }
    if (isFormDataFile) {
      snippet = '# wget doesn\'t support file upload via form data, use curl -F \\\n';
    }
    snippet += 'wget --no-check-certificate --quiet \\\n';
    snippet += `${indentation}--method ${request.method} \\\n`;
    // console.log(getHeaders(request, indentation));
    // Shell-wget accepts timeout in seconds (conversion from milli-seconds to seconds)
    if (options.requestTimeout > 0) {
      snippet += `${indentation}--timeout=${Math.floor(options.requestTimeout / 1000)} \\\n`;
    }
    else {
      snippet += `${indentation}--timeout=0 \\\n`;
    }
    // Shell-wget supports 20 redirects by default (without any specific options)
    if (typeof options.followRedirect === 'boolean' && !options.followRedirect) {
      snippet += `${indentation}--max-redirect=0 \\\n`;
    }
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    snippet += `${getHeaders(request, indentation)}\n`;
    snippet += `${parseBody(request.toJSON(), options.trimRequestBody, indentation)}`;
    snippet += `${indentation} '${sanitize(request.url.toString(), 'url')}'`;

    return callback(null, snippet);
  }
};


/***/ }),

/***/ 4402:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 4403:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5391),
  sanitize = __webpack_require__(3990).sanitize,
  sanitizeOptions = __webpack_require__(3990).sanitizeOptions,
  getUrlStringfromUrlObject = __webpack_require__(3990).getUrlStringfromUrlObject,
  addFormParam = __webpack_require__(3990).addFormParam,
  self;

/**
 * Parses Raw data from request to fetch syntax
 *
 * @param {Object} body - Raw body data
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @returns {String} request body in the desired format
 */
function parseRawBody (body, mode, trim) {
  var bodySnippet;
  bodySnippet = `let parameters = ${sanitize(body, mode, trim)}\n`;
  bodySnippet += 'let postData = parameters.data(using: .utf8)';
  return bodySnippet;
}

/**
 * Parses graphql data from request to fetch syntax
 *
 * @param {Object} body - grqphql body data
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @returns {String} request body in the desired format
 */
function parseGraphQL (body, mode, trim) {
  let query = body.query,
    graphqlVariables, bodySnippet;
  try {
    graphqlVariables = JSON.parse(body.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  bodySnippet = `let parameters = ${sanitize(JSON.stringify({
    query: query,
    variables: graphqlVariables
  }), mode, trim)}\n`;
  bodySnippet += 'let postData = parameters.data(using: .utf8)';
  return bodySnippet;
}

/**
 * Parses URLEncoded body from request to fetch syntax
 *
 * @param {Object} body - URLEncoded Body
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @returns {String} request body in the desired format
 */
function parseURLEncodedBody (body, mode, trim) {
  var payload, bodySnippet;
  payload = _.reduce(body, function (accumulator, data) {
    if (!data.disabled) {
      accumulator.push(`${sanitize(data.key, mode, trim)}=${sanitize(data.value, mode, trim)}`);
    }
    return accumulator;
  }, []).join('&');

  bodySnippet = `let parameters = "${payload}"\n`;
  bodySnippet += 'let postData =  parameters.data(using: .utf8)';
  return bodySnippet;
}

/**
 * Parses formData body from request to fetch syntax
 *
 * @param {Object} body - formData Body
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @param {boolean} trim - trim body option
 * @param {String} indent - indentation string
 * @returns {String} request body in the desired format
 */
function parseFormData (body, mode, trim, indent) {
  var parameters = [],
    parameter,
    bodySnippet;
  _.forEach(body, (data) => {
    if (!(data.disabled)) {
      parameter = '';
      parameter += `${indent}[\n${indent.repeat(2)}"key": "${sanitize(data.key, mode, trim)}",\n`;
      if (data.type === 'file') {
        parameter += `${indent.repeat(2)}"src": "${sanitize(data.src, mode, trim)}",\n`;
        parameter += `${indent.repeat(2)}"type": "file"\n${indent}]`;
      }
      else {
        parameter += `${indent.repeat(2)}"value": "${sanitize(data.value, mode, trim)}",\n`;
        parameter += `${indent.repeat(2)}"type": "text"\n${indent}]`;
      }
      parameters.push(parameter);
    }
  });
  parameters = '[\n' + _.join(parameters, ',\n') + ']';
  bodySnippet = `let parameters = ${parameters} as [[String : Any]]\n\n`;
  bodySnippet += 'let boundary = "Boundary-\\(UUID().uuidString)"\n';
  bodySnippet += 'var body = ""\nvar error: Error? = nil\n';
  bodySnippet += 'for param in parameters {\n';
  bodySnippet += `${indent}if param["disabled"] == nil {\n`;
  bodySnippet += `${indent.repeat(2)}let paramName = param["key"]!\n`;
  bodySnippet += `${indent.repeat(2)}body += "--\\(boundary)\\r\\n"\n`;
  // eslint-disable-next-line no-useless-escape
  bodySnippet += `${indent.repeat(2)}body += "Content-Disposition:form-data; name=\\"\\(paramName)\\"\"\n`;
  bodySnippet += `${indent.repeat(2)}let paramType = param["type"] as! String\n`;
  bodySnippet += `${indent.repeat(2)}if paramType == "text" {\n`;
  bodySnippet += `${indent.repeat(3)}let paramValue = param["value"] as! String\n`;
  bodySnippet += `${indent.repeat(3)}body += "\\r\\n\\r\\n\\(paramValue)\\r\\n"\n`;
  bodySnippet += `${indent.repeat(2)}} else {\n`;
  bodySnippet += `${indent.repeat(3)}let paramSrc = param["src"] as! String\n`;
  bodySnippet += `${indent.repeat(3)}let fileData = try NSData(contentsOfFile:paramSrc, options:[]) as Data\n`;
  bodySnippet += `${indent.repeat(3)}let fileContent = String(data: fileData, encoding: .utf8)!\n`;
  bodySnippet += `${indent.repeat(3)}body += "; filename=\\"\\(paramSrc)\\"\\r\\n"\n`;
  bodySnippet += `${indent.repeat(3)}  + "Content-Type: \\"content-type header\\"\\r\\n\\r\\n`;
  bodySnippet += '\\(fileContent)\\r\\n"\n';
  bodySnippet += `${indent.repeat(2)}}\n${indent}}\n}\nbody += "--\\(boundary)--\\r\\n";\n`;
  bodySnippet += 'let postData = body.data(using: .utf8)';
  return bodySnippet;
}

/* istanbul ignore next */
/**
 * Parses file body from the Request
 *
 * @returns {String} request body in the desired format
 */
function parseFile () {
  // var bodySnippet = 'let filename = "{Insert_File_Name}", postData = Data()\n';
  // bodySnippet += 'if let path = Bundle.main.path(forResource: filename, ofType: nil) {\n';
  // bodySnippet += `${indent}do {\n${indent.repeat(2)}postData =
  // try NSData(contentsOfFile:path, options:[]) as Data\n`;
  // bodySnippet += `${indent}} catch {\n`;
  // bodySnippet += `${indent.repeat(2)}print("Failed to read from \\(String(describing: filename))")\n`;
  // bodySnippet += `${indent}}\n} else {\n`;
  // bodySnippet += `${indent}print("Failed to load file from app bundle \\(String(describing: filename))")\n}\n`;
  var bodySnippet = 'let parameters = "<file contents here>"\n';
  bodySnippet += 'let postData = parameters.data(using: .utf8)';
  return bodySnippet;
}

/**
 * Parses Body from the Request using
 *
 * @param {Object} body - body object from request.
 * @param {boolean} trim - trim body option
 * @param {String} indent - indentation string
 * @returns {String} utility function for getting request body in the desired format
 */
function parseBody (body, trim, indent) {
  if (!_.isEmpty(body) && !_.isEmpty(body[body.mode])) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded, body.mode, trim);
      case 'raw':
        return parseRawBody(body.raw, body.mode, trim);
      case 'graphql':
        return parseGraphQL(body.graphql, 'raw', trim);
      case 'formdata':
        return parseFormData(body.formdata, body.mode, trim, indent);
        /* istanbul ignore next */
      case 'file':
        return parseFile(indent);
      default:
        return '';
    }
  }
  return '';
}

/**
 * Parses headers from the request.
 *
 * @param {Object} headers - headers from the request.
 * @param {String} mode - Request body type (i.e. raw, urlencoded, formdata, file)
 * @returns {String} request headers in the desired format
 */
function parseHeaders (headers, mode) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    headers = _.reject(headers, 'disabled');
    _.forEach(headers, function (header) {
      headerSnippet += `request.addValue("${sanitize(header.value, 'header')}", `;
      headerSnippet += `forHTTPHeaderField: "${sanitize(header.key, 'header', true)}")\n`;
    });
  }
  if (mode === 'formdata') {
    headerSnippet += 'request.addValue("multipart/form-data; ';
    headerSnippet += 'boundary=\\(boundary)", forHTTPHeaderField: "Content-Type")\n';
  }
  return headerSnippet;
}

self = module.exports = {
  /**
     * Used in order to get additional options for generation of Swift code snippet
     *
     * @module getOptions
     *
     * @returns {Array} Additional options specific to generation of Swift-URLSession code snippet
     */
  getOptions: function () {
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        availableOptions: ['Tab', 'Space'],
        default: 'Space',
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      }
    ];
  },

  /**
     * Converts Postman sdk request object to Swift-URLSession code snippet
     *
     * @module convert
     *
     * @param  {Object} request - Postman SDK-request object
     * @param  {Object} options - Options to tweak code snippet generated in Swift
     * @param  {String} options.indentType - type of indentation eg: Space / Tab (default: Space)
     * @param  {Number} options.indentCount - frequency of indent (default: 4 for indentType: Space,
                                                                     default: 1 for indentType: Tab)
     * @param {Number} options.requestTimeout - time in milli-seconds after which request will bail out
                                                 (default: 0 -> never bail out)
     * @param {Boolean} options.trimRequestBody - whether to trim request body fields (default: false)
     * @param {Boolean} options.followRedirect - whether to allow redirects of a request
     * @param  {Function} callback - Callback function with parameters (error, snippet)
     * @returns {String} Generated swift snippet via callback
     */
  convert: function (request, options, callback) {

    if (_.isFunction(options)) {
      callback = options;
      options = {};
    }
    else if (!_.isFunction(callback)) {
      throw new Error('Swift-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());
    var codeSnippet, indent, trim, timeout, finalUrl, // followRedirect,
      bodySnippet = '',
      headerSnippet = '',
      requestBody;

    indent = options.indentType === 'Tab' ? '\t' : ' ';
    indent = indent.repeat(options.indentCount);
    timeout = options.requestTimeout;
    // followRedirect = options.followRedirect;
    trim = options.trimRequestBody;
    finalUrl = getUrlStringfromUrlObject(request.url);

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    requestBody = (request.body ? request.body.toJSON() : {});
    bodySnippet = parseBody(requestBody, trim, indent);

    codeSnippet = 'import Foundation\n\n';
    codeSnippet += 'var semaphore = DispatchSemaphore (value: 0)\n\n';
    if (bodySnippet !== '') {
      codeSnippet += `${bodySnippet}\n\n`;
    }
    codeSnippet += `var request = URLRequest(url: URL(string: "${finalUrl}")!,` +
         `timeoutInterval: ${timeout ? timeout : 'Double.infinity'})\n`;
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    headerSnippet = parseHeaders(request.toJSON().header, (request.body ? request.body.mode : 'raw'));
    if (headerSnippet !== '') {
      codeSnippet += headerSnippet + '\n';
    }
    codeSnippet += `request.httpMethod = "${request.method}"\n`;
    if (bodySnippet !== '') {
      codeSnippet += 'request.httpBody = postData\n';
    }
    codeSnippet += '\nlet task = URLSession.shared.dataTask(with: request) { data, response, error in \n';
    codeSnippet += `${indent}guard let data = data else {\n`;
    codeSnippet += `${indent.repeat(2)}print(String(describing: error))\n`;
    codeSnippet += `${indent.repeat(2)}return\n`;
    codeSnippet += `${indent}}\n`;
    codeSnippet += `${indent}print(String(data: data, encoding: .utf8)!)\n`;
    codeSnippet += `${indent}semaphore.signal()\n}\n\n`;
    codeSnippet += 'task.resume()\n';
    codeSnippet += 'semaphore.wait()\n';

    return callback(null, codeSnippet);
  }
};


/***/ }),

/***/ 5281:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5282);


/***/ }),

/***/ 5282:
/***/ (function(module, exports, __webpack_require__) {

var sdk = __webpack_require__(5283),
  labelList = __webpack_require__(5314),
  languageMap = __webpack_require__(5315);

module.exports = {
  /**
   * Gets the options specific to a given language.
   *
   * @param {Object} language - language key provided by getLanguageList function
   * @param {Array} variant - variant key provided by getLanguageList function
   * @param {Function} callback - callback function with arguments (error, object)
   */
  getOptions (language, variant, callback) {
    var validCodegen = languageMap.filter((codegen) => {
      var lang = codegen.lang.trim(),
        currentVariant = codegen.variant.trim();
      return language === lang.toLowerCase() && variant.toLowerCase() === currentVariant.toLowerCase();
    });

    validCodegen.forEach((codegen) => {
      main = codegen.main;
      if (typeof main.getOptions !== 'function') {
        return callback('Codegen~getOptions: getOptions is not a function');
      }
      if (!main.getOptions) {
        return callback('Codegen~convert: Could not find condegen corresponding to provided language, variant pair');
      }

      return callback(null, main.getOptions());
    });
  },

  /**
   * Returns an object of supported languages
   *
   */
  getLanguageList () {
    var langMap = {},
      supportedLanguages = [];
    languageMap.forEach((codegen) => {
      var lang = codegen.lang.trim(),
        syntax_mode = codegen.syntax_mode.trim(),
        variant = codegen.variant.trim();
      lang = lang.toLowerCase();
      if (!langMap[lang]) {
        langMap[lang] = {
          key: lang,
          label: labelList[lang] ? labelList[lang] : lang,
          syntax_mode: syntax_mode.toLowerCase(),
          variants: [
            {
              key: variant
            }
          ]
        };
      }
      else {
        langMap[lang].variants.push({
          key: variant
        });
      }
    });

    supportedLanguages = Object.keys(langMap).map(function (lang) {
      return langMap[lang];
    });

    return supportedLanguages;
  },

  /**
   * Converts a request to a preferred language snippet
   *
   * @param {Object} language - language key provided by getLanguageList function
   * @param {Array} variant - variant key provided by getLanguageList function
   * @param {String} request -  valid postman request
   * @param {Object} [options] - contains convert level options
   * @param {Number} [options.indentType] - indentation based on Tab or spaces
   * @param {Number} [options.indentCount] - count/frequency of indentType
   * @param {Number} [options.requestTimeout] : time in milli-seconds after which request will bail out
   * @param {Boolean} [options.trimRequestBody] : whether to trim request body fields
   * @param {Boolean} [options.addCacheHeader] : whether to add cache-control header to postman SDK-request
   * @param {Boolean} [options.followRedirect] : whether to allow redirects of a request
   * @param {Function} callback - callback function with arguments (error, string)
   */
  convert (language, variant, request, options, callback) {
    var convert, main;

    if (!sdk.Request.isRequest(request)) {
      return callback('Codegen~convert: Invalid request');
    }

    languageMap.forEach((codegen) => {
      var lang = codegen.lang.trim(),
        currentVariant = codegen.variant.trim();
      if (language.toLowerCase() === lang.toLowerCase() && variant.toLowerCase() === currentVariant.toLowerCase()) {
        main = codegen.main;
        convert = main.convert;

        if (typeof convert !== 'function') {
          return callback('Codegen~convert: Convert is not a function');
        }
      }
    });
    if (!convert) {
      return callback('Codegen~convert: Could not find condegen corresponding to provided language, variant pair');
    }


    convert(request, options, function (err, snippet) {
      if (err) {
        return callback(err);
      }

      return callback(null, snippet);
    });
  }
};


/***/ }),

/***/ 5283:
/***/ (function(module, exports, __webpack_require__) {

/**!
 * @license http://www.apache.org/licenses/LICENSE-2.0
 *
 * Copyright 2015 Postdot Technologies Pvt. Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and limitations under the License.
 */
/**
 * @fileOverview This is the entry point to PostmanCollection modules. The structure of the module is defined here.
 */
module.exports = __webpack_require__(5284);



/***/ }),

/***/ 5284:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
    PropertyBase: __webpack_require__(3813).PropertyBase,
    Certificate: __webpack_require__(4087).Certificate,
    CertificateList: __webpack_require__(5308).CertificateList,
    Collection: __webpack_require__(5309).Collection,
    Cookie: __webpack_require__(4370).Cookie,
    CookieList: __webpack_require__(4369).CookieList,
    Description: __webpack_require__(4359).Description,
    Event: __webpack_require__(4363).Event,
    EventList: __webpack_require__(4090).EventList,
    FormParam: __webpack_require__(4367).FormParam,
    Header: __webpack_require__(4093).Header,
    HeaderList: __webpack_require__(4092).HeaderList,
    Item: __webpack_require__(4365).Item,
    ItemGroup: __webpack_require__(4362).ItemGroup,
    MutationTracker: __webpack_require__(4372).MutationTracker,
    PropertyList: __webpack_require__(3798).PropertyList,
    Property: __webpack_require__(3787).Property,
    QueryParam: __webpack_require__(4088).QueryParam,
    Request: __webpack_require__(3978).Request,
    RequestAuth: __webpack_require__(3979).RequestAuth,
    RequestBody: __webpack_require__(4366).RequestBody,
    Response: __webpack_require__(4368).Response,
    Script: __webpack_require__(4364).Script,
    Url: __webpack_require__(3837).Url,
    UrlMatchPattern: __webpack_require__(4089).UrlMatchPattern,
    UrlMatchPatternList: __webpack_require__(4361).UrlMatchPatternList,
    Variable: __webpack_require__(4360).Variable,
    VariableList: __webpack_require__(3921).VariableList,
    VariableScope: __webpack_require__(5312).VariableScope,
    ProxyConfig: __webpack_require__(4091).ProxyConfig,
    ProxyConfigList: __webpack_require__(5313).ProxyConfigList,
    Version: __webpack_require__(4371).Version
};


/***/ }),

/***/ 5285:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, module) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.15';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading and trailing whitespace. */
  var reTrim = /^\s+|\s+$/g,
      reTrimStart = /^\s+/,
      reTrimEnd = /\s+$/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      var index = -1;
      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      value = iteratee(value);

      var low = 0,
          high = array == null ? 0 : array.length,
          valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(array);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked && stack.get(other)) {
        return stacked == other;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, '');
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('dj vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // with lookup (in case of e.g. prototype pollution), and strip newlines if any.
      // A newline wouldn't be a valid sourceURL anyway, and it'd enable code injection.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/[\r\n]/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      // Like with sourceURL, we take care to not check the option's prototype,
      // as this configuration is a code injection vector.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrim, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimEnd, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return _;
    }.call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else if (freeModule) {
    // Export for Node.js.
    (freeModule.exports = _)._ = _;
    // Export for CommonJS support.
    freeExports._ = _;
  }
  else {
    // Export to the global object.
    root._ = _;
  }
}.call(this));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(4), __webpack_require__(36)(module)))

/***/ }),

/***/ 5286:
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

// Some environments don't have global Buffer (e.g. React Native).
// Solution would be installing npm modules "buffer" and "stream" explicitly.
var Buffer = __webpack_require__(119).Buffer;

var bomHandling = __webpack_require__(5287),
    iconv = module.exports;

// All codecs and aliases are kept here, keyed by encoding name/alias.
// They are lazy loaded in `iconv.getCodec` from `encodings/index.js`.
iconv.encodings = null;

// Characters emitted in case of error.
iconv.defaultCharUnicode = '';
iconv.defaultCharSingleByte = '?';

// Public API.
iconv.encode = function encode(str, encoding, options) {
    str = "" + (str || ""); // Ensure string.

    var encoder = iconv.getEncoder(encoding, options);

    var res = encoder.write(str);
    var trail = encoder.end();
    
    return (trail && trail.length > 0) ? Buffer.concat([res, trail]) : res;
}

iconv.decode = function decode(buf, encoding, options) {
    if (typeof buf === 'string') {
        if (!iconv.skipDecodeWarning) {
            console.error('Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding');
            iconv.skipDecodeWarning = true;
        }

        buf = Buffer.from("" + (buf || ""), "binary"); // Ensure buffer.
    }

    var decoder = iconv.getDecoder(encoding, options);

    var res = decoder.write(buf);
    var trail = decoder.end();

    return trail ? (res + trail) : res;
}

iconv.encodingExists = function encodingExists(enc) {
    try {
        iconv.getCodec(enc);
        return true;
    } catch (e) {
        return false;
    }
}

// Legacy aliases to convert functions
iconv.toEncoding = iconv.encode;
iconv.fromEncoding = iconv.decode;

// Search for a codec in iconv.encodings. Cache codec data in iconv._codecDataCache.
iconv._codecDataCache = {};
iconv.getCodec = function getCodec(encoding) {
    if (!iconv.encodings)
        iconv.encodings = __webpack_require__(5288); // Lazy load all encoding definitions.
    
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    var enc = iconv._canonicalizeEncoding(encoding);

    // Traverse iconv.encodings to find actual codec.
    var codecOptions = {};
    while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
            return codec;

        var codecDef = iconv.encodings[enc];

        switch (typeof codecDef) {
            case "string": // Direct alias to other encoding.
                enc = codecDef;
                break;

            case "object": // Alias with options. Can be layered.
                for (var key in codecDef)
                    codecOptions[key] = codecDef[key];

                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;
                
                enc = codecDef.type;
                break;

            case "function": // Codec itself.
                if (!codecOptions.encodingName)
                    codecOptions.encodingName = enc;

                // The codec function must load all tables and return object with .encoder and .decoder methods.
                // It'll be called only once (for each different options object).
                codec = new codecDef(codecOptions, iconv);

                iconv._codecDataCache[codecOptions.encodingName] = codec; // Save it to be reused later.
                return codec;

            default:
                throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '"+enc+"')");
        }
    }
}

iconv._canonicalizeEncoding = function(encoding) {
    // Canonicalize encoding name: strip all non-alphanumeric chars and appended year.
    return (''+encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
}

iconv.getEncoder = function getEncoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        encoder = new codec.encoder(options, codec);

    if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);

    return encoder;
}

iconv.getDecoder = function getDecoder(encoding, options) {
    var codec = iconv.getCodec(encoding),
        decoder = new codec.decoder(options, codec);

    if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);

    return decoder;
}


// Load extensions in Node. All of them are omitted in Browserify build via 'browser' field in package.json.
var nodeVer = typeof process !== 'undefined' && process.versions && process.versions.node;
if (nodeVer) {

    // Load streaming support in Node v0.10+
    var nodeVerArr = nodeVer.split(".").map(Number);
    if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        __webpack_require__(5303)(iconv);
    }

    // Load Node primitive extensions.
    __webpack_require__(5304)(iconv);
}

if (false) {
    console.error("iconv-lite warning: javascript files use encoding different from utf-8. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),

/***/ 5287:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var BOMChar = '\uFEFF';

exports.PrependBOM = PrependBOMWrapper
function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
}

PrependBOMWrapper.prototype.write = function(str) {
    if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
    }

    return this.encoder.write(str);
}

PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
}


//------------------------------------------------------------------------------

exports.StripBOM = StripBOMWrapper;
function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
}

StripBOMWrapper.prototype.write = function(buf) {
    var res = this.decoder.write(buf);
    if (this.pass || !res)
        return res;

    if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === 'function')
            this.options.stripBOM();
    }

    this.pass = true;
    return res;
}

StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
}



/***/ }),

/***/ 5288:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Update this array if you add/rename/remove files in this directory.
// We support Browserify by skipping automatic module discovery and requiring modules directly.
var modules = [
    __webpack_require__(5289),
    __webpack_require__(5290),
    __webpack_require__(5291),
    __webpack_require__(5292),
    __webpack_require__(5293),
    __webpack_require__(5294),
    __webpack_require__(5295),
    __webpack_require__(5296),
    __webpack_require__(5297),
];

// Put all encoding/alias/codec definitions to single object and export it.
for (var i = 0; i < modules.length; i++) {
    var module = modules[i];
    for (var enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
}


/***/ }),

/***/ 5289:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(119).Buffer;

// Export Node.js internal encodings.

module.exports = {
    // Encodings
    utf8:   { type: "_internal", bomAware: true},
    cesu8:  { type: "_internal", bomAware: true},
    unicode11utf8: "utf8",

    ucs2:   { type: "_internal", bomAware: true},
    utf16le: "ucs2",

    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex:    { type: "_internal" },

    // Codec.
    _internal: InternalCodec,
};

//------------------------------------------------------------------------------

function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;

    if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
        this.enc = "utf8"; // Use utf8 for decoding.
        this.encoder = InternalEncoderCesu8;

        // Add decoder for versions of Node not supporting CESU-8
        if (Buffer.from('eda0bdedb2a9', 'hex').toString() !== '') {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
    }
}

InternalCodec.prototype.encoder = InternalEncoder;
InternalCodec.prototype.decoder = InternalDecoder;

//------------------------------------------------------------------------------

// We use node.js internal decoder. Its signature is the same as ours.
var StringDecoder = __webpack_require__(53).StringDecoder;

if (!StringDecoder.prototype.end) // Node v0.8 doesn't have this method.
    StringDecoder.prototype.end = function() {};


function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
}

InternalDecoder.prototype = StringDecoder.prototype;


//------------------------------------------------------------------------------
// Encoder is mostly trivial

function InternalEncoder(options, codec) {
    this.enc = codec.enc;
}

InternalEncoder.prototype.write = function(str) {
    return Buffer.from(str, this.enc);
}

InternalEncoder.prototype.end = function() {
}


//------------------------------------------------------------------------------
// Except base64 encoder, which must keep its state.

function InternalEncoderBase64(options, codec) {
    this.prevStr = '';
}

InternalEncoderBase64.prototype.write = function(str) {
    str = this.prevStr + str;
    var completeQuads = str.length - (str.length % 4);
    this.prevStr = str.slice(completeQuads);
    str = str.slice(0, completeQuads);

    return Buffer.from(str, "base64");
}

InternalEncoderBase64.prototype.end = function() {
    return Buffer.from(this.prevStr, "base64");
}


//------------------------------------------------------------------------------
// CESU-8 encoder is also special.

function InternalEncoderCesu8(options, codec) {
}

InternalEncoderCesu8.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length * 3), bufIdx = 0;
    for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        // Naive implementation, but it works because CESU-8 is especially easy
        // to convert from UTF-16 (which all JS strings are encoded in).
        if (charCode < 0x80)
            buf[bufIdx++] = charCode;
        else if (charCode < 0x800) {
            buf[bufIdx++] = 0xC0 + (charCode >>> 6);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
        else { // charCode will always be < 0x10000 in javascript.
            buf[bufIdx++] = 0xE0 + (charCode >>> 12);
            buf[bufIdx++] = 0x80 + ((charCode >>> 6) & 0x3f);
            buf[bufIdx++] = 0x80 + (charCode & 0x3f);
        }
    }
    return buf.slice(0, bufIdx);
}

InternalEncoderCesu8.prototype.end = function() {
}

//------------------------------------------------------------------------------
// CESU-8 decoder is not implemented in Node v4.0+

function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
}

InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, 
        res = '';
    for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 0xC0) !== 0x80) { // Leading byte
            if (contBytes > 0) { // Previous code is invalid
                res += this.defaultCharUnicode;
                contBytes = 0;
            }

            if (curByte < 0x80) { // Single-byte code
                res += String.fromCharCode(curByte);
            } else if (curByte < 0xE0) { // Two-byte code
                acc = curByte & 0x1F;
                contBytes = 1; accBytes = 1;
            } else if (curByte < 0xF0) { // Three-byte code
                acc = curByte & 0x0F;
                contBytes = 2; accBytes = 1;
            } else { // Four or more are not supported for CESU-8.
                res += this.defaultCharUnicode;
            }
        } else { // Continuation byte
            if (contBytes > 0) { // We're waiting for it.
                acc = (acc << 6) | (curByte & 0x3f);
                contBytes--; accBytes++;
                if (contBytes === 0) {
                    // Check for overlong encoding, but support Modified UTF-8 (encoding NULL as C0 80)
                    if (accBytes === 2 && acc < 0x80 && acc > 0)
                        res += this.defaultCharUnicode;
                    else if (accBytes === 3 && acc < 0x800)
                        res += this.defaultCharUnicode;
                    else
                        // Actually add character.
                        res += String.fromCharCode(acc);
                }
            } else { // Unexpected continuation byte
                res += this.defaultCharUnicode;
            }
        }
    }
    this.acc = acc; this.contBytes = contBytes; this.accBytes = accBytes;
    return res;
}

InternalDecoderCesu8.prototype.end = function() {
    var res = 0;
    if (this.contBytes > 0)
        res += this.defaultCharUnicode;
    return res;
}


/***/ }),

/***/ 5290:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Buffer = __webpack_require__(119).Buffer;

// == UTF32-LE/BE codec. ==========================================================

exports._utf32 = Utf32Codec;

function Utf32Codec(codecOptions, iconv) {
    this.iconv = iconv;
    this.bomAware = true;
    this.isLE = codecOptions.isLE;
}

exports.utf32le = { type: '_utf32', isLE: true };
exports.utf32be = { type: '_utf32', isLE: false };

// Aliases
exports.ucs4le = 'utf32le';
exports.ucs4be = 'utf32be';

Utf32Codec.prototype.encoder = Utf32Encoder;
Utf32Codec.prototype.decoder = Utf32Decoder;

// -- Encoding

function Utf32Encoder(options, codec) {
    this.isLE = codec.isLE;
    this.highSurrogate = 0;
}

Utf32Encoder.prototype.write = function(str) {
    var src = Buffer.from(str, 'ucs2');
    var dst = Buffer.alloc(src.length * 2);
    var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
    var offset = 0;

    for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = (0xD800 <= code && code < 0xDC00);
        var isLowSurrogate = (0xDC00 <= code && code < 0xE000);

        if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
                // There shouldn't be two high surrogates in a row, nor a high surrogate which isn't followed by a low
                // surrogate. If this happens, keep the pending high surrogate as a stand-alone semi-invalid character
                // (technically wrong, but expected by some applications, like Windows file names).
                write32.call(dst, this.highSurrogate, offset);
                offset += 4;
            }
            else {
                // Create 32-bit value from high and low surrogates;
                var codepoint = (((this.highSurrogate - 0xD800) << 10) | (code - 0xDC00)) + 0x10000;

                write32.call(dst, codepoint, offset);
                offset += 4;
                this.highSurrogate = 0;

                continue;
            }
        }

        if (isHighSurrogate)
            this.highSurrogate = code;
        else {
            // Even if the current character is a low surrogate, with no previous high surrogate, we'll
            // encode it as a semi-invalid stand-alone character for the same reasons expressed above for
            // unpaired high surrogates.
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
        }
    }

    if (offset < dst.length)
        dst = dst.slice(0, offset);

    return dst;
};

Utf32Encoder.prototype.end = function() {
    // Treat any leftover high surrogate as a semi-valid independent character.
    if (!this.highSurrogate)
        return;

    var buf = Buffer.alloc(4);

    if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
    else
        buf.writeUInt32BE(this.highSurrogate, 0);

    this.highSurrogate = 0;

    return buf;
};

// -- Decoding

function Utf32Decoder(options, codec) {
    this.isLE = codec.isLE;
    this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
    this.overflow = null;
}

Utf32Decoder.prototype.write = function(src) {
    if (src.length === 0)
        return '';

    if (this.overflow)
        src = Buffer.concat([this.overflow, src]);

    var goodLength = src.length - src.length % 4;

    if (src.length !== goodLength) {
        this.overflow = src.slice(goodLength);
        src = src.slice(0, goodLength);
    }
    else
        this.overflow = null;

    var dst = Buffer.alloc(goodLength);
    var offset = 0;

    for (var i = 0; i < goodLength; i += 4) {
        var codepoint = this.isLE ? src.readUInt32LE(i) : src.readUInt32BE(i);

        if (codepoint < 0x10000) {
            // Simple 16-bit character
            dst.writeUInt16LE(codepoint, offset);
            offset += 2;
        }
        else {
            if (codepoint > 0x10FFFF) {
                // Not a valid Unicode codepoint
                dst.writeUInt16LE(this.badChar, offset);
                offset += 2;
            }
            else {
                // Create high and low surrogates.
                codepoint -= 0x10000;
                var high = 0xD800 | (codepoint >> 10);
                var low = 0xDC00 + (codepoint & 0x3FF);
                dst.writeUInt16LE(high, offset);
                offset += 2;
                dst.writeUInt16LE(low, offset);
                offset += 2;
            }
        }
    }

    return dst.slice(0, offset).toString('ucs2');
};

Utf32Decoder.prototype.end = function() {
    this.overflow = null;
};

// == UTF-32 Auto codec =============================================================
// Decoder chooses automatically from UTF-32LE and UTF-32BE using BOM and space-based heuristic.
// Defaults to UTF-32LE. http://en.wikipedia.org/wiki/UTF-32
// Encoder/decoder default can be changed: iconv.decode(buf, 'utf32', {defaultEncoding: 'utf-32be'});

// Encoder prepends BOM (which can be overridden with (addBOM: false}).

exports.utf32 = Utf32AutoCodec;
exports.ucs4 = Utf32AutoCodec;

function Utf32AutoCodec(options, iconv) {
    this.iconv = iconv;
}

Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;

// -- Encoding

function Utf32AutoEncoder(options, codec) {
    options = options || {};

    if (options.addBOM === undefined)
        options.addBOM = true;

    this.encoder = codec.iconv.getEncoder(options.defaultEncoding || 'utf-32le', options);
}

Utf32AutoEncoder.prototype.write = function(str) {
    return this.encoder.write(str);
};

Utf32AutoEncoder.prototype.end = function() {
    return this.encoder.end();
};

// -- Decoding

function Utf32AutoDecoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf32AutoDecoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;

        if (this.initialBytesLen < 32) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf2 = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf2, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
};

Utf32AutoDecoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }

    return this.decoder.end();
};

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-32le';

    if (buf.length >= 4) {
        // Check BOM.
        if (buf.readUInt32BE(0) === 0xFEFF) // UTF-32LE BOM
            enc = 'utf-32be';
        else if (buf.readUInt32LE(0) === 0xFEFF) // UTF-32LE BOM
            enc = 'utf-32le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Using the wrong endian-ism for UTF-32 will very often result in codepoints that are beyond
            // the valid Unicode limit of 0x10FFFF. That will be used as the primary determinant.
            //
            // Further, we can suppose the content is mostly plain ASCII chars (U+00**).
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var invalidLE = 0, invalidBE = 0;
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 4), 128); // Len is always even.

            for (var i = 0; i < _len; i += 4) {
                var b0 = buf[i], b1  = buf[i + 1], b2 = buf[i + 2], b3 = buf[i + 3];

                if (b0 !== 0 || b1 > 0x10) ++invalidBE;
                if (b3 !== 0 || b2 > 0x10) ++invalidLE;

                if (b0 === 0 && b1 === 0 && b2 === 0 && b3 !== 0) asciiCharsBE++;
                if (b0 !== 0 && b1 === 0 && b2 === 0 && b3 === 0) asciiCharsLE++;
            }

            if (invalidBE < invalidLE)
                enc = 'utf-32be';
            else if (invalidLE < invalidBE)
                enc = 'utf-32le';
            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-32be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-32le';
        }
    }

    return enc;
}


/***/ }),

/***/ 5291:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(119).Buffer;

// Note: UTF16-LE (or UCS2) codec is Node.js native. See encodings/internal.js

// == UTF16-BE codec. ==========================================================

exports.utf16be = Utf16BECodec;
function Utf16BECodec() {
}

Utf16BECodec.prototype.encoder = Utf16BEEncoder;
Utf16BECodec.prototype.decoder = Utf16BEDecoder;
Utf16BECodec.prototype.bomAware = true;


// -- Encoding

function Utf16BEEncoder() {
}

Utf16BEEncoder.prototype.write = function(str) {
    var buf = Buffer.from(str, 'ucs2');
    for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i]; buf[i] = buf[i+1]; buf[i+1] = tmp;
    }
    return buf;
}

Utf16BEEncoder.prototype.end = function() {
}


// -- Decoding

function Utf16BEDecoder() {
    this.overflowByte = -1;
}

Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
        return '';

    var buf2 = Buffer.alloc(buf.length + 1),
        i = 0, j = 0;

    if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1; j = 2;
    }

    for (; i < buf.length-1; i += 2, j+= 2) {
        buf2[j] = buf[i+1];
        buf2[j+1] = buf[i];
    }

    this.overflowByte = (i == buf.length-1) ? buf[buf.length-1] : -1;

    return buf2.slice(0, j).toString('ucs2');
}

Utf16BEDecoder.prototype.end = function() {
}


// == UTF-16 codec =============================================================
// Decoder chooses automatically from UTF-16LE and UTF-16BE using BOM and space-based heuristic.
// Defaults to UTF-16LE, as it's prevalent and default in Node.
// http://en.wikipedia.org/wiki/UTF-16 and http://encoding.spec.whatwg.org/#utf-16le
// Decoder default can be changed: iconv.decode(buf, 'utf16', {defaultEncoding: 'utf-16be'});

// Encoder uses UTF-16LE and prepends BOM (which can be overridden with addBOM: false).

exports.utf16 = Utf16Codec;
function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
}

Utf16Codec.prototype.encoder = Utf16Encoder;
Utf16Codec.prototype.decoder = Utf16Decoder;


// -- Encoding (pass-through)

function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === undefined)
        options.addBOM = true;
    this.encoder = codec.iconv.getEncoder('utf-16le', options);
}

Utf16Encoder.prototype.write = function(str) {
    return this.encoder.write(str);
}

Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
}


// -- Decoding

function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;

    this.options = options || {};
    this.iconv = codec.iconv;
}

Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
        // Codec is not chosen yet. Accumulate initial bytes.
        this.initialBytes.push(buf);
        this.initialBytesLen += buf.length;
        
        if (this.initialBytesLen < 16) // We need more bytes to use space heuristic (see below)
            return '';

        // We have enough bytes -> detect endianness.
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        this.initialBytes.length = this.initialBytesLen = 0;
    }

    return this.decoder.write(buf);
}

Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
        var buf = Buffer.concat(this.initialBytes),
            encoding = detectEncoding(buf, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);

        var res = this.decoder.write(buf),
            trail = this.decoder.end();

        return trail ? (res + trail) : res;
    }
    return this.decoder.end();
}

function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || 'utf-16le';

    if (buf.length >= 2) {
        // Check BOM.
        if (buf[0] == 0xFE && buf[1] == 0xFF) // UTF-16BE BOM
            enc = 'utf-16be';
        else if (buf[0] == 0xFF && buf[1] == 0xFE) // UTF-16LE BOM
            enc = 'utf-16le';
        else {
            // No BOM found. Try to deduce encoding from initial content.
            // Most of the time, the content has ASCII chars (U+00**), but the opposite (U+**00) is uncommon.
            // So, we count ASCII as if it was LE or BE, and decide from that.
            var asciiCharsLE = 0, asciiCharsBE = 0, // Counts of chars in both positions
                _len = Math.min(buf.length - (buf.length % 2), 64); // Len is always even.

            for (var i = 0; i < _len; i += 2) {
                if (buf[i] === 0 && buf[i+1] !== 0) asciiCharsBE++;
                if (buf[i] !== 0 && buf[i+1] === 0) asciiCharsLE++;
            }

            if (asciiCharsBE > asciiCharsLE)
                enc = 'utf-16be';
            else if (asciiCharsBE < asciiCharsLE)
                enc = 'utf-16le';
        }
    }

    return enc;
}




/***/ }),

/***/ 5292:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(119).Buffer;

// UTF-7 codec, according to https://tools.ietf.org/html/rfc2152
// See also below a UTF-7-IMAP codec, according to http://tools.ietf.org/html/rfc3501#section-5.1.3

exports.utf7 = Utf7Codec;
exports.unicode11utf7 = 'utf7'; // Alias UNICODE-1-1-UTF-7
function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7Codec.prototype.encoder = Utf7Encoder;
Utf7Codec.prototype.decoder = Utf7Decoder;
Utf7Codec.prototype.bomAware = true;


// -- Encoding

var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;

function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
}

Utf7Encoder.prototype.write = function(str) {
    // Naive implementation.
    // Non-direct chars are encoded as "+<base64>-"; single "+" char is encoded as "+-".
    return Buffer.from(str.replace(nonDirectChars, function(chunk) {
        return "+" + (chunk === '+' ? '' : 
            this.iconv.encode(chunk, 'utf16-be').toString('base64').replace(/=+$/, '')) 
            + "-";
    }.bind(this)));
}

Utf7Encoder.prototype.end = function() {
}


// -- Decoding

function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64Regex = /[A-Za-z0-9\/+]/;
var base64Chars = [];
for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));

var plusChar = '+'.charCodeAt(0), 
    minusChar = '-'.charCodeAt(0),
    andChar = '&'.charCodeAt(0);

Utf7Decoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '+'
            if (buf[i] == plusChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64Chars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) {// "+-" -> "+"
                    res += "+";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString();
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus is absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString();

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7Decoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}


// UTF-7-IMAP codec.
// RFC3501 Sec. 5.1.3 Modified UTF-7 (http://tools.ietf.org/html/rfc3501#section-5.1.3)
// Differences:
//  * Base64 part is started by "&" instead of "+"
//  * Direct characters are 0x20-0x7E, except "&" (0x26)
//  * In Base64, "," is used instead of "/"
//  * Base64 must not be used to represent direct characters.
//  * No implicit shift back from Base64 (should always end with '-')
//  * String must end in non-shifted position.
//  * "-&" while in base64 is not allowed.


exports.utf7imap = Utf7IMAPCodec;
function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
};

Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
Utf7IMAPCodec.prototype.bomAware = true;


// -- Encoding

function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer.alloc(6);
    this.base64AccumIdx = 0;
}

Utf7IMAPEncoder.prototype.write = function(str) {
    var inBase64 = this.inBase64,
        base64Accum = this.base64Accum,
        base64AccumIdx = this.base64AccumIdx,
        buf = Buffer.alloc(str.length*5 + 10), bufIdx = 0;

    for (var i = 0; i < str.length; i++) {
        var uChar = str.charCodeAt(i);
        if (0x20 <= uChar && uChar <= 0x7E) { // Direct character or '&'.
            if (inBase64) {
                if (base64AccumIdx > 0) {
                    bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
                    base64AccumIdx = 0;
                }

                buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
                inBase64 = false;
            }

            if (!inBase64) {
                buf[bufIdx++] = uChar; // Write direct character

                if (uChar === andChar)  // Ampersand -> '&-'
                    buf[bufIdx++] = minusChar;
            }

        } else { // Non-direct character
            if (!inBase64) {
                buf[bufIdx++] = andChar; // Write '&', then go to base64 mode.
                inBase64 = true;
            }
            if (inBase64) {
                base64Accum[base64AccumIdx++] = uChar >> 8;
                base64Accum[base64AccumIdx++] = uChar & 0xFF;

                if (base64AccumIdx == base64Accum.length) {
                    bufIdx += buf.write(base64Accum.toString('base64').replace(/\//g, ','), bufIdx);
                    base64AccumIdx = 0;
                }
            }
        }
    }

    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;

    return buf.slice(0, bufIdx);
}

Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer.alloc(10), bufIdx = 0;
    if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString('base64').replace(/\//g, ',').replace(/=+$/, ''), bufIdx);
            this.base64AccumIdx = 0;
        }

        buf[bufIdx++] = minusChar; // Write '-', then go to direct mode.
        this.inBase64 = false;
    }

    return buf.slice(0, bufIdx);
}


// -- Decoding

function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = '';
}

var base64IMAPChars = base64Chars.slice();
base64IMAPChars[','.charCodeAt(0)] = true;

Utf7IMAPDecoder.prototype.write = function(buf) {
    var res = "", lastI = 0,
        inBase64 = this.inBase64,
        base64Accum = this.base64Accum;

    // The decoder is more involved as we must handle chunks in stream.
    // It is forgiving, closer to standard UTF-7 (for example, '-' is optional at the end).

    for (var i = 0; i < buf.length; i++) {
        if (!inBase64) { // We're in direct mode.
            // Write direct chars until '&'
            if (buf[i] == andChar) {
                res += this.iconv.decode(buf.slice(lastI, i), "ascii"); // Write direct chars.
                lastI = i+1;
                inBase64 = true;
            }
        } else { // We decode base64.
            if (!base64IMAPChars[buf[i]]) { // Base64 ended.
                if (i == lastI && buf[i] == minusChar) { // "&-" -> "&"
                    res += "&";
                } else {
                    var b64str = base64Accum + buf.slice(lastI, i).toString().replace(/,/g, '/');
                    res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
                }

                if (buf[i] != minusChar) // Minus may be absorbed after base64.
                    i--;

                lastI = i+1;
                inBase64 = false;
                base64Accum = '';
            }
        }
    }

    if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii"); // Write direct chars.
    } else {
        var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, '/');

        var canBeDecoded = b64str.length - (b64str.length % 8); // Minimal chunk: 2 quads -> 2x3 bytes -> 3 chars.
        base64Accum = b64str.slice(canBeDecoded); // The rest will be decoded in future.
        b64str = b64str.slice(0, canBeDecoded);

        res += this.iconv.decode(Buffer.from(b64str, 'base64'), "utf16-be");
    }

    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;

    return res;
}

Utf7IMAPDecoder.prototype.end = function() {
    var res = "";
    if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer.from(this.base64Accum, 'base64'), "utf16-be");

    this.inBase64 = false;
    this.base64Accum = '';
    return res;
}




/***/ }),

/***/ 5293:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(119).Buffer;

// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that
// correspond to encoded bytes (if 128 - then lower half is ASCII). 

exports._sbcs = SBCSCodec;
function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
        throw new Error("SBCS codec is called without the data.")
    
    // Prepare char buffer for decoding.
    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))
        throw new Error("Encoding '"+codecOptions.type+"' has incorrect 'chars' (must be of len 128 or 256)");
    
    if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
            asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
    }

    this.decodeBuf = Buffer.from(codecOptions.chars, 'ucs2');
    
    // Encoding buffer.
    var encodeBuf = Buffer.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));

    for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;

    this.encodeBuf = encodeBuf;
}

SBCSCodec.prototype.encoder = SBCSEncoder;
SBCSCodec.prototype.decoder = SBCSDecoder;


function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
}

SBCSEncoder.prototype.write = function(str) {
    var buf = Buffer.alloc(str.length);
    for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
    
    return buf;
}

SBCSEncoder.prototype.end = function() {
}


function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
}

SBCSDecoder.prototype.write = function(buf) {
    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer.alloc(buf.length*2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i]*2; idx2 = i*2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2+1] = decodeBuf[idx1+1];
    }
    return newBuf.toString('ucs2');
}

SBCSDecoder.prototype.end = function() {
}


/***/ }),

/***/ 5294:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Manually added data to be used by sbcs codec in addition to generated one.

module.exports = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
    },

    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
        "type": "_sbcs",
        "chars": ""
    },

    "mik": {
        "type": "_sbcs",
        "chars": ""
    },

    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",

    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",

    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek" : "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",

    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",

    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",

    "cp819": "iso88591",
    "ibm819": "iso88591",

    "cyrillic": "iso88595",

    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",

    "greek" : "iso88597",
    "greek8" : "iso88597",
    "ecma118" : "iso88597",
    "elot928" : "iso88597",

    "hebrew": "iso88598",
    "hebrew8": "iso88598",

    "turkish": "iso88599",
    "turkish8": "iso88599",

    "thai": "iso885911",
    "thai8": "iso885911",

    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",

    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",

    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",

    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",

    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",

    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",

    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",

    "strk10482002": "rk1048",

    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",

    "gb198880": "iso646cn",
    "cn": "iso646cn",

    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",

    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",

    "mac": "macintosh",
    "csmacintosh": "macintosh",
};



/***/ }),

/***/ 5295:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Generated data for sbcs codec. Don't edit manually. Regenerate using generation/gen-sbcs.js script.
module.exports = {
  "437": "cp437",
  "737": "cp737",
  "775": "cp775",
  "850": "cp850",
  "852": "cp852",
  "855": "cp855",
  "856": "cp856",
  "857": "cp857",
  "858": "cp858",
  "860": "cp860",
  "861": "cp861",
  "862": "cp862",
  "863": "cp863",
  "864": "cp864",
  "865": "cp865",
  "866": "cp866",
  "869": "cp869",
  "874": "windows874",
  "922": "cp922",
  "1046": "cp1046",
  "1124": "cp1124",
  "1125": "cp1125",
  "1129": "cp1129",
  "1133": "cp1133",
  "1161": "cp1161",
  "1162": "cp1162",
  "1163": "cp1163",
  "1250": "windows1250",
  "1251": "windows1251",
  "1252": "windows1252",
  "1253": "windows1253",
  "1254": "windows1254",
  "1255": "windows1255",
  "1256": "windows1256",
  "1257": "windows1257",
  "1258": "windows1258",
  "28591": "iso88591",
  "28592": "iso88592",
  "28593": "iso88593",
  "28594": "iso88594",
  "28595": "iso88595",
  "28596": "iso88596",
  "28597": "iso88597",
  "28598": "iso88598",
  "28599": "iso88599",
  "28600": "iso885910",
  "28601": "iso885911",
  "28603": "iso885913",
  "28604": "iso885914",
  "28605": "iso885915",
  "28606": "iso885916",
  "windows874": {
    "type": "_sbcs",
    "chars": ""
  },
  "win874": "windows874",
  "cp874": "windows874",
  "windows1250": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1250": "windows1250",
  "cp1250": "windows1250",
  "windows1251": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1251": "windows1251",
  "cp1251": "windows1251",
  "windows1252": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1252": "windows1252",
  "cp1252": "windows1252",
  "windows1253": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1253": "windows1253",
  "cp1253": "windows1253",
  "windows1254": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1254": "windows1254",
  "cp1254": "windows1254",
  "windows1255": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1255": "windows1255",
  "cp1255": "windows1255",
  "windows1256": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1256": "windows1256",
  "cp1256": "windows1256",
  "windows1257": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1257": "windows1257",
  "cp1257": "windows1257",
  "windows1258": {
    "type": "_sbcs",
    "chars": ""
  },
  "win1258": "windows1258",
  "cp1258": "windows1258",
  "iso88591": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28591": "iso88591",
  "iso88592": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28592": "iso88592",
  "iso88593": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28593": "iso88593",
  "iso88594": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28594": "iso88594",
  "iso88595": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28595": "iso88595",
  "iso88596": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28596": "iso88596",
  "iso88597": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28597": "iso88597",
  "iso88598": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28598": "iso88598",
  "iso88599": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28599": "iso88599",
  "iso885910": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28600": "iso885910",
  "iso885911": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28601": "iso885911",
  "iso885913": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28603": "iso885913",
  "iso885914": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28604": "iso885914",
  "iso885915": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28605": "iso885915",
  "iso885916": {
    "type": "_sbcs",
    "chars": ""
  },
  "cp28606": "iso885916",
  "cp437": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm437": "cp437",
  "csibm437": "cp437",
  "cp737": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm737": "cp737",
  "csibm737": "cp737",
  "cp775": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm775": "cp775",
  "csibm775": "cp775",
  "cp850": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm850": "cp850",
  "csibm850": "cp850",
  "cp852": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm852": "cp852",
  "csibm852": "cp852",
  "cp855": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm855": "cp855",
  "csibm855": "cp855",
  "cp856": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm856": "cp856",
  "csibm856": "cp856",
  "cp857": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm857": "cp857",
  "csibm857": "cp857",
  "cp858": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm858": "cp858",
  "csibm858": "cp858",
  "cp860": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm860": "cp860",
  "csibm860": "cp860",
  "cp861": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm861": "cp861",
  "csibm861": "cp861",
  "cp862": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm862": "cp862",
  "csibm862": "cp862",
  "cp863": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm863": "cp863",
  "csibm863": "cp863",
  "cp864": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "ibm864": "cp864",
  "csibm864": "cp864",
  "cp865": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm865": "cp865",
  "csibm865": "cp865",
  "cp866": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm866": "cp866",
  "csibm866": "cp866",
  "cp869": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm869": "cp869",
  "csibm869": "cp869",
  "cp922": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm922": "cp922",
  "csibm922": "cp922",
  "cp1046": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1046": "cp1046",
  "csibm1046": "cp1046",
  "cp1124": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1124": "cp1124",
  "csibm1124": "cp1124",
  "cp1125": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1125": "cp1125",
  "csibm1125": "cp1125",
  "cp1129": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1129": "cp1129",
  "csibm1129": "cp1129",
  "cp1133": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1133": "cp1133",
  "csibm1133": "cp1133",
  "cp1161": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1161": "cp1161",
  "csibm1161": "cp1161",
  "cp1162": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1162": "cp1162",
  "csibm1162": "cp1162",
  "cp1163": {
    "type": "_sbcs",
    "chars": ""
  },
  "ibm1163": "cp1163",
  "csibm1163": "cp1163",
  "maccroatian": {
    "type": "_sbcs",
    "chars": ""
  },
  "maccyrillic": {
    "type": "_sbcs",
    "chars": ""
  },
  "macgreek": {
    "type": "_sbcs",
    "chars": ""
  },
  "maciceland": {
    "type": "_sbcs",
    "chars": ""
  },
  "macroman": {
    "type": "_sbcs",
    "chars": ""
  },
  "macromania": {
    "type": "_sbcs",
    "chars": ""
  },
  "macthai": {
    "type": "_sbcs",
    "chars": ""
  },
  "macturkish": {
    "type": "_sbcs",
    "chars": ""
  },
  "macukraine": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8r": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8u": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8ru": {
    "type": "_sbcs",
    "chars": ""
  },
  "koi8t": {
    "type": "_sbcs",
    "chars": ""
  },
  "armscii8": {
    "type": "_sbcs",
    "chars": ")(.,-"
  },
  "rk1048": {
    "type": "_sbcs",
    "chars": ""
  },
  "tcvn": {
    "type": "_sbcs",
    "chars": "\u0000\u0003\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "georgianacademy": {
    "type": "_sbcs",
    "chars": ""
  },
  "georgianps": {
    "type": "_sbcs",
    "chars": ""
  },
  "pt154": {
    "type": "_sbcs",
    "chars": ""
  },
  "viscii": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0003\u0004\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0015\u0016\u0017\u0018\u001a\u001b\u001c\u001d\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
  },
  "iso646cn": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "iso646jp": {
    "type": "_sbcs",
    "chars": "\u0000\u0001\u0002\u0003\u0004\u0005\u0006\u0007\b\t\n\u000b\f\r\u000e\u000f\u0010\u0011\u0012\u0013\u0014\u0015\u0016\u0017\u0018\u0019\u001a\u001b\u001c\u001d\u001e\u001f !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
  },
  "hproman8": {
    "type": "_sbcs",
    "chars": ""
  },
  "macintosh": {
    "type": "_sbcs",
    "chars": ""
  },
  "ascii": {
    "type": "_sbcs",
    "chars": ""
  },
  "tis620": {
    "type": "_sbcs",
    "chars": ""
  }
}

/***/ }),

/***/ 5296:
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var Buffer = __webpack_require__(119).Buffer;

// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.
// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.
// To save memory and loading time, we read table files only when requested.

exports._dbcs = DBCSCodec;

var UNASSIGNED = -1,
    GB18030_CODE = -2,
    SEQ_START  = -10,
    NODE_START = -1000,
    UNASSIGNED_NODE = new Array(0x100),
    DEF_CHAR = -1;

for (var i = 0; i < 0x100; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;


// Class DBCSCodec reads and initializes mapping tables.
function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
        throw new Error("DBCS codec is called without the data.")
    if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");

    // Load tables.
    var mappingTable = codecOptions.table();


    // Decode tables: MBCS -> Unicode.

    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.
    // Trie root is decodeTables[0].
    // Values: >=  0 -> unicode character code. can be > 0xFFFF
    //         == UNASSIGNED -> unknown/unassigned sequence.
    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.
    //         <= NODE_START -> index of the next node in our trie to process next byte.
    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.

    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. 
    this.decodeTableSeq = [];

    // Actual mapping tables consist of chunks. Use them to fill up decode tables.
    for (var i = 0; i < mappingTable.length; i++)
        this._addDecodeChunk(mappingTable[i]);

    this.defaultCharUnicode = iconv.defaultCharUnicode;

    
    // Encode tables: Unicode -> DBCS.

    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.
    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.
    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).
    //         == UNASSIGNED -> no conversion found. Output a default char.
    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.
    this.encodeTable = [];
    
    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of
    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key
    // means end of sequence (needed when one sequence is a strict subsequence of another).
    // Objects are kept separately from encodeTable to increase performance.
    this.encodeTableSeq = [];

    // Some chars can be decoded, but need not be encoded.
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === 'number')
                skipEncodeChars[val] = true;
            else
                for (var j = val.from; j <= val.to; j++)
                    skipEncodeChars[j] = true;
        }
        
    // Use decode trie to recursively fill out encode tables.
    this._fillEncodeTable(0, 0, skipEncodeChars);

    // Add more encoding pairs when needed.
    if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }

    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);


    // Load & create GB18030 tables when needed.
    if (typeof codecOptions.gb18030 === 'function') {
        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.

        // Add GB18030 decode tables.
        var thirdByteNodeIdx = this.decodeTables.length;
        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        var fourthByteNodeIdx = this.decodeTables.length;
        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);

        for (var i = 0x81; i <= 0xFE; i++) {
            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];
            var secondByteNode = this.decodeTables[secondByteNodeIdx];
            for (var j = 0x30; j <= 0x39; j++)
                secondByteNode[j] = NODE_START - thirdByteNodeIdx;
        }
        for (var i = 0x81; i <= 0xFE; i++)
            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;
        for (var i = 0x30; i <= 0x39; i++)
            fourthByteNode[i] = GB18030_CODE
    }        
}

DBCSCodec.prototype.encoder = DBCSEncoder;
DBCSCodec.prototype.decoder = DBCSDecoder;

// Decoder helpers
DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes = [];
    for (; addr > 0; addr >>= 8)
        bytes.push(addr & 0xFF);
    if (bytes.length == 0)
        bytes.push(0);

    var node = this.decodeTables[0];
    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.
        var val = node[bytes[i]];

        if (val == UNASSIGNED) { // Create new node.
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        }
        else if (val <= NODE_START) { // Existing node.
            node = this.decodeTables[NODE_START - val];
        }
        else
            throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node;
}


DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    // First element of chunk is the hex mbcs code where we start.
    var curAddr = parseInt(chunk[0], 16);

    // Choose the decoding node where we'll write our chars.
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 0xFF;

    // Write all other elements of the chunk to the table.
    for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") { // String, write as-is.
            for (var l = 0; l < part.length;) {
                var code = part.charCodeAt(l++);
                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate
                    var codeTrail = part.charCodeAt(l++);
                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)
                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);
                    else
                        throw new Error("Incorrect surrogate pair in "  + this.encodingName + " at chunk " + chunk[0]);
                }
                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)
                    var len = 0xFFF - code + 2;
                    var seq = [];
                    for (var m = 0; m < len; m++)
                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.

                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                    this.decodeTableSeq.push(seq);
                }
                else
                    writeTable[curAddr++] = code; // Basic char
            }
        } 
        else if (typeof part === "number") { // Integer, meaning increasing sequence starting with prev character.
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++)
                writeTable[curAddr++] = charCode++;
        }
        else
            throw new Error("Incorrect type '" + typeof part + "' given in "  + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 0xFF)
        throw new Error("Incorrect chunk in "  + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
}

// Encoder helpers
DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8; // This could be > 0xFF because of astral characters.
    if (this.encodeTable[high] === undefined)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.
    return this.encodeTable[high];
}

DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;
    if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.
    else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
}

DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    
    // Get the root of character tree according to first character of the sequence.
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 0xFF;

    var node;
    if (bucket[low] <= SEQ_START) {
        // There's already a sequence with  - use it.
        node = this.encodeTableSeq[SEQ_START-bucket[low]];
    }
    else {
        // There was no sequence object - allocate a new one.
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
    }

    // Traverse the character tree, allocating new nodes as needed.
    for (var j = 1; j < seq.length-1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === 'object')
            node = oldVal;
        else {
            node = node[uCode] = {}
            if (oldVal !== undefined)
                node[DEF_CHAR] = oldVal
        }
    }

    // Set the leaf to given dbcsCode.
    uCode = seq[seq.length-1];
    node[uCode] = dbcsCode;
}

DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node = this.decodeTables[nodeIdx];
    for (var i = 0; i < 0x100; i++) {
        var uCode = node[i];
        var mbCode = prefix + i;
        if (skipEncodeChars[mbCode])
            continue;

        if (uCode >= 0)
            this._setEncodeChar(uCode, mbCode);
        else if (uCode <= NODE_START)
            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
        else if (uCode <= SEQ_START)
            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
}



// == Encoder ==================================================================

function DBCSEncoder(options, codec) {
    // Encoder state
    this.leadSurrogate = -1;
    this.seqObj = undefined;
    
    // Static data
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
}

DBCSEncoder.prototype.write = function(str) {
    var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
        leadSurrogate = this.leadSurrogate,
        seqObj = this.seqObj, nextChar = -1,
        i = 0, j = 0;

    while (true) {
        // 0. Get next character.
        if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
        }
        else {
            var uCode = nextChar;
            nextChar = -1;    
        }

        // 1. Handle surrogates.
        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.
            if (uCode < 0xDC00) { // We've got lead surrogate.
                if (leadSurrogate === -1) {
                    leadSurrogate = uCode;
                    continue;
                } else {
                    leadSurrogate = uCode;
                    // Double lead surrogate found.
                    uCode = UNASSIGNED;
                }
            } else { // We've got trail surrogate.
                if (leadSurrogate !== -1) {
                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);
                    leadSurrogate = -1;
                } else {
                    // Incomplete surrogate pair - only trail surrogate found.
                    uCode = UNASSIGNED;
                }
                
            }
        }
        else if (leadSurrogate !== -1) {
            // Incomplete surrogate pair - only lead surrogate found.
            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.
            leadSurrogate = -1;
        }

        // 2. Convert uCode character.
        var dbcsCode = UNASSIGNED;
        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence
            var resCode = seqObj[uCode];
            if (typeof resCode === 'object') { // Sequence continues.
                seqObj = resCode;
                continue;

            } else if (typeof resCode == 'number') { // Sequence finished. Write it.
                dbcsCode = resCode;

            } else if (resCode == undefined) { // Current character is not part of the sequence.

                // Try default character for this sequence
                resCode = seqObj[DEF_CHAR];
                if (resCode !== undefined) {
                    dbcsCode = resCode; // Found. Write it.
                    nextChar = uCode; // Current character will be written too in the next iteration.

                } else {
                    // TODO: What if we have no default? (resCode == undefined)
                    // Then, we should write first char of the sequence as-is and try the rest recursively.
                    // Didn't do it for now because no encoding has this situation yet.
                    // Currently, just skip the sequence and write current char.
                }
            }
            seqObj = undefined;
        }
        else if (uCode >= 0) {  // Regular character
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined)
                dbcsCode = subtable[uCode & 0xFF];
            
            if (dbcsCode <= SEQ_START) { // Sequence start
                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];
                continue;
            }

            if (dbcsCode == UNASSIGNED && this.gb18030) {
                // Use GB18030 algorithm to find character(s) to write.
                var idx = findIdx(this.gb18030.uChars, uCode);
                if (idx != -1) {
                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;
                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;
                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;
                    newBuf[j++] = 0x30 + dbcsCode;
                    continue;
                }
            }
        }

        // 3. Write dbcsCode character.
        if (dbcsCode === UNASSIGNED)
            dbcsCode = this.defaultCharSingleByte;
        
        if (dbcsCode < 0x100) {
            newBuf[j++] = dbcsCode;
        }
        else if (dbcsCode < 0x10000) {
            newBuf[j++] = dbcsCode >> 8;   // high byte
            newBuf[j++] = dbcsCode & 0xFF; // low byte
        }
        else {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 0xFF;
            newBuf[j++] = dbcsCode & 0xFF;
        }
    }

    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j);
}

DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === undefined)
        return; // All clean. Most often case.

    var newBuf = Buffer.alloc(10), j = 0;

    if (this.seqObj) { // We're in the sequence.
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== undefined) { // Write beginning of the sequence.
            if (dbcsCode < 0x100) {
                newBuf[j++] = dbcsCode;
            }
            else {
                newBuf[j++] = dbcsCode >> 8;   // high byte
                newBuf[j++] = dbcsCode & 0xFF; // low byte
            }
        } else {
            // See todo above.
        }
        this.seqObj = undefined;
    }

    if (this.leadSurrogate !== -1) {
        // Incomplete surrogate pair - only lead surrogate found.
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
    }
    
    return newBuf.slice(0, j);
}

// Export for testing
DBCSEncoder.prototype.findIdx = findIdx;


// == Decoder ==================================================================

function DBCSDecoder(options, codec) {
    // Decoder state
    this.nodeIdx = 0;
    this.prevBuf = Buffer.alloc(0);

    // Static data
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
}

DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer.alloc(buf.length*2),
        nodeIdx = this.nodeIdx, 
        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,
        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.
        uCode;

    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.
        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);
    
    for (var i = 0, j = 0; i < buf.length; i++) {
        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];

        // Lookup in current trie node.
        var uCode = this.decodeTables[nodeIdx][curByte];

        if (uCode >= 0) { 
            // Normal character, just use it.
        }
        else if (uCode === UNASSIGNED) { // Unknown char.
            // TODO: Callback with seq.
            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).
            uCode = this.defaultCharUnicode.charCodeAt(0);
        }
        else if (uCode === GB18030_CODE) {
            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);
            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        }
        else if (uCode <= NODE_START) { // Go to next trie node.
            nodeIdx = NODE_START - uCode;
            continue;
        }
        else if (uCode <= SEQ_START) { // Output a sequence of chars.
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
                uCode = seq[k];
                newBuf[j++] = uCode & 0xFF;
                newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length-1];
        }
        else
            throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);

        // Write the character to buffer, handling higher planes using surrogate pair.
        if (uCode > 0xFFFF) { 
            uCode -= 0x10000;
            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);
            newBuf[j++] = uCodeLead & 0xFF;
            newBuf[j++] = uCodeLead >> 8;

            uCode = 0xDC00 + uCode % 0x400;
        }
        newBuf[j++] = uCode & 0xFF;
        newBuf[j++] = uCode >> 8;

        // Reset trie node.
        nodeIdx = 0; seqStart = i+1;
    }

    this.nodeIdx = nodeIdx;
    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j).toString('ucs2');
}

DBCSDecoder.prototype.end = function() {
    var ret = '';

    // Try to parse all remaining chars.
    while (this.prevBuf.length > 0) {
        // Skip 1 character in the buffer.
        ret += this.defaultCharUnicode;
        var buf = this.prevBuf.slice(1);

        // Parse remaining as usual.
        this.prevBuf = Buffer.alloc(0);
        this.nodeIdx = 0;
        if (buf.length > 0)
            ret += this.write(buf);
    }

    this.nodeIdx = 0;
    return ret;
}

// Binary search for GB18030. Returns largest i such that table[i] <= val.
function findIdx(table, val) {
    if (table[0] > val)
        return -1;

    var l = 0, r = table.length;
    while (l < r-1) { // always table[l] <= val < table[r]
        var mid = l + Math.floor((r-l+1)/2);
        if (table[mid] <= val)
            l = mid;
        else
            r = mid;
    }
    return l;
}



/***/ }),

/***/ 5297:
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// Description of supported double byte encodings and aliases.
// Tables are not require()-d until they are needed to speed up library load.
// require()-s are direct to support Browserify.

module.exports = {
    
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)

    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html

    'shiftjis': {
        type: '_dbcs',
        table: function() { return __webpack_require__(5298) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
        encodeSkipVals: [{from: 0xED40, to: 0xF940}],
    },
    'csshiftjis': 'shiftjis',
    'mskanji': 'shiftjis',
    'sjis': 'shiftjis',
    'windows31j': 'shiftjis',
    'ms31j': 'shiftjis',
    'xsjis': 'shiftjis',
    'windows932': 'shiftjis',
    'ms932': 'shiftjis',
    '932': 'shiftjis',
    'cp932': 'shiftjis',

    'eucjp': {
        type: '_dbcs',
        table: function() { return __webpack_require__(5299) },
        encodeAdd: {'\u00a5': 0x5C, '\u203E': 0x7E},
    },

    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.


    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder

    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    'gb2312': 'cp936',
    'gb231280': 'cp936',
    'gb23121980': 'cp936',
    'csgb2312': 'cp936',
    'csiso58gb231280': 'cp936',
    'euccn': 'cp936',

    // Microsoft's CP936 is a subset and approximation of GBK.
    'windows936': 'cp936',
    'ms936': 'cp936',
    '936': 'cp936',
    'cp936': {
        type: '_dbcs',
        table: function() { return __webpack_require__(4086) },
    },

    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    'gbk': {
        type: '_dbcs',
        table: function() { return __webpack_require__(4086).concat(__webpack_require__(4357)) },
    },
    'xgbk': 'gbk',
    'isoir58': 'gbk',

    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    'gb18030': {
        type: '_dbcs',
        table: function() { return __webpack_require__(4086).concat(__webpack_require__(4357)) },
        gb18030: function() { return __webpack_require__(5300) },
        encodeSkipVals: [0x80],
        encodeAdd: {'': 0xA2E3},
    },

    'chinese': 'gb18030',


    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    'windows949': 'cp949',
    'ms949': 'cp949',
    '949': 'cp949',
    'cp949': {
        type: '_dbcs',
        table: function() { return __webpack_require__(5301) },
    },

    'cseuckr': 'cp949',
    'csksc56011987': 'cp949',
    'euckr': 'cp949',
    'isoir149': 'cp949',
    'korean': 'cp949',
    'ksc56011987': 'cp949',
    'ksc56011989': 'cp949',
    'ksc5601': 'cp949',


    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.

    'windows950': 'cp950',
    'ms950': 'cp950',
    '950': 'cp950',
    'cp950': {
        type: '_dbcs',
        table: function() { return __webpack_require__(4358) },
    },

    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    'big5': 'big5hkscs',
    'big5hkscs': {
        type: '_dbcs',
        table: function() { return __webpack_require__(4358).concat(__webpack_require__(5302)) },
        encodeSkipVals: [0xa2cc],
    },

    'cnbig5': 'big5hkscs',
    'csbig5': 'big5hkscs',
    'xxbig5': 'big5hkscs',
};


/***/ }),

/***/ 5298:
/***/ (function(module, exports) {

module.exports = [["0","\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]

/***/ }),

/***/ 5299:
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]

/***/ }),

/***/ 5300:
/***/ (function(module, exports) {

module.exports = {"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}

/***/ }),

/***/ 5301:
/***/ (function(module, exports) {

module.exports = [["0","\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]

/***/ }),

/***/ 5302:
/***/ (function(module, exports) {

module.exports = [["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]

/***/ }),

/***/ 5303:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5304:
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 5305:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    dynamicVariables = __webpack_require__(5306),
    E = '',

    SuperString, // constructor
    Substitutor; // constructor

/**
 * A string-like instance with additional functionalities to track string operations better
 *
 * @constructor
 * @private
 * @param {String} value
 */
SuperString = function SuperString (value) {
    this.value = _.isString(value) ? value : (_.isFunction(value.toString) && value.toString() || E);

    /**
     * The total number of times there was a successful substitution.
     * @type {number}
     */
    this.substitutions = 0;

    /**
     * Keeps a track of the number of tokens replaced in the last replace command
     *
     * @type {number}
     */
    this.replacements = 0;
};

_.assign(SuperString.prototype, /** @lends SuperString.prototype */ {
    /**
     * Equivalent to string replace but performs additional tracking of the number of tokens replaced
     *
     * @param {RegExp|String} regex
     * @param {Function|String} fn
     * @returns {SuperString}
     */
    replace: function (regex, fn) {
        var replacements = 0; // maintain a count of tokens replaced

        // to ensure we do not perform needless operations in the replacement, we use multiple replacement functions
        // after validating the parameters
        this.value = (this.value.replace(regex, _.isFunction(fn) ? function () {
            replacements += 1;
            return fn.apply(this, arguments);
        } : function () { // this case is returned when replacer is not a function (ensures we do not need to check it)
            replacements += 1;
            return fn;
        }));

        this.replacements = replacements; // store the last replacements
        replacements && (this.substitutions += 1); // if any replacement is done, count that some substitution was made
        return this;
    },

    /**
     * @returns {String}
     */
    toString: function () {
        return this.value;
    },

    /**
     * @returns {String}
     */
    valueOf: function () {
        return this.value;
    }
});

/**
 * Perform replacement of tokens in a SuperString with values stored in keys of an array of objects.
 *
 * @constructor
 * @private
 * @param {Array} variables
 * @param {Object} defaults
 */
Substitutor = function (variables, defaults) {
    defaults && variables.push(defaults);
    this.variables = variables;
};

_.assign(Substitutor.prototype, /** @lends Substitutor.prototype */ {
    /**
     * Find a key from the array of variable objects provided to the substitutor
     *
     * @param {String} key
     * @returns {*}
     */
    find: function (key) {
        var arr = this.variables,
            obj,
            value,
            i,
            ii;

        for (i = 0, ii = arr.length; i < ii; i++) {
            obj = arr[i];
            // ensure that the item is an object
            if (!(obj && _.isObject(obj))) {
                continue;
            }

            // in case the object is a postman variable list, we give special attention
            if (obj.constructor._postman_propertyName === 'VariableList') {
                value = obj.oneNormalizedVariable(key);

                if (value && !value.disabled) {
                    return value;
                }
            }
            // else we return the value from the plain object
            else if (obj.hasOwnProperty(key)) {
                return obj[key];
            }
        }
    },

    /**
     * @param {String} value
     * @returns {String}
     */
    parse: function (value) {
        // convert the value into a SuperString so that it can return tracking results during replacements
        value = new SuperString(value);

        // get an instance of a replacer function that would be used to replace ejs like variable replacement
        // tokens
        var replacer = Substitutor.replacer(this);

        // replace the value once and keep on doing it until all tokens are replaced or we have reached a limit of
        // replacements
        do {
            value = value.replace(Substitutor.REGEX_EXTRACT_VARS, replacer);
        } while (value.replacements && (value.substitutions < Substitutor.VARS_SUBREPLACE_LIMIT));

        // @todo: uncomment this code, and try to raise a warning in some way.
        // do a final check that if recursion limits are reached then replace with blank string
        // if (value.substitutions >= Substitutor.VARS_SUBREPLACE_LIMIT) {
        //     value = value.replace(Substitutor.REGEX_EXTRACT_VARS, E);
        // }

        return value;
    }
});

_.assign(Substitutor, /** @lends Substitutor */ {
    /**
     * Regular expression to be used in {String}.replace for extracting variable substitutions
     * @readOnly
     * @type {RegExp}
     */
    REGEX_EXTRACT_VARS: /\{\{([^{}]*?)}}/g,

    /**
     * Defines the number of times the variable substitution mechanism will repeat until all tokens are resolved
     *
     * @type {Number}
     */
    VARS_SUBREPLACE_LIMIT: 19,

    /**
     * Maintain a list of types that are native
     * @readOnly
     * @enum {String}
     */
    NATIVETYPES: {
        'string': true,
        'number': true,
        'boolean': true
    },

    /**
     * Holds the default variables that Postman supports.
     *
     * @type {Object}
     */
    DEFAULT_VARS: {},

    /**
     * Create an instance of a substitutor or reuse one
     *
     * @param {Array|Substitutor} variables
     * @param {Object=} defaults An object containing default variables to substitute
     * @returns {Substitutor}
     */
    box: function (variables, defaults) {
        return (variables instanceof Substitutor) ? variables : new Substitutor(variables, defaults);
    },

    /**
     * Checks whether a variable is instance of substitutor
     *
     * @param {*} subject
     * @returns {Boolean}
     */
    isInstance: function (subject) {
        return (subject instanceof Substitutor);
    },

    /**
     * Get an instance of a function that is useful to be passed to a string replace function for extracting tokens
     * and replacing by substitutions
     *
     * @private
     * @param {Substitutor} substitutor
     * @returns {Function}
     */
    replacer: function (substitutor) {
        return function (match, token) {
            var r = substitutor.find(token);
            r && _.isFunction(r) && (r = r());
            r && _.isFunction(r.toString) && (r = r.toString());
            return Substitutor.NATIVETYPES[(typeof r)] ? r : match;
        };
    }
});

// @todo make the default variales of SuperString extensible and do this anywhere else but here
_.forOwn(dynamicVariables, function (variable, name) {
    if (variable && _.isFunction(variable.generator)) {
        Substitutor.DEFAULT_VARS[name] = variable.generator;
    }
});

module.exports = {
    SuperString: SuperString,
    Substitutor: Substitutor
};


/***/ }),

/***/ 5306:
/***/ (function(module, exports, __webpack_require__) {

var faker = __webpack_require__(1075),
    uuid = __webpack_require__(145),

    // locale list generated from: https://github.com/chromium/chromium/blob/master/ui/base/l10n/l10n_util.cc
    LOCALES = ['af', 'am', 'an', 'ar', 'ast', 'az', 'be', 'bg', 'bh', 'bn', 'br', 'bs', 'ca', 'ceb', 'ckb', 'co', 'cs',
        'cy', 'da', 'de', 'el', 'en', 'eo', 'es', 'et', 'eu', 'fa', 'fi', 'fil', 'fo', 'fr', 'fy', 'ga', 'gd', 'gl',
        'gn', 'gu', 'ha', 'haw', 'he', 'hi', 'hmn', 'hr', 'ht', 'hu', 'hy', 'ia', 'id', 'ig', 'is', 'it', 'ja', 'jv',
        'ka', 'kk', 'km', 'kn', 'ko', 'ku', 'ky', 'la', 'lb', 'ln', 'lo', 'lt', 'lv', 'mg', 'mi', 'mk', 'ml', 'mn',
        'mo', 'mr', 'ms', 'mt', 'my', 'nb', 'ne', 'nl', 'nn', 'no', 'ny', 'oc', 'om', 'or', 'pa', 'pl', 'ps', 'pt',
        'qu', 'rm', 'ro', 'ru', 'sd', 'sh', 'si', 'sk', 'sl', 'sm', 'sn', 'so', 'sq', 'sr', 'st', 'su', 'sv', 'sw',
        'ta', 'te', 'tg', 'th', 'ti', 'tk', 'to', 'tr', 'tt', 'tw', 'ug', 'uk', 'ur', 'uz', 'vi', 'wa', 'xh', 'yi',
        'yo', 'zh', 'zu'],

    // paths for directories
    DIRECTORY_PATHS = [
        '/Applications',
        '/bin',
        '/boot',
        '/boot/defaults',
        '/dev',
        '/etc',
        '/etc/defaults',
        '/etc/mail',
        '/etc/namedb',
        '/etc/periodic',
        '/etc/ppp',
        '/home',
        '/home/user',
        '/home/user/dir',
        '/lib',
        '/Library',
        '/lost+found',
        '/media',
        '/mnt',
        '/net',
        '/Network',
        '/opt',
        '/opt/bin',
        '/opt/include',
        '/opt/lib',
        '/opt/sbin',
        '/opt/share',
        '/private',
        '/private/tmp',
        '/private/var',
        '/proc',
        '/rescue',
        '/root',
        '/sbin',
        '/selinux',
        '/srv',
        '/sys',
        '/System',
        '/tmp',
        '/Users',
        '/usr',
        '/usr/X11R6',
        '/usr/bin',
        '/usr/include',
        '/usr/lib',
        '/usr/libdata',
        '/usr/libexec',
        '/usr/local/bin',
        '/usr/local/src',
        '/usr/obj',
        '/usr/ports',
        '/usr/sbin',
        '/usr/share',
        '/usr/src',
        '/var',
        '/var/log',
        '/var/mail',
        '/var/spool',
        '/var/tmp',
        '/var/yp'
    ],

    // generators for $random* variables
    dynamicGenerators = {
        $guid: {
            description: 'A v4 style guid',
            generator: function () {
                return uuid.v4();
            }
        },

        $timestamp: {
            description: 'The current timestamp',
            generator: function () {
                return Math.round(Date.now() / 1000);
            }
        },

        $randomInt: {
            description: 'A random integer between 1 and 1000',
            generator: function () {
                return ~~(Math.random() * (1000 + 1));
            }
        },

        // faker.phone.phoneNumber returns phone number with or without
        // extension randomly. this only returns a phone number without extension.
        $randomPhoneNumber: {
            description: 'A random 10-digit phone number',
            generator: function () {
                return faker.phone.phoneNumberFormat(0);
            }
        },

        // faker.phone.phoneNumber returns phone number with or without
        // extension randomly. this only returns a phone number with extension.
        $randomPhoneNumberExt: {
            description: 'A random phone number with extension (12 digits)',
            generator: function () {
                return faker.random.number({ min: 1, max: 99 }) + '-' + faker.phone.phoneNumberFormat(0);
            }
        },

        // faker's random.locale only returns 'en'. this returns from a list of
        // random locales
        $randomLocale: {
            description: 'A random two-letter language code (ISO 639-1)',
            generator: function () {
                return faker.random.arrayElement(LOCALES);
            }
        },

        // fakers' random.words returns random number of words between 1, 3.
        // this returns number of words between 2, 5.
        $randomWords: {
            description: 'Some random words',
            generator: function () {
                var words = [],
                    count = faker.random.number({ min: 2, max: 5 }),
                    i;

                for (i = 0; i < count; i++) {
                    words.push(faker.random.word());
                }

                return words.join(' ');
            }
        },

        // faker's system.filePath retuns nothing. this returns a path for a file.
        $randomFilePath: {
            description: 'A random file path',
            generator: function () {
                return dynamicGenerators.$randomDirectoryPath.generator() + '/' + faker.system.fileName();
            }
        },

        // faker's system.directoryPath retuns nothing. this returns a path for
        // a directory.
        $randomDirectoryPath: {
            description: 'A random directory path',
            generator: function () {
                return faker.random.arrayElement(DIRECTORY_PATHS);
            }
        },

        $randomCity: {
            description: 'A random city name',
            generator: faker.address.city
        },
        $randomStreetName: {
            description: 'A random street name',
            generator: faker.address.streetName
        },
        $randomStreetAddress: {
            description: 'A random street address (e.g. 1234 Main Street)',
            generator: faker.address.streetAddress
        },
        $randomCountry: {
            description: 'A random country',
            generator: faker.address.country
        },
        $randomCountryCode: {
            description: 'A random 2-letter country code (ISO 3166-1 alpha-2)',
            generator: faker.address.countryCode
        },
        $randomLatitude: {
            description: 'A random latitude coordinate',
            generator: faker.address.latitude
        },
        $randomLongitude: {
            description: 'A random longitude coordinate',
            generator: faker.address.longitude
        },

        $randomColor: {
            description: 'A random color',
            generator: faker.commerce.color
        },
        $randomDepartment: {
            description: 'A random commerce category (e.g. electronics, clothing)',
            generator: faker.commerce.department
        },
        $randomProductName: {
            description: 'A random product name (e.g. handmade concrete tuna)',
            generator: faker.commerce.productName
        },
        $randomProductAdjective: {
            description: 'A random product adjective (e.g. tasty, eco-friendly)',
            generator: faker.commerce.productAdjective
        },
        $randomProductMaterial: {
            description: 'A random product material (e.g. steel, plastic, leather)',
            generator: faker.commerce.productMaterial
        },
        $randomProduct: {
            description: 'A random product (e.g. shoes, table, chair)',
            generator: faker.commerce.product
        },

        $randomCompanyName: {
            description: 'A random company name',
            generator: faker.company.companyName
        },
        $randomCompanySuffix: {
            description: 'A random company suffix (e.g. Inc, LLC, Group)',
            generator: faker.company.companySuffix
        },
        $randomCatchPhrase: {
            description: 'A random catchphrase',
            generator: faker.company.catchPhrase
        },
        $randomBs: {
            description: 'A random phrase of business speak',
            generator: faker.company.bs
        },
        $randomCatchPhraseAdjective: {
            description: 'A random catchphrase adjective',
            generator: faker.company.catchPhraseAdjective
        },
        $randomCatchPhraseDescriptor: {
            description: 'A random catchphrase descriptor',
            generator: faker.company.catchPhraseDescriptor
        },
        $randomCatchPhraseNoun: {
            description: 'Randomly generates a catchphrase noun',
            generator: faker.company.catchPhraseNoun
        },
        $randomBsAdjective: {
            description: 'A random business speak adjective',
            generator: faker.company.bsAdjective
        },
        $randomBsBuzz: {
            description: 'A random business speak buzzword',
            generator: faker.company.bsBuzz
        },
        $randomBsNoun: {
            description: 'A random business speak noun',
            generator: faker.company.bsNoun
        },

        $randomDatabaseColumn: {
            description: 'A random database column name (e.g. updatedAt, token, group)',
            generator: faker.database.column
        },
        $randomDatabaseType: {
            description: 'A random database type (e.g. tiny int, double, point)',
            generator: faker.database.type
        },
        $randomDatabaseCollation: {
            description: 'A random database collation (e.g. cp1250_bin)',
            generator: faker.database.collation
        },
        $randomDatabaseEngine: {
            description: 'A random database engine (e.g. Memory, Archive, InnoDB)',
            generator: faker.database.engine
        },

        $randomDatePast: {
            description: 'A random past datetime',
            generator: faker.date.past
        },
        $randomDateFuture: {
            description: 'A random future datetime',
            generator: faker.date.future
        },
        $randomDateRecent: {
            description: 'A random recent datetime',
            generator: faker.date.recent
        },
        $randomMonth: {
            description: 'A random month',
            generator: faker.date.month
        },
        $randomWeekday: {
            description: 'A random weekday',
            generator: faker.date.weekday
        },

        $randomBankAccount: {
            description: 'A random 8-digit bank account number',
            generator: faker.finance.account
        },
        $randomBankAccountName: {
            description: 'A random bank account name (e.g. savings account, checking account)',
            generator: faker.finance.accountName
        },
        $randomCreditCardMask: {
            description: 'A random masked credit card number',
            generator: faker.finance.mask
        },
        $randomPrice: {
            description: 'A random price between 100.00 and 999.00',
            generator: faker.finance.amount
        },
        $randomTransactionType: {
            description: 'A random transaction type (e.g. invoice, payment, deposit)',
            generator: faker.finance.transactionType
        },
        $randomCurrencyCode: {
            description: 'A random 3-letter currency code (ISO-4217)',
            generator: faker.finance.currencyCode
        },
        $randomCurrencyName: {
            description: 'A random currency name',
            generator: faker.finance.currencyName
        },
        $randomCurrencySymbol: {
            description: 'A random currency symbol',
            generator: faker.finance.currencySymbol
        },
        $randomBitcoin: {
            description: 'A random bitcoin address',
            generator: faker.finance.bitcoinAddress
        },
        $randomBankAccountIban: {
            description: 'A random 15-31 character IBAN (International Bank Account Number)',
            generator: faker.finance.iban
        },
        $randomBankAccountBic: {
            description: 'A random BIC (Bank Identifier Code)',
            generator: faker.finance.bic
        },

        $randomAbbreviation: {
            description: 'A random abbreviation',
            generator: faker.hacker.abbreviation
        },
        $randomAdjective: {
            description: 'A random adjective',
            generator: faker.hacker.adjective
        },
        $randomNoun: {
            description: 'A random noun',
            generator: faker.hacker.noun
        },
        $randomVerb: {
            description: 'A random verb',
            generator: faker.hacker.verb
        },
        $randomIngverb: {
            description: 'A random verb ending in -ing',
            generator: faker.hacker.ingverb
        },
        $randomPhrase: {
            description: 'A random phrase',
            generator: faker.hacker.phrase
        },

        $randomAvatarImage: {
            description: 'A random avatar image',
            generator: faker.image.avatar
        },
        $randomImageUrl: {
            description: 'A URL for a random image',
            generator: faker.image.imageUrl
        },
        $randomAbstractImage: {
            description: 'A URL for a random abstract image',
            generator: faker.image.abstract
        },
        $randomAnimalsImage: {
            description: 'A URL for a random animal image',
            generator: faker.image.animals
        },
        $randomBusinessImage: {
            description: 'A URL for a random stock business image',
            generator: faker.image.business
        },
        $randomCatsImage: {
            description: 'A URL for a random cat image',
            generator: faker.image.cats
        },
        $randomCityImage: {
            description: 'A URL for a random city image',
            generator: faker.image.city
        },
        $randomFoodImage: {
            description: 'A URL for a random food image',
            generator: faker.image.food
        },
        $randomNightlifeImage: {
            description: 'A URL for a random nightlife image',
            generator: faker.image.nightlife
        },
        $randomFashionImage: {
            description: 'A URL for a random fashion image',
            generator: faker.image.fashion
        },
        $randomPeopleImage: {
            description: 'A URL for a random image of a person',
            generator: faker.image.people
        },
        $randomNatureImage: {
            description: 'A URL for a random nature image',
            generator: faker.image.nature
        },
        $randomSportsImage: {
            description: 'A URL for a random sports image',
            generator: faker.image.sports
        },
        $randomTransportImage: {
            description: 'A URL for a random transportation image',
            generator: faker.image.transport
        },
        $randomImageDataUri: {
            description: 'A random image data URI',
            generator: faker.image.dataUri
        },

        $randomEmail: {
            description: 'A random email address',
            generator: faker.internet.email
        },
        $randomExampleEmail: {
            description: 'A random email address from an example domain (e.g. ben@example.com)',
            generator: faker.internet.exampleEmail
        },
        $randomUserName: {
            description: 'A random username',
            generator: faker.internet.userName
        },
        $randomProtocol: {
            description: 'A random internet protocol',
            generator: faker.internet.protocol
        },
        $randomUrl: {
            description: 'A random URL',
            generator: faker.internet.url
        },
        $randomDomainName: {
            description: 'A random domain name (e.g. gracie.biz, trevor.info)',
            generator: faker.internet.domainName
        },
        $randomDomainSuffix: {
            description: 'A random domain suffix (e.g. .com, .net, .org)',
            generator: faker.internet.domainSuffix
        },
        $randomDomainWord: {
            description: 'A random unqualified domain name (a name with no dots)',
            generator: faker.internet.domainWord
        },
        $randomIP: {
            description: 'A random IPv4 address',
            generator: faker.internet.ip
        },
        $randomIPV6: {
            description: 'A random IPv6 address',
            generator: faker.internet.ipv6
        },
        $randomUserAgent: {
            description: 'A random user agent',
            generator: faker.internet.userAgent
        },
        $randomHexColor: {
            description: 'A random hex value',
            generator: faker.internet.color
        },
        $randomMACAddress: {
            description: 'A random MAC address',
            generator: faker.internet.mac
        },
        $randomPassword: {
            description: 'A random 15-character alpha-numeric password',
            generator: faker.internet.password
        },

        $randomLoremWord: {
            description: 'A random word of lorem ipsum text',
            generator: faker.lorem.word
        },
        $randomLoremWords: {
            description: 'Some random words of lorem ipsum text',
            generator: faker.lorem.words
        },
        $randomLoremSentence: {
            description: 'A random sentence of lorem ipsum text',
            generator: faker.lorem.sentence
        },
        $randomLoremSlug: {
            description: 'A random lorem ipsum URL slug',
            generator: faker.lorem.slug
        },
        $randomLoremSentences: {
            description: 'A random 2-6 sentences of lorem ipsum text',
            generator: faker.lorem.sentences
        },
        $randomLoremParagraph: {
            description: 'A random paragraph of lorem ipsum text',
            generator: faker.lorem.paragraph
        },
        $randomLoremParagraphs: {
            description: '3 random paragraphs of lorem ipsum text',
            generator: faker.lorem.paragraphs
        },
        $randomLoremText: {
            description: 'A random amount of lorem ipsum text',
            generator: faker.lorem.text
        },
        $randomLoremLines: {
            description: '1-5 random lines of lorem ipsum',
            generator: faker.lorem.lines
        },

        $randomFirstName: {
            description: 'A random first name',
            generator: faker.name.firstName
        },
        $randomLastName: {
            description: 'A random last name',
            generator: faker.name.lastName
        },
        $randomFullName: {
            description: 'A random first and last name',
            generator: faker.name.findName
        },
        $randomJobTitle: {
            description: 'A random job title (e.g. senior software developer)',
            generator: faker.name.jobTitle
        },
        $randomNamePrefix: {
            description: 'A random name prefix (e.g. Mr., Mrs., Dr.)',
            generator: faker.name.prefix
        },
        $randomNameSuffix: {
            description: 'A random name suffix (e.g. Jr., MD, PhD)',
            generator: faker.name.suffix
        },
        $randomJobDescriptor: {
            description: 'A random job descriptor (e.g., senior, chief, corporate, etc.)',
            generator: faker.name.jobDescriptor
        },
        $randomJobArea: {
            description: 'A random job area (e.g. branding, functionality, usability)',
            generator: faker.name.jobArea
        },
        $randomJobType: {
            description: 'A random job type (e.g. supervisor, manager, coordinator, etc.)',
            generator: faker.name.jobType
        },

        $randomUUID: {
            description: 'A random 36-character UUID',
            generator: faker.random.uuid
        },
        $randomBoolean: {
            description: 'A random boolean value (true/false)',
            generator: faker.random.boolean
        },
        $randomWord: {
            description: 'A random word',
            generator: faker.random.word
        },
        $randomAlphaNumeric: {
            description: 'A random alpha-numeric character',
            generator: faker.random.alphaNumeric
        },

        $randomFileName: {
            description: 'A random file name (includes uncommon extensions)',
            generator: faker.system.fileName
        },
        $randomCommonFileName: {
            description: 'A random file name',
            generator: faker.system.commonFileName
        },
        $randomMimeType: {
            description: 'A random MIME type',
            generator: faker.system.mimeType
        },
        $randomCommonFileType: {
            description: 'A random, common file type (e.g., video, text, image, etc.)',
            generator: faker.system.commonFileType
        },
        $randomCommonFileExt: {
            description: 'A random, common file extension (.doc, .jpg, etc.)',
            generator: faker.system.commonFileExt
        },
        $randomFileType: {
            description: 'A random file type (includes uncommon file types)',
            generator: faker.system.fileType
        },
        $randomFileExt: {
            description: 'A random file extension (includes uncommon extensions)',
            generator: faker.system.fileExt
        },
        $randomSemver: {
            description: 'A random semantic version number',
            generator: faker.system.semver
        }
    };

module.exports = dynamicGenerators;


/***/ }),

/***/ 5307:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var url = __webpack_require__(81),

    /**
     * @private
     * @const
     * @type {String}
     */
    E = '',

    /**
     * @private
     * @const
     * @type {String}
     */
    QUERY_SEPARATOR = '?',

    /**
     * @private
     * @const
     * @type {String}
     */
    AMPERSAND = '&',

    /**
     * @private
     * @const
     * @type {String}
     */
    EQUALS = '=',

    /**
     * @private
     * @const
     * @type {String}
     */
    PERCENT = '%',

    /**
     * @private
     * @const
     * @type {string}
     */
    ZERO = '0',

    /**
     * @private
     * @const
     * @type {string}
     */
    STRING = 'string',

    parseQueryString,
    stringifyQueryParams,
    encoder;

/**
 * Parses a query string into an array, preserving parameter values
 * Note: This function is temporary. It will be removed once we implement our own encoding
 *       instead of url.parse().
 *
 * @param string
 * @returns {*}
 */
parseQueryString = function (string) {
    var parts;

    if (typeof string === STRING) {
        parts = string.split(AMPERSAND);

        return parts.map(function (param, idx) {
            if (param === E && idx !== (parts.length - 1)) {
                return { key: null, value: null };
            }

            var index = (typeof param === STRING) ? param.indexOf(EQUALS) : -1,
                paramObj = {};

            // this means that there was no value for this key (not even blank, so we store this info) and the value is set
            // to null
            if (index < 0) {
                paramObj.key = param.substr(0, param.length);
                paramObj.value = null;
            } else {
                paramObj.key = param.substr(0, index);
                paramObj.value = param.substr(index + 1);
            }

            return paramObj;
        });
    }

    return [];
};

/**
 * Stringifies a query string, from an array of parameters
 * Note: This function is temporary. It will be removed once we implement our own encoding
 *       instead of url.parse().
 *
 * @param parameters
 * @returns {string}
 */
stringifyQueryParams = function (parameters) {
    return parameters ? parameters.map(function (param) {
            var key = param.key;
            var value = param.value;

            if (value === undefined) {
                return E;
            }

            if (key === null) {
                key = E;
            }

            if (value === null) {
                return encoder.encode(key);
            }

            return encoder.encode(key) + EQUALS + encoder.encode(value);
        }).join(AMPERSAND) : E;
};

encoder = {

    /**
     * Percent encode a character with given code.
     *
     * @param {Number} c - character code of the character to encode
     * @returns {String} - percent encoding of given character
     */
    percentEncode: function(c) {
        var hex = c.toString(16).toUpperCase();
        (hex.length === 1) && (hex = ZERO + hex);
        return PERCENT + hex;
    },

    /**
     * Checks if character at given index in the buffer is already percent encoded or not.
     *
     * @param {Buffer} buffer
     * @param {Number} i
     * @returns {Boolean}
     */
    isPreEncoded: function(buffer, i) {
        // If it is % check next two bytes for percent encode characters
        // looking for pattern %00 - %FF
        return (buffer[i] === 0x25 &&
            (encoder.isPreEncodedCharacter(buffer[i + 1]) &&
            encoder.isPreEncodedCharacter(buffer[i + 2]))
          );
    },

    /**
     * Checks if character with given code is valid hexadecimal digit or not.
     *
     * @param {Number} byte
     * @returns {Boolean}
     */
    isPreEncodedCharacter: function(byte) {
        return (byte >= 0x30 && byte <= 0x39) ||  // 0-9
           (byte >= 0x41 && byte <= 0x46) ||  // A-F
           (byte >= 0x61 && byte <= 0x66);     // a-f
    },

    /**
     * Checks whether given character should be percent encoded or not for fixture.
     *
     * @param {Number} byte
     * @returns {Boolean}
     */
    charactersToPercentEncode: function(byte) {
        return (byte < 0x23 || byte > 0x7E || // Below # and after ~
            byte === 0x3C || byte === 0x3E || // > and <
            byte === 0x28 || byte === 0x29 || // ( and )
            byte === 0x25 || // %
            byte === 0x27 || // '
            byte === 0x2A    // *
        );
    },

    /**
     * Percent encode a query string according to RFC 3986.
     * Note: This function is supposed to be used on top of node's inbuilt url encoding
     *       to solve issue https://github.com/nodejs/node/issues/8321
     *
     * @param {String} value
     * @returns {String}
     */
    encode: function (value) {
        if (!value) { return E; }

        var buffer = Buffer.from(value),
            ret = E,
            i,
            ii;

        for (i = 0, ii = buffer.length; i < ii; ++i) {

            if (encoder.charactersToPercentEncode(buffer[i]) && !encoder.isPreEncoded(buffer, i)) {
                ret += encoder.percentEncode(buffer[i]);
            }
            else {
                ret += String.fromCodePoint(buffer[i]);  // Only works in ES6 (available in Node v4+)
            }
        }

        return ret;
    },

    /**
     * Converts URL string into Node's Url object with encoded values
     *
     * @param {String} url
     * @returns {Url}
     */
    toNodeUrl: function (urlString) {
        var parsed = url.parse(urlString),
            rawQs = parsed.query,
            qs,
            search,
            path,
            str;

        if (!(rawQs && rawQs.length)) { return parsed; }

        qs = stringifyQueryParams(parseQueryString(rawQs));
        search = QUERY_SEPARATOR + qs;
        path = parsed.pathname + search;

        parsed.query = qs;
        parsed.search = search;
        parsed.path = path;

        str = url.format(parsed);

        // Parse again, because Node does not guarantee consistency of properties
        return url.parse(str);
    }
};

module.exports = encoder;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))

/***/ }),

/***/ 5308:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    Url = __webpack_require__(3837).Url,
    Certificate = __webpack_require__(4087).Certificate,

    CertificateList;

_.inherit((

    /**
     * @constructor
     * @extends {PropertyList}
     *
     * @param {Object} parent
     * @param {Array} list - The list of certificate representations
     *
     * @example <caption>Create a new CertificateList</caption>
     * var CertificateList = require('postman-collection').CertificateList,
     *    certificateList = new CertificateList({}, [
     *        {
     *            name: 'my certificate for example.com',
     *            matches: ['https://example.com/*'],
     *            key: { src: '/path/to/key/file' },
     *            cert: { src: '/path/to/certificate/file' }
     *        },
     *        {
     *            name: 'my certificate for example2.com',
     *            matches: ['https://example2.com/*'],
     *            key: { src: '/path/to/key/file' },
     *            cert: { src: '/path/to/key/file' }
     *        }
     * ]);
     */
    CertificateList = function (parent, list) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        CertificateList.super_.call(this, Certificate, parent, list);
    }), PropertyList);

_.assign(CertificateList.prototype, /** @lends CertificateList.prototype */ {
    /**
     * Matches the given url against the member certificates' allowed matches
     * and returns the certificate that can be used for the url.
     *
     * @param {String} url The url to find the certificate for
     * @return {Certificate~definition=} The matched certificate
     */
    resolveOne: function (url) {
        // url must be either string or an instance of url.
        if (!_.isString(url) && !Url.isUrl(url)) {
            return;
        }

        // find a certificate that can be applied to the url
        return this.find(function (certificate) {
            return certificate.canApplyTo(url);
        });
    }
});

_.assign(CertificateList, /** @lends CertificateList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'CertificateList',

    /**
     * Checks if the given object is a CertificateList
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isCertificateList: function (obj) {
        return Boolean(obj) && ((obj instanceof CertificateList) ||
          _.inSuperChain(obj.constructor, '_postman_propertyName', CertificateList._postman_propertyName));
    }
});

module.exports = {
    CertificateList: CertificateList
};


/***/ }),

/***/ 5309:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    ItemGroup = __webpack_require__(4362).ItemGroup,
    VariableList = __webpack_require__(3921).VariableList,
    Version = __webpack_require__(4371).Version,

    Collection, // constructor

    SCHEMA_URL = 'https://schema.getpostman.com/json/collection/v2.1.0/collection.json';

/**
 * The following is the object structure accepted as constructor parameter while calling `new Collection(...)`. It is
 * also the structure exported when {@link Property#toJSON} or {@link Property#toObjectResolved} is called on a
 * collection instance.
 * @typedef Collection~definition
 *
 * @property {Object=} [info] The meta information regarding the collection is provided as the `info` object.
 * @property {String=} [info.id] Every collection is identified by the unique value of this property. It is recommended
 * that you maintain the same id since changing the id usually implies that is a different collection than it was
 * originally.
 * @property {String=} [info.name] A collection's friendly name is defined by this property. You would want to set this
 * field to a value that would allow you to easily identify this collection among a bunch of other collections.
 * @property {String=} [info.version] Postman allows you to version your collections as they grow, and this field holds
 * the version number. While optional, it is recommended that you use this field to its fullest extent.
 * @property {Array<(Item~definition|ItemGroup~definition)>} [item] Items are the basic unit for a Postman collection.
 * You can think of them as corresponding to a single API endpoint. Each Item has one request and may have multiple API
 * responses associated with it.
 * @property {Variable~definition=} [variable] Collection variables allow you to define a set of variables,
 * that are a *part of the collection*, as opposed to environments, which are separate entities.
 * @property {RequestAuth~definition=} [auth] Collection auth allows you to define an authentication,
 * that *applies to all items* in the collection.
 * @property {Array<Event~definition>=} [event] Postman allows you to configure scripts to run when specific events
 * occur.
 * @property {String|Version~definition=} [version] Version of the collection expressed in [semver](http://semver.org/)
 * format.
 *
 * @see {ItemGroup~definition} - Since `Collection` inherits {@link ItemGroup}, the properties supported by ItemGroup
 * are applicable as well.
 *
 * @example <caption>JSON definition of an example collection</caption>
 * {
 *     "info": {
 *         "name": "My Postman Collection",
 *         "version": "1.0.0"
 *     }
 *     "item": [{
 *         "request": "{{base-url}}/get"
 *     }],
 *     "variables": [{
 *         "id": "base-url",
 *         "value": "https://postman-echo.com"
 *     }]
 * }
 */
_.inherit((

    /**
     * Create or load an instance of [Postman Collection](https://www.getpostman.com/docs/collections) as a JavaScript
     * object that can be manipulated easily.
     *
     * A collection lets you group individual requests together. These requests can be further organized into folders to
     * accurately mirror your API. Requests can also store sample responses when saved in a collection. You can add
     * metadata like name and description too so that all the information that a developer needs to use your API is
     * available easily.
     *
     * @constructor
     * @extends {ItemGroup}
     *
     * @param {Collection~definition=} [definition] - Pass the initial definition of the collection (name, id, etc) as
     * the `definition` parameter. The definition object is structured exactly as the collection format as defined in
     * [https://www.schema.getpostman.com/](https://www.schema.getpostman.com/). This parameter is optional. That
     * implies that you can create an empty instance of collection and add requests and other properties in order to
     * build a new collection.
     * @param {Array<Object>=} [environments] - The collection instance constructor accepts the second parameter as an
     * array of environment objects. Environments objects store variable definitions that are inherited by
     * {@link Collection#variables}. These environment variables are usually the ones that are exported from the Postman
     * App to use them with different collections. Refer to Postman
     * [documentation on environment variables](https://www.getpostman.com/docs/environments).
     *
     * @example <caption>Load a Collection JSON file from disk</caption>
     * var fs = require('fs'), // needed to read JSON file from disk
     *     pretty = function (obj) { // function to neatly log the collection object to console
     *         return require('util').inspect(obj, {colors: true});
     *     },
     *     Collection = require('postman-collection').Collection,
     *     myCollection;
     *
     * // Load a collection to memory from a JSON file on disk (say, sample-collection.json)
     * myCollection = new Collection(JSON.stringify(fs.readFileSync('sample-collection.json').toString()));
     *
     * // log items at root level of the collection
     * console.log(pretty(myCollection));
     *
     * @example <caption>Create a blank collection and write to file</caption>
     * var fs = require('fs'),
     *     Collection = require('postman-collection').Collection,
     *     mycollection;
     *
     * myCollection = new Collection({
     *     info: {
     *         name: "my Collection"
     *     }
     * });
     *
     * // log the collection to console to see its contents
     * fs.writeFileSync('myCollection.postman_collection', JSON.stringify(myCollection, null, 2));
     */
    Collection = function PostmanCollection (definition, environments) {
        // this constructor is intended to inherit and as such the super constructor is required to be executed
        Collection.super_.call(this, definition);

        _.assign(this, /** @lends Collection.prototype */ {
            /**
             * The `variables` property holds a list of variables that are associated with a Collection. These variables
             * are stored within a collection so that they can be re-used and replaced in rest of the collection. For
             * example, if one has a variable named `port` with value `8080`, then one can write a request {@link Url}
             * as `http://localhost:{{port}}/my/endpoint` and that will be replaced to form
             * `http://localhost:8080/my/endpoint`. **Collection Variables** are like
             * [environment variables](https://www.getpostman.com/docs/environments), but stored locally within a
             * collection.
             *
             * @type {VariableList}
             *
             * @example <caption>Creating a collection with variables</caption>
             * var fs = require('fs'),
             *     Collection = require('postman-collection').Collection,
             *     mycollection;
             *
             * // Create a new empty collection.
             * myCollection = new Collection();
             *
             * // Add a variable to the collection
             * myCollection.variables.add({
             *     id: 'apiBaseUrl',
             *     value: 'http://timeapi.org',
             *     type: 'string'
             * });
             *
             * //Add a request that uses the variable that we just added.
             * myCollection.items.add({
             *     id: 'utc-time-now',
             *     name: 'Get the current time in UTC',
             *     request: '{{apiBaseUrl}}/utc/now'
             * });
             */
            variables: new VariableList(this, definition && definition.variable, environments),

            /**
             * The `version` key in collection is used to express the version of the collection. It is useful in either
             * tracking development iteration of an API server or the version of an API itself. It can also be used to
             * represent the number of iterations of the collection as it is updated through its lifetime.
             *
             * Version is expressed in [semver](http://semver.org/) format.
             *
             * @type {Version}
             * @optional
             *
             * @see {@link http://semver.org/}
             */
            version: (definition && definition.info && definition.info.version) ?
                new Version(definition.info.version) : undefined
        });
    }), ItemGroup);

_.assign(Collection.prototype, /** @lends Collection.prototype */ {
    /**
     * Using this function, one can sync the values of collection variables from a reference object.
     *
     * @param {Object} obj
     * @param {Boolean=} [track]
     *
     * @returns {Object}
     */
    syncVariablesFrom: function (obj, track) {
        return this.variables.syncFromObject(obj, track);
    },

    /**
     * Transfer the variables in this scope to an object
     *
     * @param {Object=} [obj]
     *
     * @returns {Object}
     */
    syncVariablesTo: function (obj) {
        return this.variables.syncToObject(obj);
    },

    /**
     * Convert the collection to JSON compatible plain object
     *
     * @returns {Object}
     */
    toJSON: function () {
        var json = ItemGroup.prototype.toJSON.apply(this);

        // move ids and stuff from root level to `info` object
        json.info = {
            _postman_id: this.id,
            name: this.name,
            version: this.version,
            schema: SCHEMA_URL
        };

        delete json.id;
        delete json.name;
        delete json.version;

        if (json.hasOwnProperty('description')) {
            json.info.description = this.description;
            delete json.description;
        }

        return json;
    }
});

_.assign(Collection, /** @lends Collection */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyName: 'Collection',

    /**
     * Check whether an object is an instance of {@link ItemGroup}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isCollection: function (obj) {
        return Boolean(obj) && ((obj instanceof Collection) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', Collection._postman_propertyName));
    }
});

module.exports = {
    Collection: Collection
};


/***/ }),

/***/ 5310:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {var util = __webpack_require__(3767),
    _ = util.lodash,
    fileType = __webpack_require__(600),
    mimeType = __webpack_require__(1069),
    mimeFormat = __webpack_require__(601),

    /**
     * @private
     * @const
     * @type {String}
     */
    E = '',

    /**
     * @private
     * @const
     * @type {String}
     */
    DOT = '.',

    /**
     * @private
     * @const
     * @type {String}
     */
    QUESTION_MARK = '?',

    /**
     * @private
     * @const
     * @type {String}
     */
    DOUBLE_QUOTES = '"',

    /**
     * @private
     * @const
     * @type {String}
     */
    TOKEN_$1 = '$1',

    /**
     * @private
     * @const
     * @type {String}
     */
    BINARY = 'binary',

    /**
     * @private
     * @const
     * @type {String}
     */
    CHARSET_UTF8 = 'utf8',

    /**
     * @private
     * @const
     * @type {String}
     */
    CONTENT_TYPE_TEXT_PLAIN = 'text/plain',

    /**
     * Enum for all the Content Headers
     * @private
     * @const
     * @enum {String} HEADERS
     */
    HEADERS = {
        CONTENT_TYPE: 'Content-Type',
        CONTENT_DISPOSITION: 'Content-Disposition'
    },

    /**
     * @private
     * @const
     * @type {String}
     */
    DEFAULT_RESPONSE_FILENAME = 'response',

    /**
     * @private
     * @type {Boolean}
     */
    supportsBuffer = (typeof Buffer !== undefined) && _.isFunction(Buffer.byteLength),

    /**
     * Regexes for extracting and decoding the filename from content-disposition header
     *
     * @private
     * @type {Object}
     */
    regexes = {

        /**
         * RegExp for extracting filename from content-disposition header
         *
         * RFC 2616 grammar
         * parameter     = token "=" ( token | quoted-string )
         * token         = 1*<any CHAR except CTLs or separators>
         * separators    = "(" | ")" | "<" | ">" | "@"
         *               | "," | ";" | ":" | "\" | <">
         *               | "/" | "[" | "]" | "?" | "="
         *               | "{" | "}" | SP | HT
         * quoted-string = ( <"> *(qdtext | quoted-pair ) <"> )
         * qdtext        = <any TEXT except <">>
         * quoted-pair   = "\" CHAR
         * CHAR          = <any US-ASCII character (octets 0 - 127)>
         * TEXT          = <any OCTET except CTLs, but including LWS>
         * LWS           = [CRLF] 1*( SP | HT )
         * CRLF          = CR LF
         * CR            = <US-ASCII CR, carriage return (13)>
         * LF            = <US-ASCII LF, linefeed (10)>
         * SP            = <US-ASCII SP, space (32)>
         * HT            = <US-ASCII HT, horizontal-tab (9)>
         * CTL           = <any US-ASCII control character (octets 0 - 31) and DEL (127)>
         * OCTET         = <any 8-bit sequence of data>
         *
         * egHeader: inline; filename=testResponse.json
         * egHeader: inline; filename="test Response.json"
         * Reference: https://github.com/jshttp/content-disposition
         */
        // eslint-disable-next-line max-len
        fileNameRegex: /;[ \t]*(?:filename)[ \t]*=[ \t]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[ \t]*/,

        /**
         * RegExp for extracting filename* from content-disposition header
         *
         * RFC 5987 grammar
         * parameter     = reg-parameter / ext-parameter
         * ext-parameter = parmname "*" LWSP "=" LWSP ext-value
         * parmname      = 1*attr-char
         * ext-value     = charset  "'" [ language ] "'" value-chars
                    ; like RFC 2231's <extended-initial-value>
                    ; (see [RFC2231], Section 7)
         * charset       = "UTF-8" / "ISO-8859-1" / mime-charset
         * mime-charset  = 1*mime-charsetc
         * mime-charsetc = ALPHA / DIGIT
                    / "!" / "#" / "$" / "%" / "&"
                    / "+" / "-" / "^" / "_" / "`"
                    / "{" / "}" / "~"
                    ; as <mime-charset> in Section 2.3 of [RFC2978]
                    ; except that the single quote is not included
                    ; SHOULD be registered in the IANA charset registry
         * language      = <Language-Tag, defined in [RFC5646], Section 2.1>
         * value-chars   = *( pct-encoded / attr-char )
         * pct-encoded   = "%" HEXDIG HEXDIG
                    ; see [RFC3986], Section 2.1
         * attr-char     = ALPHA / DIGIT
                    / "!" / "#" / "$" / "&" / "+" / "-" / "."
                    / "^" / "_" / "`" / "|" / "~"
                    ; token except ( "*" / "'" / "%" )
         *
         * egHeader: attachment;filename*=utf-8''%E4%BD%A0%E5%A5%BD.txt
         * Reference: https://github.com/jshttp/content-disposition
         */
        // eslint-disable-next-line max-len
        encodedFileNameRegex: /;[ \t]*(?:filename\*)[ \t]*=[ \t]*([A-Za-z0-9!#$%&+\-^_`{}~]+)'.*'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)[ \t]*/,

        /**
         * RegExp to match quoted-pair in RFC 2616
         *
         * quoted-pair = "\" CHAR
         * CHAR        = <any US-ASCII character (octets 0 - 127)>
         */
        quotedPairRegex: /\\([ -~])/g,

        /**
         * Regex to match all the hexadecimal number inside encoded string
         */
        hexCharMatchRegex: /%([0-9A-Fa-f]{2})/g,

        /**
         * Regex to match non-latin characters
         */
        nonLatinCharMatchRegex: /[^\x20-\x7e\xa0-\xff]/g
    },

    /**
     * Decodes the hexcode to charCode
     *
     * @private
     * @param {String} str - The matched string part of a hexadecimal number
     * @param {String} hex - The hexadecimal string which needs to be converted to charCode
     * @returns {String} - String with decoded hexcode values
     */
    decodeHexcode = function (str, hex) {
        return String.fromCharCode(parseInt(hex, 16));
    },

    /**
     * HashMap for decoding string with supported characterSets
     * iso-8859-1
     * utf-8
     *
     * @private
     * @type {Object}
     */
    characterDecoders = {

        /**
         * Replaces non-latin characters with '?'
         *
         * @private
         * @param {String} val - Input encoded string
         * @returns {String} - String with latin characters
         */
        'iso-8859-1': function (val) {
            return val.replace(regexes.nonLatinCharMatchRegex, QUESTION_MARK);
        },

        /**
         * Decodes the given string with utf-8 character set
         *
         * @private
         * @param {?String} encodedString - Input encoded string
         * @returns {?String} - String with decoded character with utf-8
         */
        'utf-8': function (encodedString) {
            if (!supportsBuffer) {
                return;
            }
            return Buffer.from(encodedString, BINARY).toString(CHARSET_UTF8);
        }
    },

    /**
     * Decodes the given filename with given charset
     * The supported character sets are
     * iso-8859-1
     * utf-8
     *
     * @private
     * @param {String} encodedFileName - Input encoded file name
     * @param {String} charset - The character set to be used while decoding
     * @returns {String} - Returns the decoded filename
     */
    decodeFileName = function (encodedFileName, charset) {
        if (!encodedFileName) {
            return;
        }

        if (!characterDecoders[charset]) {
            return;
        }
        // decodes the hexadecimal numbers to charCode in encodedFileName and then decodes with given charset
        return characterDecoders[charset](encodedFileName.replace(regexes.hexCharMatchRegex, decodeHexcode));
    },

    /**
     * Takes the content-type header value and performs the mime sniffing with known mime types.
     * If content-type header is not present, detects the mime type from the response stream or response body
     * If content-type is not provided and not able to detect, then text/plain is taken as default
     *
     * @private
     * @param {?String} contentType - The value of content type header
     * @param {Stream|String} response - The response stream or body, for which content-info should be determined
     * @returns {Object} - mime information from response headers
     */
    getMimeInfo = function (contentType, response) {
        var normalized,
            detected;

        if (!contentType) {
            detected = fileType(response);
            detected && (contentType = detected.mime);
        }

        // if contentType is not detected set text/plain as default
        if (!contentType) {
            contentType = CONTENT_TYPE_TEXT_PLAIN;
        }

        normalized = mimeFormat.lookup(contentType);

        return {
            mimeType: normalized.type, // sanitised mime type base
            mimeFormat: normalized.format, // format specific to the type returned
            charset: normalized.charset || CHARSET_UTF8,
            extension: mimeType.extension(normalized.source) || E
        };
    },

    /**
     * Parses Content disposition header, and returns file name and extension
     *
     * @private
     * @param {?String} dispositionHeader - Content-disposition Header from the response
     * @returns {?String} - Returns file name from content disposition header if present
     */
    getFileNameFromDispositionHeader = function (dispositionHeader) {
        if (!dispositionHeader) {
            return;
        }

        var encodedFileName,
            fileName;

        // Get filename* value from the dispositionHeader
        encodedFileName = regexes.encodedFileNameRegex.exec(dispositionHeader);

        if (encodedFileName) {
            fileName = decodeFileName(encodedFileName[2], encodedFileName[1]);
        }

        // If filename* is not present or unparseable, then we are checking for filename in header
        if (!fileName) {
            fileName = regexes.fileNameRegex.exec(dispositionHeader);
            fileName && (fileName = fileName[1]);

            // check if file name is wrapped in double quotes
            // file name can contain escaped characters if wrapped in quotes
            if (fileName && fileName[0] === DOUBLE_QUOTES) {
                // remove quotes and escapes
                fileName = fileName
                    .substr(1, fileName.length - 2)
                    .replace(regexes.quotedPairRegex, TOKEN_$1);
            }
        }

        return fileName;
    };


module.exports = {

    /**
     * Extracts content related information from response.
     * Includes response mime information, character set and file name.
     *
     * @private
     * @param {Response} response - response instance
     * @returns {Response~ResponseContentInfo} - Return contentInfo of the response
     */
    contentInfo: function (response) {
        var contentType = response.headers.get(HEADERS.CONTENT_TYPE),
            contentDisposition = response.headers.get(HEADERS.CONTENT_DISPOSITION),
            mimeInfo = getMimeInfo(contentType, response.stream || response.body),
            fileName = getFileNameFromDispositionHeader(contentDisposition),
            fileExtension = mimeInfo.extension,

            /**
             * @typedef Response~ResponseContentInfo
             *
             * @property {String} mimeType sanitized mime type
             * @property {String} mimeFormat format for the identified mime type
             * @property {String} charset the normalized character set
             * @property {String} fileExtension extension identified from the mime type
             * @property {String} fileName file name extracted from disposition header
             */
            contentInfo = {};


        // if file name is not present in the content disposition headers, use a default file name
        if (!fileName) {
            fileName = DEFAULT_RESPONSE_FILENAME;
            // add extension to default if present
            fileExtension && (fileName += (DOT + fileExtension));
        }

        // create a compacted list of content info from mime info and file name
        mimeInfo.mimeType && (contentInfo.mimeType = mimeInfo.mimeType);
        mimeInfo.mimeFormat && (contentInfo.mimeFormat = mimeInfo.mimeFormat);
        mimeInfo.charset && (contentInfo.charset = mimeInfo.charset);
        fileExtension && (contentInfo.fileExtension = fileExtension);
        fileName && (contentInfo.fileName = fileName);

        return contentInfo;
    },
    // regexes are extracted for vulnerability tests
    regexes: regexes
};

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(10).Buffer))

/***/ }),

/***/ 5311:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var t = exports.tokens = {}
var R = 0

function tok (n) {
  t[n] = R++
}

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

tok('NUMERICIDENTIFIER')
src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*'
tok('NUMERICIDENTIFIERLOOSE')
src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

tok('NONNUMERICIDENTIFIER')
src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

tok('MAINVERSION')
src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[t.NUMERICIDENTIFIER] + ')'

tok('MAINVERSIONLOOSE')
src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

tok('PRERELEASEIDENTIFIER')
src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] +
                            '|' + src[t.NONNUMERICIDENTIFIER] + ')'

tok('PRERELEASEIDENTIFIERLOOSE')
src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[t.NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

tok('PRERELEASE')
src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))'

tok('PRERELEASELOOSE')
src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

tok('BUILDIDENTIFIER')
src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

tok('BUILD')
src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] +
             '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

tok('FULL')
tok('FULLPLAIN')
src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] +
                  src[t.PRERELEASE] + '?' +
                  src[t.BUILD] + '?'

src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
tok('LOOSEPLAIN')
src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] +
                  src[t.PRERELEASELOOSE] + '?' +
                  src[t.BUILD] + '?'

tok('LOOSE')
src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$'

tok('GTLT')
src[t.GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
tok('XRANGEIDENTIFIERLOOSE')
src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
tok('XRANGEIDENTIFIER')
src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*'

tok('XRANGEPLAIN')
src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[t.PRERELEASE] + ')?' +
                   src[t.BUILD] + '?' +
                   ')?)?'

tok('XRANGEPLAINLOOSE')
src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[t.PRERELEASELOOSE] + ')?' +
                        src[t.BUILD] + '?' +
                        ')?)?'

tok('XRANGE')
src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$'
tok('XRANGELOOSE')
src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
tok('COERCE')
src[t.COERCE] = '(^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'
tok('COERCERTL')
re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g')

// Tilde ranges.
// Meaning is "reasonably at or greater than"
tok('LONETILDE')
src[t.LONETILDE] = '(?:~>?)'

tok('TILDETRIM')
src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+'
re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

tok('TILDE')
src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$'
tok('TILDELOOSE')
src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
tok('LONECARET')
src[t.LONECARET] = '(?:\\^)'

tok('CARETTRIM')
src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+'
re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g')
var caretTrimReplace = '$1^'

tok('CARET')
src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$'
tok('CARETLOOSE')
src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
tok('COMPARATORLOOSE')
src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$'
tok('COMPARATOR')
src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
tok('COMPARATORTRIM')
src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] +
                      '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
tok('HYPHENRANGE')
src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[t.XRANGEPLAIN] + ')' +
                   '\\s*$'

tok('HYPHENRANGELOOSE')
src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[t.XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
tok('STAR')
src[t.STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[t.LOOSE] : re[t.FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

SemVer.prototype.compareBuild = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  var i = 0
  do {
    var a = this.build[i]
    var b = other.build[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.compareBuild = compareBuild
function compareBuild (a, b, loose) {
  var versionA = new SemVer(a, loose)
  var versionB = new SemVer(b, loose)
  return versionA.compare(versionB) || versionA.compareBuild(versionB)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compareBuild(b, a, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1] !== undefined ? m[1] : ''
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY || version === ANY) {
    return true
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    if (this.value === '') {
      return true
    }
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    if (comp.value === '') {
      return true
    }
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[t.COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[t.TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[t.CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return (
      isSatisfiable(thisComparators, options) &&
      range.set.some(function (rangeComparators) {
        return (
          isSatisfiable(rangeComparators, options) &&
          thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options)
            })
          })
        )
      })
    )
  })
}

// take a set of comparators and determine whether there
// exists a version which can satisfy it
function isSatisfiable (comparators, options) {
  var result = true
  var remainingComparators = comparators.slice()
  var testComparator = remainingComparators.pop()

  while (result && remainingComparators.length) {
    result = remainingComparators.every(function (otherComparator) {
      return testComparator.intersects(otherComparator, options)
    })

    testComparator = remainingComparators.pop()
  }

  return result
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    // if we're including prereleases in the match, then we need
    // to fix this to -0, the lowest possible prerelease value
    pr = options.includePrerelease ? '-0' : ''

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0-0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p + pr
    } else if (xm) {
      ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0' + pr +
        ' <' + M + '.' + (+m + 1) + '.0' + pr
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[t.STAR], '')
}

// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    try {
      version = new SemVer(version, this.options)
    } catch (er) {
      return false
    }
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version, options) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version === 'number') {
    version = String(version)
  }

  if (typeof version !== 'string') {
    return null
  }

  options = options || {}

  var match = null
  if (!options.rtl) {
    match = version.match(re[t.COERCE])
  } else {
    // Find the right-most coercible string that does not share
    // a terminus with a more left-ward coercible string.
    // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
    //
    // Walk through the string checking with a /g regexp
    // Manually set the index so as to pick up overlapping matches.
    // Stop when we get a match that ends at the string end, since no
    // coercible string can be more right-ward without the same terminus.
    var next
    while ((next = re[t.COERCERTL].exec(version)) &&
      (!match || match.index + match[0].length !== version.length)
    ) {
      if (!match ||
          next.index + next[0].length !== match.index + match[0].length) {
        match = next
      }
      re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length
    }
    // leave it in a clean state
    re[t.COERCERTL].lastIndex = -1
  }

  if (match === null) {
    return null
  }

  return parse(match[2] +
    '.' + (match[3] || '0') +
    '.' + (match[4] || '0'), options)
}

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(3)))

/***/ }),

/***/ 5312:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    Property = __webpack_require__(3787).Property,
    PropertyBase = __webpack_require__(3813).PropertyBase,
    VariableList = __webpack_require__(3921).VariableList,
    MutationTracker = __webpack_require__(4372).MutationTracker,

    /**
     * Known variable mutation types.
     *
     * @private
     * @constant
     * @type {Object}
     */
    MUTATIONS = {
        SET: 'set',
        UNSET: 'unset'
    },

    VariableScope;

/**
 * Environment and Globals of postman is exported and imported in a specified data structure. This data structure can be
 * passed on to the constructor parameter of {@link VariableScope} or {@link VariableList} to instantiate an instance of
 * the same with pre-populated values from arguments.
 *
 * @typedef VariableScope~definition
 * @property {String} [id] ID of the scope
 * @property {String} [name] A name of the scope
 * @property {Array.<Variable~definition>} [values] A list of variables defined in an array in form of `{name:String,
 * value:String}`
 *
 * @example <caption>JSON definition of a VariableScope (environment, globals, etc)</caption>
 * {
 *   "name": "globals",
 *   "values": [{
 *     "key": "var-1",
 *     "value": "value-1"
 *   }, {
 *     "key": "var-2",
 *     "value": "value-2"
 *   }]
 * }
 */
_.inherit((

    /**
     * VariableScope is a representation of a list of variables in Postman, such as the environment variables or the
     * globals. Using this object, it is easy to perform operations on this list of variables such as get a variable or
     * set a variable.
     *
     * @constructor
     * @extends {Property}
     *
     * @param {VariableScope~definition} definition The constructor accepts an initial set of values for initialising
     * the scope
     * @param {Array<VariableList>=} layers Additional parent scopes to search for and resolve variables
     *
     * @example <caption>Load a environment from file, modify and save back</caption>
     * var fs = require('fs'), // assuming NodeJS
     *     env,
     *     sum;
     *
     * // load env from file assuming it has initial data
     * env = new VariableScope(JSON.parse(fs.readFileSync('./my-postman-environment.postman_environment').toString()));
     *
     * // get two variables and add them
     * sum = env.get('one-var') + env.get('another-var');
     *
     * // save it back in environment and write to file
     * env.set('sum', sum, 'number');
     * fs.writeFileSync('./sum-of-vars.postman_environment', JSON.stringify(env.toJSON()));
     */
    VariableScope = function PostmanVariableScope (definition, layers) {
        // in case the definition is an array (legacy format) or existing as list, we convert to actual format
        if (_.isArray(definition) || VariableList.isVariableList(definition)) {
            definition = { values: definition };
        }

        // we accept parent scopes to increase search area. Here we normalize the argument to be an array
        // so we can easily loop though them and add them to the instance.
        layers && !_.isArray(layers) && (layers = [layers]);

        // this constructor is intended to inherit and as such the super constructor is required to be executed
        VariableScope.super_.call(this, definition);

        var values = definition && definition.values, // access the values (need this var to reuse access)

            // enable mutation tracking if `mutations` are in definition (restore the state)
            // or is enabled  through options
            mutations = definition && definition.mutations,
            ii,
            i;

        /**
         * @memberOf VariableScope.prototype
         * @type {VariableList}
         */
        this.values = new VariableList(this, VariableList.isVariableList(values) ? values.toJSON() : values);
        // in above line, we clone the values if it is already a list. there is no point directly using the instance of
        // a variable list since one cannot be created with a parent reference to begin with.

        if (layers) {
            this._layers = [];

            for (i = 0, ii = layers.length; i < ii; i++) {
                VariableList.isVariableList(layers[i]) && this._layers.push(layers[i]);
            }
        }

        // restore previously tracked mutations
        if (mutations) {
            this.mutations = new MutationTracker(mutations);
        }
    }), Property);

/**
 * @note Handling disabled and duplicate variables:
 * | method | single enabled    | single disabled | with duplicates                                                    |
 * |--------|-------------------|-----------------|------------------------------------------------------------------- |
 * | has    | true              | false           | true (if last enabled) OR false (if all disabled)                  |
 * | get    | {Variable}        | undefined       | last enabled {Variable} OR undefined (if all disabled)             |
 * | set    | update {Variable} | new {Variable}  | update last enabled {Variable} OR new {Variable} (if all disabled) |
 * | unset  | delete {Variable} | noop            | delete all enabled {Variable}                                      |
 *
 * @todo Expected behavior of `unset` with duplicates:
 * delete last enabled {Variable} and update the reference with last enabled in rest of the list.
 * This requires unique identifier in the variable list for mutations to work correctly.
 */
_.assign(VariableScope.prototype, /** @lends VariableScope.prototype */ {
    /**
     * Defines whether this property instances requires an id
     * @private
     * @readOnly
     * @type {String}
     */
    _postman_propertyRequiresId: true,

    /**
     * @deprecated since v1.2.5.*
     * Get a copy of all variables in form of a plain object. This is useful for iteration and other use.
     * @returns {Object}
     *
     * @example <caption>Iterate on all variables</caption>
     * var VariableScope = require('postman-collection').VariableScope,
     *     env = new VariableScope([{
     *         key: 'var1',
     *         value: 'one'
     *     }, {
     *         key: 'var2',
     *         value: 2,
     *         type: 'number'
     *     }, {
     *         key: 'var3',
     *         value: true,
     *         type: 'boolean'
     *     }]),
     *     obj;
     *
     * // get all variables consolidated as an object
     * obj = env.variables();
     *
     * Object.keys(obj).forEach(function(varname) {
     *     console.log(obj[varname]); // log all variables
     * });
     */
    variables: function () {
        return this.values.syncToObject({});
    },

    /**
     * Converts a list of Variables into an object where key is `_postman_propertyIndexKey` and value is determined
     * by the `valueOf` function
     *
     * @param {Boolean} excludeDisabled
     * @param {Boolean} caseSensitive
     * @return {Object}
     */
    toObject: function (excludeDisabled, caseSensitive) {
        // if the scope has no layers, we simply export the contents of primary store
        if (!this._layers) {
            return this.values.toObject(excludeDisabled, caseSensitive);
        }

        var mergedLayers = {};

        _.forEachRight(this._layers, function (layer) {
            _.assign(mergedLayers, layer.toObject(excludeDisabled, caseSensitive));
        });

        return _.assign(mergedLayers, this.values.toObject(excludeDisabled, caseSensitive));
    },

    /**
     * Determines whether one particular variable is defined in this scope of variables.
     *
     * @param {String} key - The name of the variable to check
     * @returns {Boolean} - Returns true if an enabled variable with given key is present in current or parent scopes,
     *                      false otherwise
     */
    has: function (key) {
        var variable = this.values.oneNormalizedVariable(key),
            i,
            ii;

        // if a variable is disabled or does not exist in local scope,
        // we search all the layers and return the first occurrence.
        if ((!variable || variable.disabled === true) && this._layers) {
            for (i = 0, ii = this._layers.length; i < ii; i++) {
                variable = this._layers[i].oneNormalizedVariable(key);
                if (variable && variable.disabled !== true) { break; }
            }
        }

        return Boolean(variable && variable.disabled !== true);
    },

    /**
     * Fetches a variable from the current scope or from parent scopes if present.
     *
     * @param {String} key - The name of the variable to get.
     * @returns {*} The value of the specified variable across scopes.
     */
    get: function (key) {
        var variable = this.values.oneNormalizedVariable(key),
            i,
            ii;

        // if a variable does not exist in local scope, we search all the layers and return the first occurrence.
        if ((!variable || variable.disabled === true) && this._layers) {
            for (i = 0, ii = this._layers.length; i < ii; i++) {
                variable = this._layers[i].oneNormalizedVariable(key);
                if (variable && variable.disabled !== true) { break; }
            }
        }

        return (variable && variable.disabled !== true) ? variable.valueOf() : undefined;
    },

    /**
     * Creates a new variable, or updates an existing one.
     *
     * @param {String} key - The name of the variable to set.
     * @param {*} value - The value of the variable to be set.
     * @param {Variable.types} [type] - Optionally, the value of the variable can be set to a type
     */
    set: function (key, value, type) {
        var variable = this.values.oneNormalizedVariable(key),

            update = { // create an object that will be used as setter
                key: key,
                value: value
            };

        _.isString(type) && (update.type = type);

        // If a variable by the name key exists, update it's value and return.
        // @note adds new variable if existing is disabled. Disabled variables are not updated.
        if (variable && !variable.disabled) {
            variable.update(update);
        }
        else {
            this.values.add(update);
        }

        // track the change if mutation tracking is enabled
        this._postman_enableTracking && this.mutations.track(MUTATIONS.SET, key, value);
    },

    /**
     * Removes the variable with the specified name.
     *
     * @param {String} key
     */
    unset: function (key) {
        var lastDisabledVariable;

        this.values.remove(function (variable) {
            // bail out if variable name didn't match
            if (variable.key !== key) {
                return false;
            }

            // don't delete disabled variables
            if (variable.disabled) {
                lastDisabledVariable = variable;
                return false;
            }

            // delete all enabled variables
            return true;
        });

        // restore the reference with the last disabled variable
        if (lastDisabledVariable) {
            this.values.reference[key] = lastDisabledVariable;
        }

        // track the change if mutation tracking is enabled
        this._postman_enableTracking && this.mutations.track(MUTATIONS.UNSET, key);
    },

    /**
     * Removes *all* variables from the current scope. This is a destructive action.
     */
    clear: function () {
        var mutations = this.mutations;

        // track the change if mutation tracking is enabled
        // do this before deleting the keys
        if (this._postman_enableTracking) {
            this.values.each(function (variable) {
                mutations.track(MUTATIONS.UNSET, variable.key);
            });
        }

        this.values.clear();
    },

    /**
     * Replace all variable names with their values in the given template.
     *
     * @param {String|Object} template - A string or an object to replace variables in
     * @returns {String|Object} The string or object with variables (if any) substituted with their values
     */
    replaceIn: function (template) {
        if (_.isString(template) || _.isArray(template)) {
            // convert template to object because replaceSubstitutionsIn only accepts objects
            var result = Property.replaceSubstitutionsIn({ template: template }, _.concat(this.values, this._layers));
            return result.template;
        }

        if (_.isObject(template)) {
            return Property.replaceSubstitutionsIn(template, _.concat(this.values, this._layers));
        }

        return template;
    },

    /**
     * Enable mutation tracking.
     *
     * @note: Would do nothing if already enabled.
     * @note: Any previously tracked mutations would be reset when starting a new tracking session.
     *
     * @param {MutationTracker~definition} [options] Options for Mutation Tracker. See {@link MutationTracker}
     */
    enableTracking: function (options) {
        // enabled already, do nothing
        if (this._postman_enableTracking) {
            return;
        }

        /**
         * Controls if mutation tracking is enabled
         *
         * @memberof VariableScope.prototype
         *
         * @private
         * @property {Boolean}
         */
        this._postman_enableTracking = true;

        // we don't want to add more mutations to existing mutations
        // that will lead to mutations not capturing the correct state
        // so we reset this with the new instance
        this.mutations = new MutationTracker(options);
    },

    /**
     * Disable mutation tracking.
     */
    disableTracking: function () {
        // disable further tracking but keep the tracked mutations
        this._postman_enableTracking = false;
    },

    /**
     * Apply a mutation instruction on this variable scope.
     *
     * @private
     *
     * @param {String} instruction Instruction identifying the type of the mutation, e.g. `set`, `unset`
     */
    applyMutation: function (instruction, key, value) {
        // we know that `set` and `unset` are the only supported instructions
        // and we know the parameter signature of both is the same as the items in a mutation
        if (this[instruction]) {

            // @todo: use argument spread here, once node v4 support is dropped
            this[instruction](key, value);
        }
    },

    /**
     * Using this function, one can sync the values of this variable list from a reference object.
     *
     * @private
     * @param {Object} obj
     * @param {Boolean=} [track]
     * @returns {Object}
     */
    syncVariablesFrom: function (obj, track) {
        return this.values.syncFromObject(obj, track);
    },

    /**
     * Transfer the variables in this scope to an object
     *
     * @private
     * @param {Object=} [obj]
     * @returns {Object}
     */
    syncVariablesTo: function (obj) {
        return this.values.syncToObject(obj);
    },

    /**
     * Convert this variable scope into a JSON serialisable object. Useful to transport or store, environment and
     * globals as a whole.
     *
     * @returns {Object}
     */
    toJSON: function () {
        var obj = PropertyBase.toJSON(this);

        // @todo - remove this when pluralisation is complete
        if (obj.value) {
            obj.values = obj.value;
            delete obj.value;
        }

        // ensure that the concept of layers is not exported as JSON. JSON cannot retain references and this will end up
        // being a pointless object post JSONification.
        if (obj._layers) {
            delete obj._layers;
        }

        // ensure that tracking flag is not serialized
        // otherwise, it is very easy to let tracking trickle to many instances leading to a snowball effect
        if (obj._postman_enableTracking) {
            delete obj._postman_enableTracking;
        }

        return obj;
    },

    /**
     * Adds a variable list to the current instance in order to increase the surface area of variable resolution.
     * This enables consumers to search across scopes (eg. environment and globals).
     *
     * @private
     * @param {VariableList} [list]
     */
    addLayer: function (list) {
        if (!VariableList.isVariableList(list)) {
            return;
        }

        !this._layers && (this._layers = []); // lazily initialize layers
        this._layers.push(list);
    }
});

_.assign(VariableScope, /** @lends VariableScope */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     *
     * @note that this is directly accessed only in case of VariableScope from _.findValue lodash util mixin
     */
    _postman_propertyName: 'VariableScope',

    /**
     * Check whether an object is an instance of {@link VariableScope}.
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isVariableScope: function (obj) {
        return Boolean(obj) && ((obj instanceof VariableScope) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', VariableScope._postman_propertyName));
    }
});

module.exports = {
    VariableScope: VariableScope
};


/***/ }),

/***/ 5313:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(3767).lodash,
    PropertyList = __webpack_require__(3798).PropertyList,
    ProxyConfig = __webpack_require__(4091).ProxyConfig,
    Url = __webpack_require__(3837).Url,

    ProxyConfigList;

_.inherit((

    /**
     * @constructor
     * @extends {PropertyList}
     *
     * @param {Object} parent
     * @param {Array} populate The list of proxy objects
     *
     * @example <caption>Create a new ProxyConfigList</caption>
     * var ProxyConfigList = require('postman-collection').ProxyConfigList,
     *     myProxyConfig = new ProxyConfigList({}, [
     *              {match: 'https://example.com/*', host: 'proxy.com', port: 8080, tunnel: true},
     *              {match: 'http+https://example2.com/*', host: 'proxy2.com'},
     *          ]);
     */
    ProxyConfigList = function PostmanProxyConfigList (parent, populate) {

        // this constructor is intended to inherit and as such the super constructor is required to be executed
        ProxyConfigList.super_.call(this, ProxyConfig, parent, populate);
    }), PropertyList);

_.assign(ProxyConfigList.prototype, /** @lends ProxyConfigList.prototype */ {
    /**
     * Matches and gets the proxy config for the particular url.
     *
     * @returns {ProxyConfig~definition} The matched proxyConfig object
     * @param {URL=} [url] The url for which the proxy config needs to be fetched
     */
    resolve: function (url) {
        // url must be either string or an instance of url.
        if (!_.isString(url) && !Url.isUrl(url)) {
            return;
        }

        // @todo - use a fixed-length cacheing of regexes in future
        return this.find(function (proxyConfig) {
            return !proxyConfig.disabled && proxyConfig.test(url);
        });

    }
});

_.assign(ProxyConfigList, /** @lends ProxyConfigList */ {
    /**
     * Defines the name of this property for internal use.
     * @private
     * @readOnly
     * @type {String}
     *
     * @note that this is directly accessed only in case of ProxyConfigList from _.findValue lodash util mixin
     */
    _postman_propertyName: 'ProxyConfigList',

    /**
     * Checks whether an object is a ProxyConfigList
     *
     * @param {*} obj
     * @returns {Boolean}
     */
    isProxyConfigList: function (obj) {
        return Boolean(obj) && ((obj instanceof ProxyConfigList) ||
            _.inSuperChain(obj.constructor, '_postman_propertyName', ProxyConfigList._postman_propertyName));
    }
});

module.exports = {
    ProxyConfigList: ProxyConfigList
};


/***/ }),

/***/ 5314:
/***/ (function(module, exports) {

module.exports = {"bash":"bash","curl":"cURL","javascript":"JavaScript","http":"HTTP","python":"Python","ruby":"Ruby","java":"Java","c":"C","php":"PHP","objective-c":"Objective-C","perl":"Perl","go":"Go","swift":"Swift","typescript":"TypeScript","powershell":"PowerShell","csharp":"C#","nodejs":"NodeJs","ocaml":"OCaml","shell":"Shell"}

/***/ }),

/***/ 5315:
/***/ (function(module, exports, __webpack_require__) {

var codegenList = [
  {
    'type': 'code_generator',
    'lang': 'csharp',
    'variant': 'RestSharp',
    'syntax_mode': 'csharp',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': '',
    'main': __webpack_require__(5316)
  },
  {
    'type': 'code_generator',
    'lang': 'curl',
    'variant': 'cURL',
    'syntax_mode': 'powershell',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/curl',
    'main': __webpack_require__(5319)
  },
  {
    'type': 'code_generator',
    'lang': 'go',
    'variant': 'Native',
    'syntax_mode': 'golang',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/golang',
    'main': __webpack_require__(5322)
  },
  {
    'type': 'code_generator',
    'lang': 'http',
    'variant': 'HTTP',
    'syntax_mode': 'text',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/http',
    'main': __webpack_require__(5325)
  },
  {
    'type': 'code_generator',
    'lang': 'java',
    'variant': 'OkHttp',
    'syntax_mode': 'java',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/java-okhttp',
    'main': __webpack_require__(5329)
  },
  {
    'type': 'code_generator',
    'lang': 'java',
    'variant': 'Unirest',
    'syntax_mode': 'java',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/java-unirest',
    'main': __webpack_require__(5332)
  },
  {
    'type': 'code_generator',
    'lang': 'JavaScript',
    'variant': 'Fetch',
    'syntax_mode': 'javascript',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/js-fetch',
    'main': __webpack_require__(5335)
  },
  {
    'type': 'code_generator',
    'lang': 'javascript',
    'variant': 'jQuery',
    'syntax_mode': 'javascript',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/js-jquery',
    'main': __webpack_require__(5338)
  },
  {
    'type': 'code_generator',
    'lang': 'JavaScript',
    'variant': 'XHR',
    'syntax_mode': 'javascript',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/js-xhr',
    'main': __webpack_require__(5341)
  },
  {
    'type': 'code_generator',
    'lang': 'C',
    'variant': 'libcurl',
    'syntax_mode': 'c_cpp',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/libcurl',
    'main': __webpack_require__(5344)
  },
  {
    'type': 'code_generator',
    'lang': 'nodejs',
    'variant': 'Native',
    'syntax_mode': 'javascript',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/nodejs-native',
    'main': __webpack_require__(5347)
  },
  {
    'type': 'code_generator',
    'lang': 'nodejs',
    'variant': 'Request',
    'syntax_mode': 'javascript',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/nodejs-request',
    'main': __webpack_require__(5350)
  },
  {
    'type': 'code_generator',
    'lang': 'nodejs',
    'variant': 'Unirest',
    'syntax_mode': 'javascript',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://bitbucket.org/postmanlabs/codegen-nodejs-unirest#readme',
    'main': __webpack_require__(5353)
  },
  {
    'type': 'code_generator',
    'lang': 'Objective-C',
    'variant': 'NSURLSession',
    'syntax_mode': 'objectivec',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/objective-c',
    'main': __webpack_require__(5356)
  },
  {
    'type': 'code_generator',
    'lang': 'ocaml',
    'variant': 'Cohttp',
    'syntax_mode': 'ocaml',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/ocaml-cohttp',
    'main': __webpack_require__(5359)
  },
  {
    'type': 'code_generator',
    'lang': 'php',
    'variant': 'cURL',
    'syntax_mode': 'php',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/php-curl',
    'main': __webpack_require__(5362)
  },
  {
    'type': 'code_generator',
    'lang': 'php',
    'variant': 'HTTP_Request2',
    'syntax_mode': 'php',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/php-httprequest2',
    'main': __webpack_require__(5365)
  },
  {
    'type': 'code_generator',
    'lang': 'php',
    'variant': 'pecl_http',
    'syntax_mode': 'php',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/php-pecl-http',
    'main': __webpack_require__(5368)
  },
  {
    'type': 'code_generator',
    'lang': 'powershell',
    'variant': 'RestMethod',
    'syntax_mode': 'powershell',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/powershell-restmethod',
    'main': __webpack_require__(5371)
  },
  {
    'type': 'code_generator',
    'lang': 'python',
    'variant': 'http.client',
    'syntax_mode': 'python',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/python-http.client',
    'main': __webpack_require__(5374)
  },
  {
    'type': 'code_generator',
    'lang': 'python',
    'variant': 'Requests',
    'syntax_mode': 'python',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/python-requests',
    'main': __webpack_require__(5377)
  },
  {
    'type': 'code_generator',
    'lang': 'Ruby',
    'variant': 'Net::HTTP',
    'syntax_mode': 'ruby',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/ruby',
    'main': __webpack_require__(5380)
  },
  {
    'type': 'code_generator',
    'lang': 'shell',
    'variant': 'Httpie',
    'syntax_mode': 'powershell',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/shell-httpie',
    'main': __webpack_require__(5383)
  },
  {
    'type': 'code_generator',
    'lang': 'shell',
    'variant': 'wget',
    'syntax_mode': 'powershell',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://bitbucket.org/postmanlabs/codegen-php-curl#readme',
    'main': __webpack_require__(5386)
  },
  {
    'type': 'code_generator',
    'lang': 'swift',
    'variant': 'URLSession',
    'syntax_mode': 'swift',
    'author': 'Postman Labs <help@getpostman.com>',
    'homepage': 'https://github.com/postmanlabs/code-generators/tree/master/codegens/swift',
    'main': __webpack_require__(5389)
  }
];
module.exports = codegenList;


/***/ }),

/***/ 5316:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5317);


/***/ }),

/***/ 5317:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4373).convert,
  getOptions: __webpack_require__(4373).getOptions
};


/***/ }),

/***/ 5318:
/***/ (function(module, exports, __webpack_require__) {


var _ = __webpack_require__(4374),
  sanitize = __webpack_require__(3980).sanitize;

/**
 * Parses body of request specific requests having form data
 *
 * @param {Object} requestBody - JSON object representing body of request
 * @param {Boolean} trimFields - indicates whether to trim fields of body
 * @returns {String} code snippet of csharp-restsharp for multipart formdata
 */
function parseFormData (requestBody, trimFields) {
  if (!Array.isArray(requestBody[requestBody.mode])) {
    return '';
  }

  return requestBody[requestBody.mode].reduce((body, data) => {
    if (data.disabled) {
      return body;
    }
    if (data.type === 'file') {
      body += `request.AddFile("${sanitize(data.key, trimFields)}", "${sanitize(data.src, trimFields)}");\n`;
    }
    else {
      (!data.value) && (data.value = '');
      body += `request.AddParameter("${sanitize(data.key, trimFields)}", ` +
                `"${sanitize(data.value, trimFields)}");\n`;
    }

    return body;
  }, '');
}

/**
 * Returns content-type of request body if available else returns text/plain as default
 *
 * @param {Object} request - Postman SDK request object
 * @returns {String} content-type of request body
 */
function parseContentType (request) {
  return request.getHeaders({enabled: true, ignoreCase: true})['content-type'] || 'text/plain';
}

/**
 *
 * @param {Object} requestBody - JSON object representing body of request
 * @param {boolean} trimFields - Boolean denoting whether to trim body fields
 * @returns {String} code snippet for graphql body
 */
function parseGraphQL (requestBody, trimFields) {
  let query = requestBody.graphql.query,
    graphqlVariables;
  try {
    graphqlVariables = JSON.parse(requestBody.graphql.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  return 'request.AddParameter("application/json", ' +
          `"${sanitize(JSON.stringify({query: query, variables: graphqlVariables}), trimFields)}",
           ParameterType.RequestBody);\n`;

}

/**
 * Parses request object and returns csharp-restsharp code snippet for adding request body
 *
 * @param {Object} request - JSON object representing body of request
 * @param {Boolean} trimFields - indicates whether to trim fields of body
 * @returns {String} code snippet of csharp-restsharp parsed from request object
 */
function parseBody (request, trimFields) {
  var requestBody = request.body ? request.body.toJSON() : {};
  if (!_.isEmpty(requestBody)) {
    switch (requestBody.mode) {
      case 'urlencoded':
        return parseFormData(requestBody, trimFields);
      case 'formdata':
        return parseFormData(requestBody, trimFields);
      case 'raw':
        return `request.AddParameter("${parseContentType(request)}", ` +
                    `${JSON.stringify(requestBody[requestBody.mode])},  ParameterType.RequestBody);\n`;
      case 'graphql':
        return parseGraphQL(requestBody, trimFields);
        /* istanbul ignore next */
      case 'file':
        return `request.AddParameter("${parseContentType(request)}", ` +
                    '"<file contents here>", ParameterType.RequestBody);\n';
      default:
        return '';
    }
  }
  return '';
}

/**
 * Parses header in Postman-SDK request and returns code snippet of csharp-restsharp for adding headers
 *
 * @param {Object} requestJson - Postman SDK reqeust object
 * @returns {String} code snippet for adding headers in csharp-restsharp
 */
function parseHeader (requestJson) {
  if (!Array.isArray(requestJson.header)) {
    return '';
  }

  return requestJson.header.reduce((headerSnippet, header) => {
    if (!header.disabled) {
      headerSnippet += `request.AddHeader("${sanitize(header.key, true)}", "${sanitize(header.value)}");\n`;
    }
    return headerSnippet;
  }, '');
}

module.exports = {
  parseBody: parseBody,
  parseHeader: parseHeader,
  parseContentType: parseContentType
};


/***/ }),

/***/ 5319:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5320);


/***/ }),

/***/ 5320:
/***/ (function(module, exports, __webpack_require__) {

var sanitize = __webpack_require__(3922).sanitize,
  sanitizeOptions = __webpack_require__(3922).sanitizeOptions,
  getUrlStringfromUrlObject = __webpack_require__(3922).getUrlStringfromUrlObject,
  addFormParam = __webpack_require__(3922).addFormParam,
  form = __webpack_require__(3922).form,
  _ = __webpack_require__(5321),
  self;

self = module.exports = {
  convert: function (request, options, callback) {

    if (!_.isFunction(callback)) {
      throw new Error('Curl-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());

    var indent, trim, headersData, body, redirect, timeout, multiLine,
      format, snippet, silent, url;

    redirect = options.followRedirect;
    timeout = options.requestTimeout;
    multiLine = options.multiLine;
    format = options.longFormat;
    trim = options.trimRequestBody;
    silent = options.silent;

    snippet = silent ? `curl ${form('-s', format)}` : 'curl';
    if (redirect) {
      snippet += ` ${form('-L', format)}`;
    }
    if (timeout > 0) {
      snippet += ` ${form('-m', format)} ${timeout}`;
    }
    if (multiLine) {
      indent = options.indentType === 'Tab' ? '\t' : ' ';
      indent = ' ' + options.lineContinuationCharacter + '\n' + indent.repeat(options.indentCount); // eslint-disable-line max-len
    }
    else {
      indent = ' ';
    }
    url = getUrlStringfromUrlObject(request.url);
    if (request.method === 'HEAD') {
      snippet += ` ${form('-I', format)} '${url}'`;
    }
    else {
      snippet += ` ${form('-X', format)} ${request.method} '${url}'`;
    }

    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    headersData = request.toJSON().header;
    if (headersData) {
      headersData = _.reject(headersData, 'disabled');
      _.forEach(headersData, (header) => {
        snippet += indent + `${form('-H', format)} '${sanitize(header.key, true)}: ${sanitize(header.value)}'`;
      });
    }

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        if (type === 'file') {
          if (typeof param.src !== 'string') {
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    if (request.body) {
      body = request.body.toJSON();

      if (!_.isEmpty(body)) {
        switch (body.mode) {
          case 'urlencoded':
            _.forEach(body.urlencoded, function (data) {
              if (!data.disabled) {
                // Using the long form below without considering the longFormat option,
                // to generate more accurate and correct snippet
                snippet += indent + '--data-urlencode';
                snippet += ` '${sanitize(data.key, trim)}=${sanitize(data.value, trim)}'`;
              }
            });
            break;
          case 'raw':
            snippet += indent + `--data-raw '${sanitize(body.raw.toString(), trim)}'`;
            break;
          // eslint-disable-next-line no-case-declarations
          case 'graphql':
            let query = body.graphql.query,
              graphqlVariables;
            try {
              graphqlVariables = JSON.parse(body.graphql.variables);
            }
            catch (e) {
              graphqlVariables = {};
            }
            snippet += indent + `--data-raw '${sanitize(JSON.stringify({
              query: query,
              variables: graphqlVariables
            }), trim)}'`;
            break;
          case 'formdata':
            _.forEach(body.formdata, function (data) {
              if (!(data.disabled)) {
                if (data.type === 'file') {
                  snippet += indent + `${form('-F', format)}`;
                  snippet += ` '${sanitize(data.key, trim)}=@${sanitize(data.src, trim)}'`;
                }
                else {
                  snippet += indent + `${form('-F', format)}`;
                  snippet += ` '${sanitize(data.key, trim)}=${sanitize(data.value, trim)}'`;
                }
              }
            });
            break;
          case 'file':
            snippet += indent + '--data-binary';
            snippet += ` '@${sanitize(body[body.mode].src, trim)}'`;
            break;
          default:
            snippet += `${form('-d', format)} ''`;
        }
      }
    }
    callback(null, snippet);
  },
  getOptions: function () {
    return [
      {
        name: 'Generate multiline snippet',
        id: 'multiLine',
        type: 'boolean',
        default: true,
        description: 'Split cURL command across multiple lines'
      },
      {
        name: 'Use long form options',
        id: 'longFormat',
        type: 'boolean',
        default: true,
        description: 'Use the long form for cURL options (--header instead of -H)'
      },
      {
        name: 'Line continuation character',
        id: 'lineContinuationCharacter',
        availableOptions: ['\\', '^'],
        type: 'enum',
        default: '\\',
        description: 'Set a character used to mark the continuation of a statement on the next line ' +
          '(generally, \\ for OSX/Linux, ^ for Windows)'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response before ' +
          'timing out (use 0 for infinity)'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Use Silent Mode',
        id: 'silent',
        type: 'boolean',
        default: false,
        description: 'Display the requested data without showing the cURL progress meter or error messages'
      }
    ];
  }
};


/***/ }),

/***/ 5321:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5322:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5323);


/***/ }),

/***/ 5323:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5324),
  sanitize = __webpack_require__(4094).sanitize,
  sanitizeOptions = __webpack_require__(4094).sanitizeOptions,
  addFormParam = __webpack_require__(4094).addFormParam,
  isFile = false,
  self;

/**
 * Parses Raw data to fetch syntax
 *
 * @param {Object} body Raw body data
 * @param {boolean} trim trim body option
 */
function parseRawBody (body, trim) {
  var bodySnippet;
  bodySnippet = `payload := strings.NewReader("${sanitize(body.toString(), trim)}")`;
  return bodySnippet;
}

/**
 * Parses graphql data to golang syntax
 *
 * @param {Object} body Raw body data
 * @param {boolean} trim trim body option
 */
function parseGraphQL (body, trim) {
  let query = body.query,
    graphqlVariables,
    bodySnippet;
  try {
    graphqlVariables = JSON.parse(body.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  bodySnippet = `payload := strings.NewReader("${sanitize(JSON.stringify({
    query: query,
    variables: graphqlVariables
  }), trim)}")`;
  return bodySnippet;
}

/**
 * Parses URLEncoded body from request to fetch syntax
 *
 * @param {Object} body URLEncoded Body
 * @param {boolean} trim trim body option
 */
function parseURLEncodedBody (body, trim) {
  var payload, bodySnippet;
  payload = _.reduce(body, function (accumulator, data) {
    if (!data.disabled) {
      accumulator.push(`${escape(data.key, trim)}=${escape(data.value, trim)}`);
    }
    return accumulator;
  }, []).join('&');

  bodySnippet = `payload := strings.NewReader("${payload}")`;
  return bodySnippet;
}

/**
 * Parses formData body from request to fetch syntax
 *
 * @param {Object} body formData Body
 * @param {boolean} trim trim body option
 * @param {string} indent indent string
 */
function parseFormData (body, trim, indent) {
  var bodySnippet = `payload := &bytes.Buffer{}\n${indent}writer := multipart.NewWriter(payload)\n`;
  _.forEach(body, function (data, index) {
    if (!data.disabled) {
      if (data.type === 'file') {
        isFile = true;
        bodySnippet += `${indent}file, errFile${index + 1} := os.Open("${data.src}")\n`;
        bodySnippet += `${indent}defer file.Close()\n`;
        bodySnippet += `${indent}part${index + 1},
         errFile${index + 1} := writer.CreateFormFile("${sanitize(data.key, trim)}",` +
                        `filepath.Base("${data.src}"))\n`;
        bodySnippet += `${indent}_, errFile${index + 1} = io.Copy(part${index + 1}, file)\n`;
        bodySnippet += `${indent}if errFile${index + 1} !=nil {
          \n${indent.repeat(2)}fmt.Println(errFile${index + 1})\n${indent}}\n`;
      }
      else {
        bodySnippet += `${indent}_ = writer.WriteField("${sanitize(data.key, trim)}",`;
        bodySnippet += ` "${sanitize(data.value, trim)}")\n`;
      }
    }
  });
  bodySnippet += `${indent}err := writer.Close()\n${indent}if err != nil ` +
  `{\n${indent.repeat(2)}fmt.Println(err)\n${indent}}\n`;
  return bodySnippet;
}

/**
 * Parses file body from the Request
 *
 */
function parseFile () {
  // var bodySnippet = `payload := &bytes.Buffer{}\n${indent}writer := multipart.NewWriter(payload)\n`;
  // isFile = true;
  // bodySnippet += `${indent}// add your file name in the next statement in place of path\n`;
  // bodySnippet += `${indent}file, err := os.Open(path)\n`;
  // bodySnippet += `${indent}defer file.Close()\n`;
  // bodySnippet += `${indent}part, err := writer.CreateFormFile("file", filepath.Base(path))\n`;
  // bodySnippet += `${indent}_, err := io.Copy(part, file)\n`;
  // bodySnippet += `${indent}err := writer.Close()\n${indent}if err != nil {${indent}fmt.Println(err)}\n`;
  var bodySnippet = 'payload := strings.NewReader("<file contents here>")\n';
  return bodySnippet;
}

/**
 * Parses Body from the Request
 *
 * @param {Object} body body object from request.
 * @param {boolean} trim trim body option
 * @param {string} indent indent string
 */
function parseBody (body, trim, indent) {
  if (!_.isEmpty(body)) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded, trim);
      case 'raw':
        return parseRawBody(body.raw, trim);
      case 'graphql':
        return parseGraphQL(body.graphql, trim);
      case 'formdata':
        return parseFormData(body.formdata, trim, indent);
      case 'file':
        return parseFile(body.file, trim, indent);
      default:
        return '';
    }
  }
  return '';
}

/**
 * Parses headers from the request.
 *
 * @param {Object} headers headers from the request.
 * @param {string} indent indent string
 */
function parseHeaders (headers, indent) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    headers = _.reject(headers, 'disabled');
    _.forEach(headers, function (header) {
      headerSnippet += `${indent}req.Header.Add("${sanitize(header.key, true)}", "${sanitize(header.value)}")\n`;
    });
  }
  return headerSnippet;
}

self = module.exports = {
  convert: function (request, options, callback) {

    if (!_.isFunction(callback)) {
      throw new Error('GoLang-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());

    var codeSnippet, indent, trim, timeout, followRedirect,
      bodySnippet = '',
      responseSnippet = '',
      headerSnippet = '';

    indent = options.indentType === 'Tab' ? '\t' : ' ';
    indent = indent.repeat(options.indentCount);
    timeout = options.requestTimeout;
    followRedirect = options.followRedirect;
    trim = options.trimRequestBody;

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        if (type === 'file') {
          if (typeof param.src !== 'string') {
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    if (request.body) {
      bodySnippet = parseBody(request.body.toJSON(), trim, indent);
    }

    codeSnippet = 'package main\n\n';
    codeSnippet += `import (\n${indent}"fmt"\n`;
    if (timeout > 0) {
      codeSnippet += `${indent}"time"\n`;
    }
    if (request.body && request.body.toJSON().mode === 'formdata') {
      codeSnippet += `${indent}"bytes"\n${indent}"mime/multipart"\n`;
    }
    else if (bodySnippet !== '') {
      codeSnippet += `${indent}"strings"\n`;
    }
    if (isFile) {
      codeSnippet += `${indent}"os"\n${indent}"path/filepath"\n`;
      codeSnippet += `${indent}"io"\n`;
      // Setting isFile as false for further calls to this function
      isFile = false;
    }
    codeSnippet += `${indent}"net/http"\n${indent}"io/ioutil"\n)\n\n`;

    codeSnippet += `func main() {\n\n${indent}url := "${encodeURI(request.url.toString())}"\n`;
    codeSnippet += `${indent}method := "${request.method}"\n\n`;

    if (bodySnippet !== '') {
      codeSnippet += indent + bodySnippet + '\n\n';
    }

    if (timeout > 0) {
      codeSnippet += `${indent}timeout := time.Duration(${timeout / 1000} * time.Second)\n`;
    }

    codeSnippet += indent + 'client := &http.Client {\n';
    if (!followRedirect) {
      codeSnippet += indent.repeat(2) + 'CheckRedirect: func(req *http.Request, via []*http.Request) ';
      codeSnippet += 'error {\n';
      codeSnippet += `${indent.repeat(3)}return http.ErrUseLastResponse\n${indent.repeat(2)}},\n`;
    }
    if (timeout > 0) {
      codeSnippet += indent.repeat(2) + 'Timeout: timeout,\n';
    }
    codeSnippet += indent + '}\n';
    if (bodySnippet !== '') {
      codeSnippet += `${indent}req, err := http.NewRequest(method, url, payload)\n\n`;
    }
    else {
      codeSnippet += `${indent}req, err := http.NewRequest(method, url, nil)\n\n`;
    }
    codeSnippet += `${indent}if err != nil {\n${indent.repeat(2)}fmt.Println(err)\n${indent}}\n`;
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    headerSnippet = parseHeaders(request.toJSON().header, indent);
    if (headerSnippet !== '') {
      codeSnippet += headerSnippet + '\n';
    }
    if (request.body && (request.body.toJSON().mode === 'formdata')) {
      codeSnippet += `${indent}req.Header.Set("Content-Type", writer.FormDataContentType())\n`;
    }
    responseSnippet = `${indent}res, err := client.Do(req)\n`;
    responseSnippet += `${indent}defer res.Body.Close()\n${indent}body, err := ioutil.ReadAll(res.Body)\n\n`;
    responseSnippet += `${indent}fmt.Println(string(body))\n}`;

    codeSnippet += responseSnippet;
    callback(null, codeSnippet);
  },
  getOptions: function () {
    return [{
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a ' +
        'response before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }];
  }
};


/***/ }),

/***/ 5324:
/***/ (function(module, exports) {

/* istanbul ignore file */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5325:
/***/ (function(module, exports, __webpack_require__) {

let converter = __webpack_require__(5326);

module.exports = {
  getOptions: converter.getOptions,
  convert: converter.convert
};


/***/ }),

/***/ 5326:
/***/ (function(module, exports, __webpack_require__) {

let utils = __webpack_require__(5327);

/**
 * Used in order to get additional options for generation of C# code snippet (i.e. Include Boilerplate code)
 *
 * @module getOptions
 *
 * @returns {Array} Additional options specific to generation of http code snippet
 */
function getOptions () {
  return [{
    name: 'Trim request body fields',
    id: 'trimRequestBody',
    type: 'boolean',
    default: false,
    description: 'Remove white space and additional lines that may affect the server\'s response'
  }];
}

/**
 * Converts a Postman SDK request to HTTP message
 *
 * @param {Object} request - Postman SDK request
 * @param {Object} options - Options for converter
 * @param {Boolean} options.trimRequestBody - determines whether to trim the body or not
 * @param {Function} callback callback
 * @returns {Function} returns the snippet with the callback function.
 */
function convert (request, options, callback) {
  let snippet = '';
  options = utils.sanitizeOptions(options, getOptions());
  utils.parseURLVariable(request);
  snippet = `${request.method} ${utils.getEndPoint(request)} HTTP/1.1\n`;
  snippet += `Host: ${utils.getHost(request)}\n`;
  if (request.body && !request.headers.has('Content-Type')) {
    if (request.body.mode === 'file') {
      request.addHeader({
        key: 'Content-Type',
        value: 'text/plain'
      });
    }
    else if (request.body.mode === 'graphql') {
      request.addHeader({
        key: 'Content-Type',
        value: 'application/json'
      });
    }
  }
  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              utils.addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            utils.addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          utils.addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        utils.addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  snippet += `${utils.getHeaders(request)}\n`;
  snippet += `\n${utils.getBody(request, options.trimRequestBody)}`;

  return callback(null, snippet);
}

module.exports = {
  getOptions: getOptions,
  convert: convert
};


/***/ }),

/***/ 5327:
/***/ (function(module, exports, __webpack_require__) {

let _ = __webpack_require__(5328),
  path = __webpack_require__(15);

const FORM_DATA_BOUNDARY = '----WebKitFormBoundary7MA4YWxkTrZu0gW',
  RAW = 'raw',
  GRAPHQL = 'graphql',
  URL_ENCODED = 'urlencoded',
  FORM_DATA = 'formdata',
  FILE = 'file';

var contentTypeHeaderMap = {
  'aac': 'audio/aac',
  'abw': 'application/x-abiword',
  'arc': 'application/x-freearc',
  'avi': 'video/x-msvideo',
  'azw': 'application/vnd.amazon.ebook',
  'bin': 'application/octet-stream',
  'bmp': 'image/bmp',
  'bz': 'application/x-bzip',
  'bz2': 'application/x-bzip2',
  'csh': 'application/x-csh',
  'css': 'text/css',
  'csv': 'text/csv',
  'doc': 'application/msword',
  'docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'eot': 'application/vnd.ms-fontobject',
  'epub': 'application/epub+zip',
  'gif': 'image/gif',
  'htm': 'text/html',
  'html': 'text/html',
  'ico': 'image/vnd.microsoft.icon',
  'ics': 'text/calendar',
  'jar': 'application/java-archive',
  'jpeg': 'image/jpeg',
  'jpg': 'image/jpeg',
  'js': 'text/javascript',
  'json': 'application/json',
  'jsonld': 'application/ld+json',
  'mid': 'audip/midi',
  'midi': 'audio/midi',
  'mjs': 'text/javascript',
  'mp3': 'audio/mpeg',
  'mpeg': 'video/mpeg',
  'mpkg': 'application/vnd.apple.installer+xml',
  'odp': 'application/vnd.oasis.opendocument.presentation',
  'ods': 'application/vnd.oasis.opendocument.spreadsheet',
  'odt': 'application/vnd.oasis.opendocument.text',
  'oga': 'audio/ogg',
  'ogv': 'video/ogg',
  'ogx': 'application/ogg',
  'otf': 'font/otf',
  'png': 'image/png',
  'pdf': 'application/pdf',
  'ppt': 'application/vnd.ms-powerpoint',
  'pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
  'rar': 'application/x-rar-compressed',
  'rtf': 'application/rtf',
  'sh': 'application/x-sh',
  'svg': 'image/svg+xml',
  'swf': 'application/x-shockwave-flash',
  'tar': 'application/x-tar',
  'tif': 'image/tiff',
  'tiff': 'image/tiff',
  'ts': 'video/mp2t',
  'ttf': 'font/ttf',
  'txt': 'text/plain',
  'vsd': 'application/vnd.visio',
  'wav': 'audio/wav',
  'weba': 'audio/webm',
  'webm': 'video/webm',
  'webp': 'image/webp',
  'woff': 'font/woff',
  'woff2': 'font/woff2',
  'xhtml': 'application/xhtml+xml',
  'xls': 'application/vnd.ms-excel',
  'xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'xml': 'text/xml',
  'xul': 'application/vnd.mozilla.xul+xml',
  'zip': 'application/zip',
  '3gp': 'video/3gpp',
  '7z': 'application/x-7z-compressed',
  '7-zip': 'application/x-7z-compressed'
};

/**
 * Returns an array of properties in the property list.
 *
 * @param {Object} propertyList - Postman SDK property list
 * @param {Boolean} includeDisabled - Determines whether disabled properties are to be returned
 * @returns {Object} List of members
 */
function getMembersOfPropertyList (propertyList, includeDisabled = false) {
  /* istanbul ignore else */
  if (!includeDisabled) {
    return _.reject(propertyList.members, 'disabled');
  }

  return propertyList.members;
}

/**
 * Stringifies the members of the property list.
 *
 * @param {Object} propertyList propertyList
 * @param {String} joinUsing specify string that should be used to join the list of properties
 * @param {Boolean} includeDisabled indicated whether or not to include disabled properties
 * @param {Boolean} trimRequestBody indicates whether or not to trin request body
 * @returns {String} Stringified property List
 */
function convertPropertyListToString (propertyList, joinUsing, includeDisabled = false, trimRequestBody = false) {
  let properties;

  properties = getMembersOfPropertyList(propertyList, includeDisabled);

  return _.join(_.map(properties, (prop) => {
    return (trimRequestBody ? prop.toString().trim() : prop.toString());
  }), joinUsing);
}

/**
 * parses variable of request url object and sets hostname, path and query in request object
 *
 * @param {Object} request - Postman SDK request object
 */
function parseURLVariable (request) {
  const variableArray = _.get(request.toJSON(), 'url.variable', []);

  if (!variableArray.length) {
    return;
  }

  variableArray.forEach(function (variableArrayElement) {
    request.url.path.forEach(function (pathArrayElement, pathArrayElementIndex) {
      if (pathArrayElement === ':' + variableArrayElement.key) {
        request.url.path[pathArrayElementIndex] = variableArrayElement.value;
      }
    });
  });
}

/**
 * Returns the request end-point as a string.
 *
 * @param {Object} request - Postman SDK request
 * @returns {string} returns endpoint from the url path
 */
function getEndPoint (request) {
  let endPoint = '/',
    params = '';

  if (request.url.query.members && _.size(request.url.query.members)) {
    params += `?${convertPropertyListToString(request.url.query, '&')}`;
  }

  if (request.url.path && _.size(request.url.path)) {
    endPoint = `/${_.join(request.url.path, '/')}${params}`;
  }

  return endPoint;
}

/**
 * Returns the request host as a string.
 *
 * @param {Object} request - Postman SDK request
 * @returns {String} host
 */
function getHost (request) {
  if (!request.url.host) {
    return '';
  }

  let host = _.join(request.url.host, '.');
  if (request.url.port) {
    host += `:${request.url.port}`;
  }

  return host;
}

/**
 * Returns the request headers as a string
 *
 * @param {Object} request - Postman SDK request
 * @returns {Function} calls convertPropertyListToString
 */
function getHeaders (request) {
  let contentTypeIndex = _.findIndex(request.headers.members, { key: 'Content-Type' }),
    formDataHeader = `multipart/form-data; boundary=${FORM_DATA_BOUNDARY}`,
    headers = '';

  if (contentTypeIndex >= 0) {
    if (request.headers.members[contentTypeIndex].value === 'multipart/form-data' ||
      (request.body && request.body.mode === 'formdata')) {
      request.headers.members[contentTypeIndex].value = formDataHeader;
    }
  }

  _.forEach(request.headers.members, (header) => {
    header.key = header.key.trim();
  });
  headers = convertPropertyListToString(request.headers, '\n', false);
  if (request.body && request.body.mode === 'formdata' && contentTypeIndex < 0) {
    headers += `Content-Type: ${formDataHeader}`;
  }
  return headers;
}

/**
 * Returns the request body as a string
 *
 * @param {Object} request - Postman SDK request
 * @param {Boolean} trimRequestBody - Determines whether to trim the body
 * @returns {String} returns Body of the request
 */
function getBody (request, trimRequestBody) {
  let requestBody = '';
  /* istanbul ignore else */
  if (request.body) {
    switch (request.body.mode) {
      case RAW:
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += request.body[request.body.mode].toString();
        }
        return trimRequestBody ? requestBody.trim() : requestBody;
      // eslint-disable-next-line no-case-declarations
      case GRAPHQL:
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += JSON.stringify({
          query: query,
          variables: graphqlVariables
        });
        return trimRequestBody ? requestBody.trim() : requestBody;
      case URL_ENCODED:
        /* istanbul ignore else */
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += convertPropertyListToString(request.body[request.body.mode], '&', false, trimRequestBody);
        }
        return trimRequestBody ? requestBody.trim() : requestBody;

      case FORM_DATA:
        requestBody += `${FORM_DATA_BOUNDARY}\n`;
        /* istanbul ignore else */
        if (!_.isEmpty(request.body[request.body.mode])) {
          let properties = getMembersOfPropertyList(request.body[request.body.mode]);
          _.forEach(properties, function (property) {
            /* istanbul ignore else */
            if (property.type === 'text') {
              requestBody += 'Content-Disposition: form-data; name="';
              requestBody += `${(trimRequestBody ? property.key.trim() : property.key)}"\n`;
              requestBody += `\n${(trimRequestBody ? property.value.trim() : property.value)}\n`;
            }
            else if (property.type === 'file') {
              var pathArray = property.src.split(path.sep),
                fileName = pathArray[pathArray.length - 1],
                fileExtension = fileName.split('.')[1];
              requestBody += 'Content-Disposition: form-data; name="';
              requestBody += `${(trimRequestBody ? property.key.trim() : property.key)}"; filename="`;
              requestBody += `${fileName}"\n`;
              if (contentTypeHeaderMap[fileExtension]) {
                requestBody += `Content-Type: ${contentTypeHeaderMap[fileExtension]}\n\n`;
              }
              else {
                requestBody += 'Content-Type: <Content-Type header here>\n\n';
              }
              requestBody += '(data)\n';
            }
            requestBody += `${FORM_DATA_BOUNDARY}\n`;
          });
        }
        return trimRequestBody ? requestBody.trim() : requestBody;

      case FILE:
        return '"<file contents here>"';
      default:
        return requestBody;
    }
  }
  return '';
}

/**
 * sanitizes input options
 *
 * @param {Object} options - Options provided by the user
 * @param {Array} optionsArray - options array received from getOptions function
 *
 * @returns {Object} - Sanitized options object
 */
function sanitizeOptions (options, optionsArray) {
  var result = {},
    defaultOptions = {},
    id;
  optionsArray.forEach((option) => {
    defaultOptions[option.id] = {
      default: option.default,
      type: option.type
    };
    if (option.type === 'enum') {
      defaultOptions[option.id].availableOptions = option.availableOptions;
    }
  });

  for (id in options) {
    if (options.hasOwnProperty(id)) {
      if (defaultOptions[id] === undefined) {
        continue;
      }
      switch (defaultOptions[id].type) {
        case 'boolean':
          if (typeof options[id] !== 'boolean') {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'positiveInteger':
          if (typeof options[id] !== 'number' || options[id] < 0) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        case 'enum':
          if (!defaultOptions[id].availableOptions.includes(options[id])) {
            result[id] = defaultOptions[id].default;
          }
          else {
            result[id] = options[id];
          }
          break;
        default:
          result[id] = options[id];
      }
    }
  }

  for (id in defaultOptions) {
    if (defaultOptions.hasOwnProperty(id)) {
      if (result[id] === undefined) {
        result[id] = defaultOptions[id].default;
      }
    }
  }
  return result;
}

/**
 *
 * @param {Array} array - form data array
 * @param {String} key - key of form data param
 * @param {String} type - type of form data param(file/text)
 * @param {String} val - value/src property of form data param
 * @param {String} disabled - Boolean denoting whether the param is disabled or not
 * @param {String} contentType - content type header of the param
 *
 * Appends a single param to form data array
 */
function addFormParam (array, key, type, val, disabled, contentType) {
  if (type === 'file') {
    array.push({
      key: key,
      type: type,
      src: val,
      disabled: disabled,
      contentType: contentType
    });
  }
  else {
    array.push({
      key: key,
      type: type,
      value: val,
      disabled: disabled,
      contentType: contentType
    });
  }
}

module.exports = {
  parseURLVariable: parseURLVariable,
  getEndPoint: getEndPoint,
  getHost: getHost,
  getHeaders: getHeaders,
  getBody: getBody,
  sanitizeOptions: sanitizeOptions,
  addFormParam: addFormParam
};


/***/ }),

/***/ 5328:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5329:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5330);


/***/ }),

/***/ 5330:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4375).convert,
  getOptions: __webpack_require__(4375).getOptions
};


/***/ }),

/***/ 5331:
/***/ (function(module, exports, __webpack_require__) {


var _ = __webpack_require__(4376),
  sanitize = __webpack_require__(3981).sanitize,
  path = __webpack_require__(15);

/**
 * parses body of request and returns urlencoded string
 *
 * @param {Object} requestBody - json object respresenting body of request
 * @param {Boolean} trimFields - indicates whether to trim fields of body
 * @returns {String} - urlencoded string for request body
 */
function parseUrlencode (requestBody, trimFields) {
  //  reducing array of urlencoded form data to array of strings
  return _.reduce(requestBody[requestBody.mode], function (accumalator, data) {
    if (!data.disabled) {
      accumalator.push(`${sanitize(data.key, trimFields)}=${sanitize(data.value, trimFields)}`.replace(/&/g, '%26'));
    }
    return accumalator;
  }, []).join('&');
}

/**
 * parses body of request and creates java okhttp code snippet for adding form data
 *
 * @param {Object} requestBody - JSON object representing body of request
 * @param {String} indentString - string for indentation
 * @param {Boolean} trimFields - indicates whether to trim fields of body
 * @returns {String} - code snippet of java okhttp for multipart formdata
 */
function parseFormData (requestBody, indentString, trimFields) {
  return _.reduce(requestBody[requestBody.mode], function (body, data) {
    if (data.disabled) {
      return body;
    }
    /* istanbul ignore next */
    if (data.type === 'file') {
      var pathArray = data.src.split(path.sep),
        fileName = pathArray[pathArray.length - 1];
      body += indentString + '.addFormDataPart' +
                    `("${sanitize(data.key, trimFields)}","${sanitize(fileName, trimFields)}",\n` +
                    indentString.repeat(2) + 'RequestBody.create(MediaType.parse("application/octet-stream"),\n' +
                    indentString.repeat(2) + `new File("${sanitize(data.src)}")))\n`;
    }
    else {
      !data.value && (data.value = '');
      body += indentString + '.addFormDataPart' +
                    `("${sanitize(data.key, trimFields)}", "${sanitize(data.value, trimFields)}")\n`;
    }

    return body;
  }, '') + indentString + '.build()';
}

/**
 * parses request object and returns java okhttp code snippet for adding request body
 *
 * @param {Object} requestBody - JSON object representing body of request
 * @param {String} indentString - string for indentation
 * @param {Boolean} trimFields - indicates whether to trim fields of body
 * @returns {String} - code snippet of java okhttp parsed from request object
 */
function parseBody (requestBody, indentString, trimFields) {
  if (!_.isEmpty(requestBody)) {
    switch (requestBody.mode) {
      case 'urlencoded':
        return 'RequestBody body = RequestBody.create(mediaType, ' +
                        `"${parseUrlencode(requestBody, trimFields)}");\n`;
      case 'raw':
        return 'RequestBody body = RequestBody.create(mediaType, ' +
                        `${JSON.stringify(requestBody[requestBody.mode])});\n`;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = requestBody[requestBody.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(requestBody[requestBody.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        return 'RequestBody body = RequestBody.create(mediaType, ' +
        `"${sanitize(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }), trimFields)}");\n`;
      case 'formdata':
        return 'RequestBody body = new MultipartBody.Builder().setType(MultipartBody.FORM)\n' +
                        `${parseFormData(requestBody, indentString, trimFields)};\n`;
        /* istanbul ignore next */
      case 'file':
        // return 'RequestBody body = new MultipartBody.Builder().setType(MultipartBody.FORM)\n' +
        //                 indentString + `.addFormDataPart("file", "${requestBody[requestBody.mode].src}",\n` +
        //                 indentString + 'RequestBody.create(MediaType.parse("application/octet-stream"),\n' +
        //                 indentString + `new File("${requestBody[requestBody.mode].src}"))).build();\n`;
        return 'RequestBody body = RequestBody.create(mediaType, "<file contents here>");\n';
      default:
        return 'RequestBody body = RequestBody.create(mediaType, "");\n';
    }
  }
  return 'RequestBody body = RequestBody.create(mediaType, "");\n';
}

/**
 * Parses header in Postman-SDK request and returns code snippet of java okhttp for adding headers
 *
 * @param {Object} request - Postman SDK reqeust object
 * @param {String} indentString - indentation for code snippet
 * @returns {String} - code snippet for adding headers in java-okhttp
 */
function parseHeader (request, indentString) {
  var headerArray = request.toJSON().header,
    headerSnippet = '';

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerSnippet += _.reduce(headerArray, function (accumalator, header) {
      accumalator += indentString + `.addHeader("${sanitize(header.key, true)}", ` +
        `"${sanitize(header.value)}")\n`;
      return accumalator;
    }, '');
  }
  return headerSnippet;
}

/**
 * returns content-type of request body if available else returns text/plain as default
 *
 * @param {Object} request - Postman SDK request object
 * @returns {String}- content-type of request body
 */
function parseContentType (request) {
  if (request.body && request.body.mode === 'graphql') {
    return 'application/json';
  }
  return request.getHeaders({enabled: true, ignoreCase: true})['content-type'] || 'text/plain';
}

module.exports = {
  parseBody: parseBody,
  parseHeader: parseHeader,
  parseContentType: parseContentType
};


/***/ }),

/***/ 5332:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5333);


/***/ }),

/***/ 5333:
/***/ (function(module, exports, __webpack_require__) {


module.exports = {
  convert: __webpack_require__(4377).convert,
  getOptions: __webpack_require__(4377).getOptions
};


/***/ }),

/***/ 5334:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4378),

  sanitize = __webpack_require__(4095).sanitize;

/**
 *
 * @param {*} urlObject The request sdk request.url object
 * @returns {String} The final string after parsing all the parameters of the url including
 * protocol, auth, host, port, path, query, hash
 * This will be used because the url.toString() method returned the URL with non encoded query string
 * and hence a manual call is made to getQueryString() method with encode option set as true.
 */
function getUrlStringfromUrlObject (urlObject) {
  var url = '';
  if (!urlObject) {
    return url;
  }
  if (urlObject.protocol) {
    url += (urlObject.protocol.endsWith('://') ? urlObject.protocol : urlObject.protocol + '://');
  }
  if (urlObject.auth && urlObject.auth.user) {
    url = url + ((urlObject.auth.password) ?
      // ==> username:password@
      urlObject.auth.user + ':' + urlObject.auth.password : urlObject.auth.user) + '@';
  }
  if (urlObject.host) {
    url += urlObject.getHost();
  }
  if (urlObject.port) {
    url += ':' + urlObject.port.toString();
  }
  if (urlObject.path) {
    url += urlObject.getPath();
  }
  if (urlObject.query && urlObject.query.count()) {
    let queryString = urlObject.getQueryString({ ignoreDisabled: true, encode: true });
    queryString && (url += '?' + queryString);
  }
  if (urlObject.hash) {
    url += '#' + urlObject.hash;
  }

  return url;
}

/**
 * parses form data from request body and returns codesnippet in java unirest
 *
 * @param {Object} requestbody - JSON object acquired by request.body.JSON()
 * @param {String} indentString - value for indentation
 * @param {Boolean} trimField - whether to trim fields of the request body
 * @returns {String} - body string parsed from JSON object
 */
function parseFormData (requestbody, indentString, trimField) {
  return _.reduce(requestbody[requestbody.mode], function (body, data) {
    if (data.disabled) {
      return body;
    }
    if (data.type === 'file') {
      body += indentString + `.field("file", new File("${sanitize(data.src, trimField)}"))\n`;
    }
    else {
      (!data.value) && (data.value = '');
      body += indentString + `.field("${sanitize(data.key, trimField)}", ` +
                                    `"${sanitize(data.value, trimField)}")\n`;
    }
    return body;
  }, '');
}

/**
 * parses body from request object based on mode provided by request body and
 * returns codesnippet in java unirest
 *
 * @param {Object} request - postman request object, more information can be found in postman collection sdk
 * @param {String} indentString - value for indentation
 * @param {Boolean} trimField - whether to trim fields of body of the request
 * @returns {String} - body string parsed from request object
 */
function parseBody (request, indentString, trimField) {
  if (request.body) {
    switch (request.body.mode) {
      case 'urlencoded':
        return parseFormData(request.body.toJSON(), indentString, trimField);
      case 'raw':
        return indentString + `.body(${JSON.stringify(request.body.toString())})\n`;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body.graphql.query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body.graphql.variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        return indentString + `.body("${sanitize(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }), trimField)}")\n`;
      case 'formdata':
        var formDataContent = parseFormData(request.body.toJSON(), indentString, trimField);
        if (!formDataContent.includes('.field("file", new File')) {
          formDataContent = indentString + '.multiPartContent()' + formDataContent;
        }
        return formDataContent;
      case 'file':
        return indentString + '.body("<file contents here>")\n';
      default:
        return '';
    }
  }
  return '';
}

/**
 * parses header from request and returns codesnippet in java unirest
 *
 * @param {Object} request - postman request object, more information can be found in postman collection sdk
 * @param {String} indentString - value for indentation
 * @returns {String} - body string parsed from request object
 */
function parseHeader (request, indentString) {
  var headerArray = request.toJSON().header,
    headerSnippet = '';
  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerSnippet += headerArray.reduce(function (accumlator, header) {
      accumlator += indentString + `.header("${sanitize(header.key, true)}", "${sanitize(header.value)}")\n`;
      return accumlator;
    }, '');
  }
  return headerSnippet;
}

module.exports = {
  parseBody: parseBody,
  parseHeader: parseHeader,
  getUrlStringfromUrlObject: getUrlStringfromUrlObject
};


/***/ }),

/***/ 5335:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5336);


/***/ }),

/***/ 5336:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5337),
  sanitize = __webpack_require__(4096).sanitize,
  sanitizeOptions = __webpack_require__(4096).sanitizeOptions,
  addFormParam = __webpack_require__(4096).addFormParam,
  path = __webpack_require__(15);
const VALID_BODY_MODES = ['urlencoded', 'raw', 'graphql', 'file', 'formdata'];

/**
 * Adds mode of redirection in fetch.
 *
 * @param {boolean} redirect to determine whether to follow redirects or not.
 */
function redirectMode (redirect) {
  if (redirect) {
    return 'follow';
  }
  return 'manual';
}

/**
 * Parses URLEncoded body from request to fetch syntax
 *
 * @param {Object} body URLEncoded Body
 * @param {boolean} trim trim body option
 */
function parseURLEncodedBody (body, trim) {
  var bodySnippet = 'var urlencoded = new URLSearchParams();\n';
  _.forEach(body, function (data) {
    if (!data.disabled) {
      bodySnippet += `urlencoded.append("${sanitize(data.key, trim)}", "${sanitize(data.value, trim)}");\n`;
    }
  });
  return bodySnippet;
}

/**
 * Parses Formdata from request to fetch syntax
 *
 * @param {Object} body FormData body
 * @param {boolean} trim trim body option
 */
function parseFormData (body, trim) {
  var bodySnippet = 'var formdata = new FormData();\n';
  _.forEach(body, function (data) {
    if (!data.disabled) {
      if (data.type === 'file') {
        var pathArray = data.src.split(path.sep),
          fileName = pathArray[pathArray.length - 1];
        bodySnippet += `formdata.append("${sanitize(data.key, trim)}", fileInput.files[0], "${fileName}");\n`;
      }
      else {
        bodySnippet += `formdata.append("${sanitize(data.key, trim)}", "${sanitize(data.value, trim)}");\n`;
      }
    }
  });
  return bodySnippet;
}

/**
 * Parses Raw data to fetch syntax
 *
 * @param {Object} body Raw body data
 * @param {boolean} trim trim body option
 * @param {String} contentType Content type of the body being sent
 */
function parseRawBody (body, trim, contentType) {
  var bodySnippet = 'var raw = ';
  if (contentType === 'application/json') {
    try {
      let jsonBody = JSON.parse(body);
      bodySnippet += `JSON.stringify(${JSON.stringify(jsonBody)});\n`;
    }
    catch (error) {
      bodySnippet += `"${sanitize(body.toString(), trim)}";\n`;
    }
  }
  else {
    bodySnippet += `"${sanitize(body.toString(), trim)}";\n`;
  }
  return bodySnippet;
}

/**
 * Parses graphql data to fetch syntax
 *
 * @param {Object} body graphql body data
 * @param {boolean} trim trim body option
 * @param {String} indentString indentation to be added to the snippet
 */
function parseGraphQL (body, trim, indentString) {
  let query = body.query,
    graphqlVariables,
    bodySnippet;
  try {
    graphqlVariables = JSON.parse(body.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  bodySnippet = 'var graphql = JSON.stringify({\n';
  bodySnippet += `${indentString}query: "${sanitize(query, trim)}",\n`;
  bodySnippet += `${indentString}variables: ${JSON.stringify(graphqlVariables)}\n})`;
  return bodySnippet;
}


/* istanbul ignore next */
/**
 * parses binamry file data
 */
function parseFileData () {
  var bodySnippet = 'var file = "<file contents here>";\n';
  return bodySnippet;
}

/**
 * Parses Body from the Request
 *
 * @param {Object} body body object from request.
 * @param {boolean} trim trim body option
 * @param {String} indentString indentation to be added to the snippet
 * @param {String} contentType Content type of the body being sent
 */
function parseBody (body, trim, indentString, contentType) {
  if (!_.isEmpty(body)) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded, trim);
      case 'raw':
        return parseRawBody(body.raw, trim, contentType);
      case 'graphql':
        return parseGraphQL(body.graphql, trim, indentString);
      case 'formdata':
        return parseFormData(body.formdata, trim);
        /* istanbul ignore next */
      case 'file':
        return parseFileData(body.file, trim);
      default:
        return parseRawBody(body[body.mode], trim);
    }
  }
  return '';
}

/**
 * Parses headers from the request.
 *
 * @param {Object} headers headers from the request.
 */
function parseHeaders (headers) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    headerSnippet = 'var myHeaders = new Headers();\n';
    headers = _.reject(headers, 'disabled');
    _.forEach(headers, function (header) {
      headerSnippet += `myHeaders.append("${sanitize(header.key, true)}", "${sanitize(header.value)}");\n`;
    });
  }
  else {
    headerSnippet = '';
  }
  return headerSnippet;
}

/**
 * Used to get the options specific to this codegen
 *
 * @returns {Array} - Returns an array of option objects
 */
function getOptions () {
  return [
    {
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
* Converts Postman sdk request object to js-fetch request code snippet
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
function convert (request, options, callback) {
  if (!_.isFunction(callback)) {
    throw new Error('JS-Fetch Converter callback is not a valid function');
  }
  options = sanitizeOptions(options, getOptions());

  var indent = options.indentType === 'Tab' ? '\t' : ' ',
    trim = options.trimRequestBody,
    headers, body,
    codeSnippet = '',
    headerSnippet = '',
    bodySnippet = '',
    optionsSnippet = '',
    timeoutSnippet = '',
    fetchSnippet = '';
  indent = indent.repeat(options.indentCount);
  if (request.body && request.body.mode === 'graphql' && !request.headers.has('Content-Type')) {
    request.addHeader({
      key: 'Content-Type',
      value: 'application/json'
    });
  }
  headers = request.toJSON().header;
  headerSnippet = parseHeaders(headers);

  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  body = request.body && request.body.toJSON();
  bodySnippet = parseBody(body, trim, indent, request.headers.get('Content-Type'));

  optionsSnippet = `var requestOptions = {\n${indent}`;
  optionsSnippet += `method: '${request.method}',\n${indent}`;
  if (headerSnippet !== '') {
    optionsSnippet += `headers: myHeaders,\n${indent}`;
    codeSnippet += headerSnippet + '\n';
  }
  if (bodySnippet !== '') {
    if (!_.includes(VALID_BODY_MODES, body.mode)) { body.mode = 'raw'; }
    optionsSnippet += `body: ${body.mode},\n${indent}`;
    codeSnippet += bodySnippet + '\n';
  }
  optionsSnippet += `redirect: '${redirectMode(options.followRedirect)}'\n};\n`;

  codeSnippet += optionsSnippet + '\n';

  fetchSnippet = `fetch("${sanitize(request.url.toString())}", requestOptions)\n${indent}`;
  fetchSnippet += `.then(response => response.text())\n${indent}`;
  fetchSnippet += `.then(result => console.log(result))\n${indent}`;
  fetchSnippet += '.catch(error => console.log(\'error\', error));';

  if (options.requestTimeout > 0) {
    timeoutSnippet = `var promise = Promise.race([\n${indent}`;
    timeoutSnippet += `fetch('${request.url.toString()}', requestOptions)\n${indent}${indent}`;
    timeoutSnippet += `.then(response => response.text()),\n${indent}`;
    timeoutSnippet += `new Promise((resolve, reject) =>\n${indent}${indent}`;
    timeoutSnippet += `setTimeout(() => reject(new Error('Timeout')), ${options.requestTimeout})\n${indent}`;
    timeoutSnippet += ')\n]);\n\n';
    timeoutSnippet += 'promise.then(result => console.log(result)),\n';
    timeoutSnippet += 'promise.catch(error => console.log(error));';
    codeSnippet += timeoutSnippet;
  }
  else {
    codeSnippet += fetchSnippet;
  }

  callback(null, codeSnippet);
}

module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 5337:
/***/ (function(module, exports) {

/* istanbul ignore file */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5338:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5339);


/***/ }),

/***/ 5339:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4379).convert,
  getOptions: __webpack_require__(4379).getOptions
};


/***/ }),

/***/ 5340:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4380),
  sanitize = __webpack_require__(3982).sanitize;

/**
     * Used to parse the body of the postman SDK-request and return in the desired format
     *
     * @param  {Object} request - postman SDK-request object
     * @param  {Boolean} trimRequestBody - whether to trim request body fields
     * @param  {String} indentation - used for indenting snippet's structure
     * @param {String} contentType Content type of the body being sent
     * @returns {String} - request body
     */
module.exports = function (request, trimRequestBody, indentation, contentType) {
  // used to check whether body is present in the request and return accordingly
  if (request.body) {
    var requestBody = '',
      bodyMap,
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          if (contentType === 'application/json') {
            // eslint-disable-next-line max-depth
            try {
              let jsonBody = JSON.parse(request.body[request.body.mode]);
              requestBody += `${indentation}"data": JSON.stringify(${JSON.stringify(jsonBody)}),\n`;
            }
            catch (error) {
              requestBody += `${indentation}"data": ` +
                        `${sanitize(request.body[request.body.mode], request.body.mode, trimRequestBody)},\n`;
            }
          }
          else {
            requestBody += `${indentation}"data": ` +
            `${sanitize(request.body[request.body.mode], request.body.mode, trimRequestBody)},\n`;
          }
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += `${indentation}"data": ` +
          'JSON.stringify({\n' +
          `${indentation.repeat(2)}query: ${sanitize(query, 'raw', trimRequestBody)},\n` +
          `${indentation.repeat(2)}variables: ${JSON.stringify(graphqlVariables)}\n` +
          `${indentation}})\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyMap = _.map(enabledBodyList, function (value) {
            return `${indentation.repeat(2)}"${sanitize(value.key, request.body.mode, trimRequestBody)}":` +
                            ` "${sanitize(value.value, request.body.mode, trimRequestBody)}"`;
          });
          requestBody = `${indentation}"data": {\n${bodyMap.join(',\n')}\n${indentation}}\n`;
        }
        return requestBody;
      case 'formdata':
        requestBody = `${indentation}"processData": false,\n` +
                        `${indentation}"mimeType": "multipart/form-data",\n` +
                        `${indentation}"contentType": false,\n` +
                        `${indentation}"data": form\n`;
        return requestBody;
      case 'file':
        requestBody = `${indentation} "data": "<file contents here>"\n`;
        return requestBody;
      default:
        return requestBody;

    }
  }
  return '';
};


/***/ }),

/***/ 5341:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5342);


/***/ }),

/***/ 5342:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5343),
  sanitize = __webpack_require__(4097).sanitize,
  sanitizeOptions = __webpack_require__(4097).sanitizeOptions,
  addFormParam = __webpack_require__(4097).addFormParam,
  path = __webpack_require__(15);

/**
 * Parses URLEncoded body from request
 *
 * @param {*} body URLEncoded Body
 */
function parseURLEncodedBody (body) {
  var payload = [],
    bodySnippet;
  _.forEach(body, function (data) {
    if (!data.disabled) {
      payload.push(`${escape(data.key)}=${escape(data.value)}`);
    }
  });
  bodySnippet = `var data = "${payload.join('&')}";\n`;
  return bodySnippet;
}

/**
 * Parses Raw data
 *
 * @param {*} body Raw body data
 * @param {*} trim trim body option
 * @param {String} contentType Content type of the body being sent
 */
function parseRawBody (body, trim, contentType) {
  var bodySnippet = 'var data = ';
  if (contentType === 'application/json') {
    try {
      let jsonBody = JSON.parse(body);
      bodySnippet += `JSON.stringify(${JSON.stringify(jsonBody)});\n`;
    }
    catch (error) {
      bodySnippet += `"${sanitize(body.toString(), trim)}";\n`;
    }
  }
  else {
    bodySnippet += `"${sanitize(body.toString(), trim)}";\n`;
  }
  return bodySnippet;
}

/**
 * Parses graphql data
 *
 * @param {Object} body graphql body data
 * @param {boolean} trim trim body option
 * @param {String} indentString indentation to be added to the snippet
 */
function parseGraphQL (body, trim, indentString) {
  let query = body.query,
    graphqlVariables,
    bodySnippet;
  try {
    graphqlVariables = JSON.parse(body.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  bodySnippet = 'var data = JSON.stringify({\n';
  bodySnippet += `${indentString}query: "${sanitize(query, trim)}",\n`;
  bodySnippet += `${indentString}variables: ${JSON.stringify(graphqlVariables)}\n`;
  bodySnippet += '});\n';
  return bodySnippet;
}

/**
 * Parses formData body from request
 *
 * @param {*} body formData Body
 * @param {*} trim trim body option
 */
function parseFormData (body, trim) {
  var bodySnippet = 'var data = new FormData();\n';
  _.forEach(body, (data) => {
    if (!(data.disabled)) {
      /* istanbul ignore next */
      /* ignoring because the file src is not stored in postman collection" */
      if (data.type === 'file') {
        var pathArray = data.src.split(path.sep),
          fileName = pathArray[pathArray.length - 1];
        bodySnippet += `data.append("${sanitize(data.key, trim)}", fileInput.files[0], "${fileName}");\n `;
      }
      else {
        bodySnippet += `data.append("${sanitize(data.key, trim)}", "${sanitize(data.value, trim)}");\n`;
      }
    }
  });
  return bodySnippet;
}

/* istanbul ignore next */
/* ignoring because source of file is not stored in postman collection */
/**
 * Parses file body from the Request
 *
 */
function parseFile () {
  // var bodySnippet = 'var data = new FormData();\n';
  // bodySnippet += `data.append("${sanitize(body.key, trim)}", "${sanitize(body.src, trim)}", `;
  // bodySnippet += `"${sanitize(body.key, trim)}");\n`;
  var bodySnippet = 'var data = "<file contents here>";\n';
  return bodySnippet;
}

/**
 * Parses Body from the Request
 *
 * @param {*} body body object from request.
 * @param {*} trim trim body option
 * @param {String} indentString indentation to be added to the snippet
 * @param {String} contentType Content type of the body being sent
 */
function parseBody (body, trim, indentString, contentType) {
  if (!_.isEmpty(body)) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded, trim);
      case 'raw':
        return parseRawBody(body.raw, trim, contentType);
      case 'graphql':
        return parseGraphQL(body.graphql, trim, indentString);
      case 'formdata':
        return parseFormData(body.formdata, trim);
      case 'file':
        return parseFile(body.file, trim);
      default:
        return 'var data = null;\n';
    }
  }
  return 'var data = null;\n';
}

/**
 * Parses headers from the request.
 *
 * @param {Object} headers headers from the request.
 */
function parseHeaders (headers) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    headers = _.reject(headers, 'disabled');
    _.forEach(headers, function (header) {
      headerSnippet += `xhr.setRequestHeader("${sanitize(header.key, true)}", "${sanitize(header.value)}");\n`;
    });
  }
  return headerSnippet;
}

/**
 * Used to get the options specific to this codegen
 *
 * @returns {Array} - Returns an array of option objects
 */
function getOptions () {
  return [
    {
      name: 'Set indentation count',
      id: 'indentCount',
      type: 'positiveInteger',
      default: 2,
      description: 'Set the number of indentation characters to add per code level'
    },
    {
      name: 'Set indentation type',
      id: 'indentType',
      type: 'enum',
      availableOptions: ['Tab', 'Space'],
      default: 'Space',
      description: 'Select the character used to indent lines of code'
    },
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
 * @description Converts Postman sdk request object to nodejs(unirest) code snippet
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {String} options.indentType - type for indentation eg: Space, Tab
 * @param {String} options.indentCount - number of spaces or tabs for indentation.
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
function convert (request, options, callback) {

  if (!_.isFunction(callback)) {
    throw new Error('JS-XHR-Converter: callback is not valid function');
  }
  options = sanitizeOptions(options, getOptions());
  var indent, trim, headerSnippet,
    codeSnippet = '',
    bodySnippet = '';
  indent = options.indentType === 'Tab' ? '\t' : ' ';
  indent = indent.repeat(options.indentCount);
  trim = options.trimRequestBody;

  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
      // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  bodySnippet = request.body && !_.isEmpty(request.body.toJSON()) ? parseBody(request.body.toJSON(), trim,
    indent, request.headers.get('Content-Type')) : '';

  codeSnippet += bodySnippet + '\n';

  codeSnippet += 'var xhr = new XMLHttpRequest();\nxhr.withCredentials = true;\n\n';

  codeSnippet += 'xhr.addEventListener("readystatechange", function() {\n';
  codeSnippet += `${indent}if(this.readyState === 4) {\n`;
  codeSnippet += `${indent.repeat(2)}console.log(this.responseText);\n`;
  codeSnippet += `${indent}}\n});\n\n`;

  codeSnippet += `xhr.open("${request.method}", "${encodeURI(request.url.toString())}");\n`;
  if (options.requestTimeout) {
    codeSnippet += `xhr.timeout = ${options.requestTimeout};\n`;
    codeSnippet += 'xhr.addEventListener("ontimeout", function(e) {\n';
    codeSnippet += `${indent} console.log(e);\n`;
    codeSnippet += '});\n';
  }
  if (request.body && request.body.mode === 'graphql' && !request.headers.has('Content-Type')) {
    request.addHeader({
      key: 'Content-Type',
      value: 'application/json'
    });
  }
  headerSnippet = parseHeaders(request.toJSON().header);

  codeSnippet += headerSnippet + '\n';

  codeSnippet += request.body && !_.isEmpty(request.body.toJSON()) ? 'xhr.send(data);' : 'xhr.send();';
  callback(null, codeSnippet);
}

module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 5343:
/***/ (function(module, exports) {

/* istanbul ignore file */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5344:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5345);


/***/ }),

/***/ 5345:
/***/ (function(module, exports, __webpack_require__) {

var sanitize = __webpack_require__(4098).sanitize,
  sanitizeOptions = __webpack_require__(4098).sanitizeOptions,
  addFormParam = __webpack_require__(4098).addFormParam,
  _ = __webpack_require__(5346),
  self;

self = module.exports = {
  convert: function (request, options, callback) {

    if (!_.isFunction(callback)) {
      throw new Error('Curl-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());

    var trim, headersData, body, text,
      snippet = '',
      formCheck,
      formdataString = '',
      protocol,
      BOUNDARY = '----WebKitFormBoundary7MA4YWxkTrZu0gW',
      timeout,
      followRedirect,
      indent = options.indentType === 'Tab' ? '\t' : ' ',
      indentString = indent.repeat(options.indentCount),
      headerSnippet = '',
      footerSnippet = '';
    if (options.includeBoilerplate) {
      headerSnippet = '#include <stdio.h>\n#include <string.h>\n#include <curl/curl.h>\n' +
      'int main(int argc, char *argv[]){\n';
      footerSnippet = 'return (int)res;\n}';
    }
    trim = options.trimRequestBody;
    protocol = options.protocol;
    timeout = options.requestTimeout;
    followRedirect = options.followRedirect;
    snippet += 'CURL *curl;\n';
    snippet += 'CURLcode res;\n';
    snippet += 'curl = curl_easy_init();\n';
    snippet += 'if(curl) {\n';
    snippet += indentString + `curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "${request.method}");\n`;
    snippet += indentString +
    `curl_easy_setopt(curl, CURLOPT_URL, "${encodeURI(request.url.toString())}");\n`;
    if (timeout) {
      snippet += indentString + `curl_easy_setopt(curl, CURLOPT_TIMEOUT_MS, ${timeout}L);\n`;
    }
    if (followRedirect) {
      snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1L);\n';
    }
    snippet += indentString + `curl_easy_setopt(curl, CURLOPT_DEFAULT_PROTOCOL, "${protocol}");\n`;
    snippet += indentString + 'struct curl_slist *headers = NULL;\n';
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    headersData = request.toJSON().header;
    if (headersData) {
      headersData = _.reject(headersData, 'disabled');
      _.forEach(headersData, function (header) {
        snippet += indentString + `headers = curl_slist_append(headers, "${sanitize(header.key, true)}:` +
      ` ${sanitize(header.value)}");\n`;
      });
    }
    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        if (type === 'file') {
          if (typeof param.src !== 'string') {
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }

    body = request.body ? request.body.toJSON() : {};
    if (body.mode && body.mode === 'formdata' && !options.useMimeType) {
      snippet += indentString + 'headers = curl_slist_append(headers, "content-type:' +
                ` multipart/form-data; boundary=${BOUNDARY}");\n`;
    }
    snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_HTTPHEADER, headers);\n';
    if (request.method === 'HEAD') {
      snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);\n';
    }

    // request body
    if (!_.isEmpty(body)) {
      switch (body.mode) {
        case 'urlencoded':
          text = [];
          _.forEach(body.urlencoded, function (data) {
            if (!data.disabled) {
              text.push(`${escape(data.key)}=${escape(data.value)}`);
            }
          });
          snippet += indentString + `const char *data = "${text.join('&')}";\n`;
          snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n';
          break;
        case 'raw':
          snippet += indentString + `const char *data = "${sanitize(body.raw.toString(), trim)}";\n`;
          snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n';
          break;
        // eslint-disable-next-line no-case-declarations
        case 'graphql':
          let query = body.graphql.query,
            graphqlVariables;
          try {
            graphqlVariables = JSON.parse(body.graphql.variables);
          }
          catch (e) {
            graphqlVariables = {};
          }
          snippet += indentString + `const char *data = "${sanitize(JSON.stringify({
            query: query,
            variables: graphqlVariables
          }), trim)}";\n`;
          snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n';
          break;
        case 'formdata':
          if (options.useMimeType) {
            snippet += indentString + 'curl_mime *mime;\n';
            snippet += indentString + 'curl_mimepart *part;\n';
            snippet += indentString + 'mime = curl_mime_init(curl);\n';
            snippet += indentString + 'part = curl_mime_addpart(mime);\n';
            formCheck = false;

            _.forEach(body.formdata, function (data) {
              if (!(data.disabled)) {
                if (formCheck) {
                  snippet += indentString + 'part = curl_mime_addpart(mime);\n';
                }
                else {
                  formCheck = true;
                }
                if (data.type === 'file') {
                  snippet += indentString + `curl_mime_name(part, "${sanitize(data.key, trim)}");\n`;
                  snippet += indentString + `curl_mime_filedata(part, "${sanitize(data.src, trim)}");\n`;
                }
                else {
                  snippet += indentString + `curl_mime_name(part, "${sanitize(data.key, trim)}");\n`;
                  snippet += indentString +
                  `curl_mime_data(part, "${sanitize(data.value, trim)}", CURL_ZERO_TERMINATED);\n`;
                }
              }
            });
            snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_MIMEPOST, mime);\n';
          }
          else {
            BOUNDARY = '--' + BOUNDARY;
            _.forEach(body.formdata, function (data) {
              if (!data.disabled) {
                formdataString += `${BOUNDARY}\\r\\nContent-Disposition: form-data; name=\\"${sanitize(data.key)}\\"`;
                if (data.type === 'file') {
                  formdataString += `; filename=\\"${sanitize(data.src)}\\"\\r\\nContent-type: ` +
                  '<Content-Type Header>\\r\\n\\r\\n<file contents here>\\r\\n';
                }
                else {
                  formdataString += `\\r\\n\\r\\n${sanitize(data.value)}\\r\\n`;
                }
              }
            });
            formdataString += BOUNDARY + '--';
            snippet += indentString + `curl_easy_setopt(curl, CURLOPT_POSTFIELDS, "${formdataString}");\n`;
          }
          break;
        case 'file':
          snippet += indentString + 'curl_easy_setopt(curl,CURLOPT_POSTFIELDS,"<file contents here>");\n';
          // `const char *data = "${sanitize(body.key, trim)}=@${sanitize(body.value, trim)}";\n`;
          // snippet += indentString + 'curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);\n';
          break;
        default:
          snippet = String(snippet);
      }
    }

    snippet += indentString + 'res = curl_easy_perform(curl);\n';
    if (body.mode === 'formdata' && options.useMimeType) {
      snippet += indentString + 'curl_mime_free(mime);\n';
    }
    snippet += '}\n';
    snippet += 'curl_easy_cleanup(curl);\n';
    (options.includeBoilerplate) &&
    (snippet = indentString + snippet.split('\n').join('\n' + indentString));
    callback(null, headerSnippet + snippet + footerSnippet);
  },
  getOptions: function () {
    return [
      {
        name: 'Include boilerplate',
        id: 'includeBoilerplate',
        type: 'boolean',
        default: false,
        description: 'Include class definition and import statements in snippet'
      },
      {
        name: 'Protocol',
        id: 'protocol',
        type: 'enum',
        availableOptions: ['http', 'https'],
        default: 'https',
        description: 'The protocol to be used to make the request'
      },
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        availableOptions: ['Tab', 'Space'],
        default: 'Space',
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Use curl_mime',
        id: 'useMimeType',
        type: 'boolean',
        default: true,
        description: 'Use curl_mime to send multipart/form-data requests'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      }
    ];
  }
};


/***/ }),

/***/ 5346:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];

    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });

    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];

    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });

    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }

    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }

    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }

    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';

    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;

    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }

    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;

    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }

    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }

    return true;
  }

};


/***/ }),

/***/ 5347:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5348);


/***/ }),

/***/ 5348:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4381).convert,
  getOptions: __webpack_require__(4381).getOptions
};


/***/ }),

/***/ 5349:
/***/ (function(module, exports, __webpack_require__) {

const _ = __webpack_require__(4382),

  sanitize = __webpack_require__(4099).sanitize,
  path = __webpack_require__(15);

/**
 * parses body of request when type of the request body is formdata or urlencoded and
 * returns code snippet for nodejs to add body
 *
 * @param {Array<Object>} dataArray - array containing body elements of request
 * @param {String} indentString - string required for indentation
 * @param {Boolean} trimBody - indicates whether to trim body or not
 */
function extractFormData (dataArray, indentString, trimBody) {
  if (!dataArray) {
    return '';
  }
  var snippetString = _.reduce(dataArray, (accumalator, item) => {
    if (item.disabled) {
      return accumalator;
    }

    accumalator.push(
      indentString + `'${sanitize(item.key, trimBody)}': '${sanitize(item.value, trimBody)}'`
    );

    return accumalator;
  }, []);
  return snippetString.join(',\n');
}

/**
 * Generates multipart form data snippet
 *
 * @param {*} requestbody
 */
function generateMultipartFormData (requestbody) {
  const boundary = '------WebKitFormBoundary7MA4YWxkTrZu0gW\\r\\nContent-Disposition: form-data; ',
    dataArray = requestbody[requestbody.mode],
    postData = '"' + boundary + _.reduce(dataArray, (accumalator, dataArrayElement) => {
      if (!dataArrayElement.disabled || dataArrayElement.disabled === false) {
        const key = dataArrayElement.key.replace(/"/g, '\'');

        if (dataArrayElement.type === 'file') {
          var pathArray = dataArrayElement.src.split(path.sep),
            fileName = pathArray[pathArray.length - 1];
          const filename = `filename=\\"${fileName}\\"`,
            contentType = 'Content-Type: \\"{Insert_File_Content_Type}\\"',
            fileContent = `fs.readFileSync('${dataArrayElement.src}')`;

          // eslint-disable-next-line max-len
          accumalator.push(`name=\\"${key}\\"; ${filename}\\r\\n${contentType}\\r\\n\\r\\n" + ${fileContent} + "\\r\\n`);
        }
        else {
          // eslint-disable-next-line no-useless-escape
          const value = dataArrayElement.value.replace(/\\/g, '\\\\').replace(/"/g, '\\"');
          accumalator.push(`name=\\"${key}\\"\\r\\n\\r\\n${value}\\r\\n`);
        }
      }
      return accumalator;
      // eslint-disable-next-line no-useless-escape
    }, []).join(`${boundary}`) + '------WebKitFormBoundary7MA4YWxkTrZu0gW--\"';

  return postData;
}

/**
 * Parses body object based on mode of body and returns code snippet
 *
 * @param {Object} requestbody - json object for body of request
 * @param {String} indentString - string for indentation
 * @param {Boolean} trimBody - indicates whether to trim body fields or not
 * @param {String} contentType Content type of the body being sent
 */
function parseBody (requestbody, indentString, trimBody, contentType) {
  if (requestbody) {
    switch (requestbody.mode) {
      case 'raw':
        if (contentType === 'application/json') {
          try {
            let jsonBody = JSON.parse(requestbody[requestbody.mode]);
            return `JSON.stringify(${JSON.stringify(jsonBody)})`;
          }
          catch (error) {
            return ` ${JSON.stringify(requestbody[requestbody.mode])}`;
          }
        }
        return ` ${JSON.stringify(requestbody[requestbody.mode])}`;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = requestbody[requestbody.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(requestbody[requestbody.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        return 'JSON.stringify({\n' +
        `${indentString}query: "${sanitize(query, trimBody)}",\n` +
        `${indentString}variables: ${JSON.stringify(graphqlVariables)}\n})`;
      case 'formdata':
        return generateMultipartFormData(requestbody);
      case 'urlencoded':
        return `qs.stringify({\n${extractFormData(requestbody[requestbody.mode], indentString, trimBody)}` +
                    '\n})';
      case 'file':
        return '"<file contents here>"';
      default:
        return '';
    }
  }
  return '';
}

/**
 * parses header of request object and returns code snippet of nodejs native to add header
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required in code snippet
 * @returns {String} - code snippet of nodejs native to add header
 */
function parseHeader (request, indentString) {
  var headerObject = request.getHeaders({enabled: true}),
    headerSnippet = indentString + '\'headers\': {\n';

  if (headerObject) {
    headerSnippet += _.reduce(Object.keys(headerObject), function (accumalator, key) {
      if (Array.isArray(headerObject[key])) {
        var headerValues = [];
        _.forEach(headerObject[key], (value) => {
          headerValues.push(`'${sanitize(value)}'`);
        });
        accumalator.push(
          indentString.repeat(2) + `'${sanitize(key, true)}': [${headerValues.join(', ')}]`
        );
      }
      else {
        accumalator.push(
          indentString.repeat(2) + `'${sanitize(key, true)}': '${sanitize(headerObject[key])}'`
        );
      }
      return accumalator;
    }, []).join(',\n');
  }

  if (headerObject && !_.isEmpty(headerObject)) {
    headerSnippet += '\n';
  }

  headerSnippet += indentString + '}';
  return headerSnippet;
}

/**
 * parses host of request object and returns code snippet of nodejs native to add hostname
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required in code snippet
 * @returns {String} - code snippet of nodejs native to add hostname
 */
function parseHost (request, indentString) {
  var hostArray = _.get(request, 'url.host', []),
    hostSnippet = indentString + '\'hostname\': \'';

  if (hostArray.length) {
    hostSnippet += _.reduce(hostArray, function (accumalator, key) {
      accumalator.push(`${sanitize(key)}`);
      return accumalator;
    }, []).join('.');
  }

  hostSnippet += '\'';

  return hostSnippet;
}

/**
 * parses port of request object and returns code snippet of nodejs native to add port
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required in code snippet
 * @returns {String} - code snippet of nodejs native to add port
 */
function parsePort (request, indentString) {
  var port = _.get(request, 'url.port', ''),
    portSnippet = '';
  if (port) {
    portSnippet += `${indentString}'port': ${port}`;
  }
  return portSnippet;
}

/**
 * parses path of request object and returns code snippet of nodejs native to add path
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required in code snippet
 * @returns {String} - code snippet of nodejs native to add path
 */
function parsePath (request, indentString) {
  var pathArray = _.get(request, 'url.path'),
    queryArray = _.get(request.toJSON(), 'url.query'),
    pathSnippet = indentString + '\'path\': \'/',
    querySnippet = '';

  if (pathArray && pathArray.length) {
    pathSnippet += sanitize(_.reduce(pathArray, function (accumalator, key) {
      if (key.length) {
        accumalator.push(`${sanitize(key)}`);
      }
      else {
        accumalator.push('');
      }
      return accumalator;
    }, []).join('/'));
  }

  if (queryArray && queryArray.length) {
    const queryExists = !(_.every(queryArray, function (element) {
      return element.disabled && element.disabled === false;
    }));

    if (queryExists) {
      querySnippet += '?' + _.reduce(queryArray, function (accumalator, queryElement) {
        if (!queryElement.disabled || _.get(queryElement, 'disabled') === false) {
          accumalator.push(`${queryElement.key}=${sanitize(encodeURIComponent(queryElement.value))}`);
        }
        return accumalator;
      }, []).join('&');
    }
  }
  pathSnippet += querySnippet + '\'';
  return pathSnippet;
}

/**
 * parses variable of request url object and sets hostname, path and query in request object
 *
 * @param {Object} request - Postman SDK request object
 */
function parseURLVariable (request) {
  const variableArray = _.get(request.toJSON(), 'url.variable', []);

  if (!variableArray.length) {
    return;
  }

  variableArray.forEach(function (variableArrayElement) {
    request.url.host.forEach(function (hostArrayElement, hostArrayElementIndex) {
      if (hostArrayElement === ':' + variableArrayElement.key) {
        request.url.host[hostArrayElementIndex] = variableArrayElement.value;
      }
    });

    request.url.path.forEach(function (pathArrayElement, pathArrayElementIndex) {
      if (pathArrayElement === ':' + variableArrayElement.key) {
        request.url.path[pathArrayElementIndex] = variableArrayElement.value;
      }
    });

    request.toJSON().url.query.forEach(function (queryArrayElement, queryArrayElementIndex) {
      if (queryArrayElement === ':' + variableArrayElement.key) {
        request.url.query[queryArrayElementIndex] = variableArrayElement.value;
      }
    });
  });
}

module.exports = {
  parseBody: parseBody,
  parseHeader: parseHeader,
  parseHost: parseHost,
  parsePort: parsePort,
  parsePath: parsePath,
  parseURLVariable: parseURLVariable
};


/***/ }),

/***/ 5350:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5351);


/***/ }),

/***/ 5351:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4383).convert,
  getOptions: __webpack_require__(4383).getOptions
};


/***/ }),

/***/ 5352:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4384),

  sanitize = __webpack_require__(4100).sanitize,
  path = __webpack_require__(15);

/**
 * parses body of request when type of the request body is formdata or urlencoded and
 * returns code snippet for nodejs to add body
 *
 * @param {Array<Object>} dataArray - array containing body elements of request
 * @param {String} indentString - string required for indentation
 * @param {Boolean} trimBody - indicates whether to trim body or not
 */
function extractFormData (dataArray, indentString, trimBody) {
  if (!dataArray) {
    return '';
  }
  var snippetString = _.reduce(dataArray, (accumalator, item) => {
    if (item.disabled) {
      return accumalator;
    }
    /* istanbul ignore next */
    if (item.type === 'file') {
      /**
             * creating snippet to send file in nodejs request
             * for example:
             *  'fieldname': {
             *      'value': fs.createStream('filename.ext'),
             *      'options': {
             *          'filename': 'filename.ext',
             *          'contentType: null
             *          }
             *      }
             *  }
             */
      if (Array.isArray(item.src) && item.src.length) {
        let fileSnippet = '',
          fileArray = [];
        _.forEach(item.src, (filePath) => {
          fileArray.push(`${indentString.repeat(3)}fs.createReadStream('${sanitize(filePath, trimBody)}')`);
        });
        if (fileArray.length) {
          fileSnippet += `${indentString.repeat(2)}'${sanitize(item.key, trimBody)}': ` +
          `[\n${fileArray.join(',\n')}\n${indentString.repeat(2)}]`;
          accumalator.push(fileSnippet);
        }
        else {
          return accumalator;
        }
      }
      else if (typeof item.src !== 'string') {
        accumalator.push([
          indentString.repeat(2) + `'${sanitize(item.key, trimBody)}': {`,
          indentString.repeat(3) + '\'value\': fs.createReadStream(\'/path/to/file\'),',
          indentString.repeat(3) + '\'options\': {',
          indentString.repeat(4) + '\'filename\': \'filename\'',
          indentString.repeat(4) + '\'contentType\': null',
          indentString.repeat(3) + '}',
          indentString.repeat(2) + '}'
        ].join('\n'));
      }
      else {
        var pathArray = item.src.split(path.sep),
          fileName = pathArray[pathArray.length - 1];
        accumalator.push([
          indentString.repeat(2) + `'${sanitize(item.key, trimBody)}': {`,
          indentString.repeat(3) + `'value': fs.createReadStream('${sanitize(item.src, trimBody)}'),`,
          indentString.repeat(3) + '\'options\': {',
          indentString.repeat(4) + `'filename': '${sanitize(fileName, trimBody)}',`,
          indentString.repeat(4) + '\'contentType\': null',
          indentString.repeat(3) + '}',
          indentString.repeat(2) + '}'
        ].join('\n'));
      }
    }
    else {
      accumalator.push(
        indentString.repeat(2) +
                `'${sanitize(item.key, trimBody)}': '${sanitize(item.value, trimBody)}'`
      );
    }
    return accumalator;
  }, []);
  return snippetString.join(',\n') + '\n';
}

/**
 * Parses body object based on mode of body and returns code snippet
 *
 * @param {Object} requestbody - json object for body of request
 * @param {String} indentString - string for indentation
 * @param {Boolean} trimBody - indicates whether to trim body fields or not
 * @param {String} contentType Content type of the body being sent
 */
function parseBody (requestbody, indentString, trimBody, contentType) {
  if (requestbody) {
    switch (requestbody.mode) {
      case 'raw':
        if (contentType === 'application/json') {
          try {
            let jsonBody = JSON.parse(requestbody[requestbody.mode]);
            return `body: JSON.stringify(${JSON.stringify(jsonBody)})\n`;
          }
          catch (error) {
            return `body: ${JSON.stringify(requestbody[requestbody.mode])}\n`;
          }
        }
        return `body: ${JSON.stringify(requestbody[requestbody.mode])}\n`;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = requestbody[requestbody.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(requestbody[requestbody.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        return 'body: JSON.stringify({\n' +
          `${indentString.repeat(2)}query: '${sanitize(query, trimBody)}',\n` +
          `${indentString.repeat(2)}variables: ${JSON.stringify(graphqlVariables)}\n` +
          `${indentString}})`;
      case 'formdata':
        return `formData: {\n${extractFormData(requestbody[requestbody.mode], indentString, trimBody)}` +
                        indentString + '}';
      case 'urlencoded':
        return `form: {\n${extractFormData(requestbody[requestbody.mode], indentString, trimBody)}` +
                        indentString + '}';
        /* istanbul ignore next */
      case 'file':
        // return 'formData: {\n' +
        //                 extractFormData(requestbody[requestbody.mode], indentString, trimBody) +
        //                 indentString + '}';
        return 'body: "<file contents here>"\n';
      default:
        return '';
    }
  }
  return '';
}

/**
 * parses header of request object and returns code snippet of nodejs request to add header
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required in code snippet
 * @returns {String} - code snippet of nodejs request to add header
 */
function parseHeader (request, indentString) {
  var headerObject = request.getHeaders({enabled: true}),
    headerSnippet = indentString + '\'headers\': {\n';

  if (!_.isEmpty(headerObject)) {
    headerSnippet += _.reduce(Object.keys(headerObject), function (accumalator, key) {
      if (Array.isArray(headerObject[key])) {
        var headerValues = [];
        _.forEach(headerObject[key], (value) => {
          headerValues.push(`'${sanitize(value)}'`);
        });
        accumalator.push(
          indentString.repeat(2) + `'${sanitize(key, true)}': [${headerValues.join(', ')}]`
        );
      }
      else {
        accumalator.push(
          indentString.repeat(2) + `'${sanitize(key, true)}': '${sanitize(headerObject[key])}'`
        );
      }
      return accumalator;
    }, []).join(',\n') + '\n';
  }

  headerSnippet += indentString + '}';
  return headerSnippet;
}

module.exports = {
  parseBody: parseBody,
  parseHeader: parseHeader
};


/***/ }),

/***/ 5353:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5354);


/***/ }),

/***/ 5354:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4385).convert,
  getOptions: __webpack_require__(4385).getOptions
};


/***/ }),

/***/ 5355:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4386),

  sanitize = __webpack_require__(3983).sanitize;


/**
 * parses body of request when mode of body is formdata and
 * returns code snippet for nodejs to send body
 *
 * @param {Array<Object>} bodyArray - array containing body elements of request
 * @param {String} indentString - string required for indentation
 * @param {Boolean} trimBody - indicates whether to trim body fields or not
 */
function parseMultipart (bodyArray, indentString, trimBody) {
  return _.reduce(bodyArray, function (bodyString, item) {
    if (item.disabled) {
      return bodyString;
    }
    /* istanbul ignore next */
    if (item.type === 'file') {
      bodyString += indentString + `.attach('file', '${sanitize(item.src, trimBody)}')\n`;
    }
    else {
      bodyString += indentString +
                          `.field('${sanitize(item.key, trimBody)}', '${sanitize(item.value, trimBody)}')\n`;
    }
    return bodyString;
  }, '');
}

/**
 * parses body of request when mode of body is urlencoded and
 * returns code snippet for nodejs to send body
 *
 * @param {Array<Object>} bodyArray - data containing body elements of request
 * @param {String} indentString - string required for indentation
 * @param {Boolean} trimBody - indicates whether to trim body fields or not
 */
function parseFormdata (bodyArray, indentString, trimBody) {
  return _.reduce(bodyArray, function (bodyString, item) {
    if (item.disabled) {
      return bodyString;
    }
    bodyString += indentString +
      '.send(' + `'${sanitize(item.key, trimBody)}=${sanitize(item.value, trimBody)}'`.replace(/&/g, '%26') + ')\n';
    return bodyString;
  }, '');
}

/**
 * Parses body object based on mode of body and converts into nodejs(unirest) code snippet
 *
 * @param {Object} requestbody - json object representing body of request
 * @param {String} indentString - string required for indentation
 * @param {Boolean} trimBody - indicates whether to trim body fields or not
 * @param {String} contentType Content type of the body being sent
 * @returns {String} - code snippet for adding body in request
 */
function parseBody (requestbody, indentString, trimBody, contentType) {
  if (requestbody) {
    switch (requestbody.mode) {
      case 'raw':
        if (contentType === 'application/json') {
          try {
            let jsonBody = JSON.parse(requestbody[requestbody.mode]);
            return `${indentString}.send(JSON.stringify(${JSON.stringify(jsonBody)}))\n`;
          }
          catch (error) {
            return indentString + '.send(' + JSON.stringify(requestbody[requestbody.mode]) + ')\n';
          }
        }
        return indentString + '.send(' + JSON.stringify(requestbody[requestbody.mode]) + ')\n';
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = requestbody[requestbody.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(requestbody[requestbody.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        return indentString + '.send(JSON.stringify({\n' +
          `${indentString.repeat(2)}query: '${sanitize(query, trimBody)}',\n` +
          `${indentString.repeat(2)}variables: ${JSON.stringify(graphqlVariables)}\n` +
          `${indentString}}))\n`;
      case 'urlencoded':
        return parseFormdata(requestbody[requestbody.mode], indentString, trimBody);
      case 'formdata':
        return parseMultipart(requestbody[requestbody.mode], indentString, trimBody);
        /* istanbul ignore next */
      case 'file':
        return '.send("<file contents here>")\n';
      default:
        return '';
    }
  }
  return '';
}

/**
 * parses header of request object and returns code snippet of nodejs unirest to add header
 *
 * @param {Object} request - Postman SDK request object
 * @param {String} indentString - indentation required in code snippet
 * @returns {String} - code snippet of nodejs unirest to add header
 */
function parseHeader (request, indentString) {
  var headerObject = request.getHeaders({enabled: true}),
    headerSnippet = '';

  if (!_.isEmpty(headerObject)) {
    headerSnippet += indentString + '.headers({\n';

    headerSnippet += _.reduce(Object.keys(headerObject), function (accumalator, key) {
      if (Array.isArray(headerObject[key])) {
        var headerValues = [];
        _.forEach(headerObject[key], (value) => {
          headerValues.push(`'${sanitize(value)}'`);
        });
        accumalator.push(
          indentString.repeat(2) + `'${sanitize(key, true)}': [${headerValues.join(', ')}]`
        );
      }
      else {
        accumalator.push(
          indentString.repeat(2) + `'${sanitize(key, true)}': '${sanitize(headerObject[key])}'`
        );
      }
      return accumalator;
    }, []).join(',\n') + '\n';

    headerSnippet += indentString + '})\n';
  }
  return headerSnippet;
}

module.exports = {
  parseBody: parseBody,
  parseHeader: parseHeader
};


/***/ }),

/***/ 5356:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5357);


/***/ }),

/***/ 5357:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5358),
  sanitizeOptions = __webpack_require__(4101).sanitizeOptions,
  sanitize = __webpack_require__(4101).sanitize,
  addFormParam = __webpack_require__(4101).addFormParam,
  self;

/**
 * Parses Raw data
 *
 * @param {Object} body Raw body data
 * @param {String} indent indentation required for code snippet
 * @param {Boolean} trim indicates whether to trim string or not
 */
function parseRawBody (body, indent, trim) {
  var bodySnippet = '';
  bodySnippet += 'NSData *postData = [[NSData alloc] initWithData:[@"' + sanitize(body.toString(), trim) + '" ' +
  'dataUsingEncoding:NSUTF8StringEncoding]];\n';
  bodySnippet += '[request setHTTPBody:postData];\n';
  return bodySnippet;
}

/**
 * Parses GraphQL body
 *
 * @param {Object} body GraphQL body
 * @param {String} indent indentation required for code snippet
 * @param {Boolean} trim indicates whether to trim string or not
 */
function parseGraphQLBody (body, indent, trim) {
  var bodySnippet = '',
    rawBody = JSON.stringify(body);
  bodySnippet += 'NSData *postData = [[NSData alloc] initWithData:[@"' + sanitize(rawBody, trim) + '" ' +
  'dataUsingEncoding:NSUTF8StringEncoding]];\n';
  bodySnippet += '[request setHTTPBody:postData];\n';
  return bodySnippet;
}

/**
 * Parses URLEncoded body
 *
 * @param {Object} body URLEncoded Body
 * @param {String} indent indentation required for code snippet
 * @param {Boolean} trim indicates whether to trim string or not
 */
function parseURLEncodedBody (body, indent, trim) {
  let bodySnippet = '',
    key,
    value,
    first = true;
  _.forEach(body, function (data) {
    if (!data.disabled) {
      key = trim ? data.key.trim() : data.key;
      value = trim ? data.value.trim() : data.value;
      if (first) {
        bodySnippet += 'NSMutableData *postData = [[NSMutableData alloc] initWithData:[@"' +
        sanitize(key, true) + '=' + sanitize(value, trim) + '" dataUsingEncoding:NSUTF8StringEncoding]];\n';
      }
      else {
        bodySnippet += '[postData appendData:[@"&' + sanitize(key, true) + '=' + sanitize(value, trim) +
        '" dataUsingEncoding:NSUTF8StringEncoding]];\n';
      }
      first = false;
    }
  });
  bodySnippet += '[request setHTTPBody:postData];\n';
  return bodySnippet;
}

/**
 * Parses form data body from request
 *
 * @param {Object} body form data Body
 * @param {String} indent indentation required for code snippet
 * @param {Boolean} trim indicates whether to trim string or not
 */
function parseFormData (body, indent, trim) {
  let bodySnippet = '',
    formDataArray = [],
    key,
    foundFile = false,
    value;

  if (_.isEmpty(body)) {
    return bodySnippet;
  }

  bodySnippet += 'NSArray *parameters = @[';

  _.forEach(body, function (data) {
    key = trim ? data.key.trim() : data.key;
    value = trim ? data.value.trim() : data.value;
    if (!data.disabled) {
      if (data.type === 'file') {
        foundFile = true;
        formDataArray.push(`\n${indent}@{ @"name": @"${key}", @"fileName": @"${data.src}" }`);
      }
      else {
        formDataArray.push(`\n${indent}@{ @"name": @"${key}", @"value": @"${sanitize(value, trim)}" }`);
      }
    }
  });
  bodySnippet += formDataArray.join(', ');
  bodySnippet += ' \n];\n';
  bodySnippet += '\nNSString *boundary = @"----WebKitFormBoundary7MA4YWxkTrZu0gW";\n';
  bodySnippet += 'NSError *error;\n';
  bodySnippet += 'NSMutableString *body = [NSMutableString string];\n';
  bodySnippet += '\nfor (NSDictionary *param in parameters) {\n';
  bodySnippet += indent + '[body appendFormat:@"--%@\\r\\n", boundary];\n';
  if (foundFile) {
    bodySnippet += indent + 'if (param[@"fileName"]) {\n';
    // eslint-disable-next-line max-len
    bodySnippet += indent.repeat(2) + '[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"; filename=\\"%@\\"\\r\\n", param[@"name"], param[@"fileName"]];\n';
    bodySnippet += indent.repeat(2) + '[body appendFormat:@"Content-Type: %@\\r\\n\\r\\n", param[@"contentType"]];\n';
    // eslint-disable-next-line max-len
    bodySnippet += indent.repeat(2) + '[body appendFormat:@"%@", [NSString stringWithContentsOfFile:param[@"fileName"]' +
      ' encoding:NSUTF8StringEncoding error:&error]];\n';
    bodySnippet += indent.repeat(2) + 'if (error) {\n';
    bodySnippet += indent.repeat(3) + 'NSLog(@"%@", error);\n';
    bodySnippet += indent.repeat(2) + '}\n';
    bodySnippet += indent + '} else {\n';
    bodySnippet += indent.repeat(2) +
      '[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"\\r\\n\\r\\n", param[@"name"]];\n';
    bodySnippet += indent.repeat(2) + '[body appendFormat:@"%@", param[@"value"]];\n';
    bodySnippet += indent + '}\n';
  }
  else {
    bodySnippet += indent +
      '[body appendFormat:@"Content-Disposition:form-data; name=\\"%@\\"\\r\\n\\r\\n", param[@"name"]];\n';
    bodySnippet += indent + '[body appendFormat:@"%@", param[@"value"]];\n';
  }
  bodySnippet += '}\n';
  bodySnippet += '[body appendFormat:@"\\r\\n--%@--\\r\\n", boundary];\n';
  bodySnippet += 'NSData *postData = [body dataUsingEncoding:NSUTF8StringEncoding];\n';
  bodySnippet += '[request setHTTPBody:postData];\n';
  return bodySnippet;
}

/**
 * Parses Body from the Request
 *
 * @param {Object} body body object from request.
 * @param {String} indent indentation required for code snippet
 * @param {trim} trim indicates whether to trim string or not
 */
function parseBody (body, indent, trim) {
  if (!_.isEmpty(body)) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded, indent, trim);
      case 'raw':
        return parseRawBody(body.raw, indent, trim);
      case 'formdata':
        return parseFormData(body.formdata, indent, trim);
      case 'file':
        return '';
      case 'graphql':
        return parseGraphQLBody(body.graphql, indent, trim);
      default:
        return '<file-content-here>';
    }
  }
  return '';
}

/**
 * Parses headers from the request.
 *
 * @param {Object} headersArray array containing headers
 * @param {String} indent indentation required for code snippet
 * @param {Boolean} trim indicates whether to trim string or not
 */
function parseHeaders (headersArray, indent, trim) {
  var headerString = '',
    headerDictionary = [];
  if (_.isEmpty(headersArray)) {
    return headerString;
  }
  headerString = 'NSDictionary *headers = @{\n';

  _.forEach(headersArray, function (header) {
    if (!header.disabled) {
      headerDictionary.push(indent + '@"' + header.key + '": @"' + sanitize(header.value, trim) + '"');
    }
  });
  headerString += headerDictionary.join(',\n');
  headerString += '\n};\n\n';
  headerString += '[request setAllHTTPHeaderFields:headers];\n';
  return headerString;
}

self = module.exports = {
  convert: function (request, options, callback) {
    var indent,
      codeSnippet = '',
      requestTimeout,
      headerSnippet = '#import <Foundation/Foundation.h>\n\n',
      footerSnippet = '',
      trim;
    options = sanitizeOptions(options, self.getOptions());
    trim = options.trimRequestBody;
    indent = options.indentType === 'tab' ? '\t' : ' ';
    indent = indent.repeat(options.indentCount);

    requestTimeout = options.requestTimeout / 1000; // Objective-C takes time in seconds.

    if (!_.isFunction(callback)) {
      throw new Error('Callback is not valid function');
    }

    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        if (type === 'file') {
          if (typeof param.src !== 'string') {
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    if (options.includeBoilerplate) {
      headerSnippet += 'int main(int argc, const char * argv[]) {\n\n';
      footerSnippet += '}';
    }
    codeSnippet += 'dispatch_semaphore_t sema = dispatch_semaphore_create(0);\n\n';
    codeSnippet += 'NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@"' +
      encodeURI(request.url.toString()) + '"]\n';
    codeSnippet += `${indent}cachePolicy:NSURLRequestUseProtocolCachePolicy\n`;
    codeSnippet += `${indent}timeoutInterval:${requestTimeout}.0];\n`;

    // TODO: use defaultSessionConfiguration
    // codeSnippet += 'NSURLSessionConfiguration *config = [NSURLSessionConfiguration defaultSessionConfiguration];\n';

    codeSnippet += parseHeaders(request.headers.toJSON(), indent, trim);
    codeSnippet += parseBody(request.body ? request.body.toJSON() : {}, indent, trim) + '\n';
    codeSnippet += '[request setHTTPMethod:@"' + request.method + '"];\n\n';
    codeSnippet += 'NSURLSession *session = [NSURLSession sharedSession];\n';
    codeSnippet += 'NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request\n';
    codeSnippet += 'completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n';
    codeSnippet += `${indent}if (error) {\n`;
    codeSnippet += `${indent.repeat(2)}NSLog(@"%@", error);\n`;
    codeSnippet += `${indent}} else {\n`;
    codeSnippet += `${indent.repeat(2)}NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *) response;\n`;
    codeSnippet += `${indent.repeat(2)}NSError *parseError = nil;\n`;
    // eslint-disable-next-line max-len
    codeSnippet += `${indent.repeat(2)}NSDictionary *responseDictionary = [NSJSONSerialization JSONObjectWithData:data options:0 error:&parseError];\n`;
    codeSnippet += `${indent.repeat(2)}NSLog(@"%@",responseDictionary);\n`;
    codeSnippet += `${indent.repeat(2)}dispatch_semaphore_signal(sema);\n`;
    codeSnippet += `${indent}}\n`;
    codeSnippet += '}];\n';
    codeSnippet += '[dataTask resume];\n';
    codeSnippet += 'dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);';

    //  if boilerplate is included then two more indent needs to be added in snippet
    (options.includeBoilerplate) &&
    (codeSnippet = indent + codeSnippet.split('\n').join('\n' + indent) + '\n');

    callback(null, headerSnippet + codeSnippet + footerSnippet);
  },
  getOptions: function () {
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        availableOptions: ['Tab', 'Space'],
        default: 'Space',
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        // Using 10 secs as default
        // TODO: Find out a way to set infinite timeout.
        default: 10000,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Include boilerplate',
        id: 'includeBoilerplate',
        type: 'boolean',
        default: false,
        description: 'Include class definition and import statements in snippet'
      }
    ];
  }
};


/***/ }),

/***/ 5358:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5359:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5360);


/***/ }),

/***/ 5360:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4387).convert,
  getOptions: __webpack_require__(4387).getOptions
};


/***/ }),

/***/ 5361:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5362:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5363);


/***/ }),

/***/ 5363:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4388).convert,
  getOptions: __webpack_require__(4388).getOptions
};


/***/ }),

/***/ 5364:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4389),
  sanitize = __webpack_require__(3984).sanitize;

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {Boolean} trimRequestBody - whether to trim request body fields
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request body
 */
module.exports = function (request, trimRequestBody, indentation) {
  // used to check whether body is present in the request and return accordingly
  if (request.body) {
    var requestBody = '',
      bodyMap,
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += `${indentation}CURLOPT_POSTFIELDS =>` +
                        `${sanitize(request.body[request.body.mode], request.body.mode, trimRequestBody)},\n`;
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += `${indentation}CURLOPT_POSTFIELDS =>` +
          `${sanitize(JSON.stringify({
            query: query,
            variables: graphqlVariables
          }), 'raw', trimRequestBody)},\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyMap = _.map(enabledBodyList, function (value) {
            return `${sanitize(value.key, request.body.mode, trimRequestBody)}=` +
                            `${sanitize(value.value, request.body.mode, trimRequestBody)}`;
          });
          requestBody = `${indentation}CURLOPT_POSTFIELDS => "${bodyMap.join('&')}",\n`;
        }
        return requestBody;
      case 'formdata':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyMap = _.map(enabledBodyList, function (value) {
            if (value.type === 'text') {
              return (`'${sanitize(value.key, request.body.mode, trimRequestBody)}' => '` +
                                `${sanitize(value.value, request.body.mode, trimRequestBody)}'`);
            }
            else if (value.type === 'file') {
              return `'${sanitize(value.key, request.body.mode, trimRequestBody)}'=> ` +
                            `new CURLFILE('${sanitize(value.src, request.body.mode, trimRequestBody)}')`;
            }
          });
          requestBody = `${indentation}CURLOPT_POSTFIELDS => array(${bodyMap.join(',')}),\n`;
        }
        return requestBody;
      case 'file':
        // requestBody = `${indentation}CURLOPT_POSTFIELDS => array('file' => '@'`;
        // requestBody += `${sanitize(request.body[request.body.mode].src,
        //   request.body.mode, trimRequestBody)}'),\n`;
        requestBody = `${indentation}CURLOPT_POSTFIELDS => "<file contents here>",\n`;
        return requestBody;
      default:
        return requestBody;

    }
  }
  return '';
};


/***/ }),

/***/ 5365:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5366);


/***/ }),

/***/ 5366:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4390),
  parseBody = __webpack_require__(5367),
  sanitize = __webpack_require__(3985).sanitize,
  sanitizeOptions = __webpack_require__(3985).sanitizeOptions,
  addFormParam = __webpack_require__(3985).addFormParam,
  self;
const ALLOWED_METOHDS = [ 'OPTIONS', 'GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'TRACE', 'CONNECT'];

/**
 * Used to get the headers and put them in the desired form of the language
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request headers in the desired format
 */
function getHeaders (request, indentation) {
  var headerArray = request.toJSON().header,
    headerMap;

  if (!_.isEmpty(headerArray)) {
    headerArray = _.reject(headerArray, 'disabled');
    headerMap = _.map(headerArray, function (header) {
      return `${indentation}'${sanitize(header.key)}' => ` +
            `'${sanitize(header.value)}'`;
    });
    return `$request->setHeader(array(\n${headerMap.join(',\n')}\n));\n`;
  }
  return '';
}
self = module.exports = {
  /**
  * @returns {Array} plugin specific options
  */
  getOptions: function () {
    return [
      {
        name: 'Set indentation count',
        id: 'indentCount',
        type: 'positiveInteger',
        default: 2,
        description: 'Set the number of indentation characters to add per code level'
      },
      {
        name: 'Set indentation type',
        id: 'indentType',
        type: 'enum',
        default: 'Space',
        availableOptions: ['Tab', 'Space'],
        description: 'Select the character used to indent lines of code'
      },
      {
        name: 'Set request timeout',
        id: 'requestTimeout',
        type: 'positiveInteger',
        default: 0,
        description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
      },
      {
        name: 'Trim request body fields',
        id: 'trimRequestBody',
        type: 'boolean',
        default: false,
        description: 'Remove white space and additional lines that may affect the server\'s response'
      },
      {
        name: 'Follow redirects',
        id: 'followRedirect',
        type: 'boolean',
        default: true,
        description: 'Automatically follow HTTP redirects'
      }
    ];
  },
  convert: function (request, options, callback) {
    if (_.isFunction(options)) {
      callback = options;
      options = {};
    }
    if (!_.isFunction(callback)) {
      throw new Error('PHP-HttpRequest2-Converter: callback is not valid function');
    }
    options = sanitizeOptions(options, self.getOptions());

    var snippet, indentString;
    indentString = options.indentType === 'Tab' ? '\t' : ' ';
    indentString = indentString.repeat(options.indentCount);

    snippet = '<?php\n';
    snippet += 'require_once \'HTTP/Request2.php\';\n';
    snippet += '$request = new HTTP_Request2();\n';
    snippet += `$request->setUrl('${sanitize(request.url.toString())}');\n`;
    snippet += '$request->setMethod(';
    if (ALLOWED_METOHDS.includes(request.method)) {
      snippet += `HTTP_Request2::METHOD_${request.method});\n`;
    }
    else {
      snippet += `'${request.method}');\n`;
    }

    if (options.requestTimeout !== 0 || options.followRedirect) {
      let configArray = [];

      // PHP-HTTP_Request2 method accepts timeout in seconds and it must be an integer
      if (options.requestTimeout !== 0 && Number.isInteger(options.requestTimeout / 1000)) {
        let requestTimeout = options.requestTimeout;
        requestTimeout /= 1000;
        configArray.push(`${indentString}'timeout' => ${requestTimeout}`);
      }
      if (options.followRedirect) {
        configArray.push(`${indentString}'follow_redirects' => TRUE`);
      }
      if (configArray.length) {
        snippet += '$request->setConfig(array(\n';
        snippet += configArray.join(',\n') + '\n';
      }
      snippet += '));\n';
    }
    if (request.body && !request.headers.has('Content-Type')) {
      if (request.body.mode === 'file') {
        request.addHeader({
          key: 'Content-Type',
          value: 'text/plain'
        });
      }
      else if (request.body.mode === 'graphql') {
        request.addHeader({
          key: 'Content-Type',
          value: 'application/json'
        });
      }
    }
    // add the headers to snippet
    snippet += getHeaders(request, indentString);

    // The following code handles multiple files in the same formdata param.
    // It removes the form data params where the src property is an array of filepath strings
    // Splits that array into different form data params with src set as a single filepath string
    if (request.body && request.body.mode === 'formdata') {
      let formdata = request.body.formdata,
        formdataArray = [];
      formdata.members.forEach((param) => {
        let key = param.key,
          type = param.type,
          disabled = param.disabled,
          contentType = param.contentType;
        // check if type is file or text
        if (type === 'file') {
          // if src is not of type string we check for array(multiple files)
          if (typeof param.src !== 'string') {
            // if src is an array(not empty), iterate over it and add files as separate form fields
            if (Array.isArray(param.src) && param.src.length) {
              param.src.forEach((filePath) => {
                addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
              });
            }
            // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
            else {
              addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
            }
          }
          // if src is string, directly add the param with src as filepath
          else {
            addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
          }
        }
        // if type is text, directly add it to formdata array
        else {
          addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
        }
      });
      request.body.update({
        mode: 'formdata',
        formdata: formdataArray
      });
    }
    // add the body to snippet
    if (!_.isEmpty(request.body)) {
      snippet += `${parseBody(request.toJSON(), indentString, options.trimRequestBody)}`;
    }
    snippet += 'try {\n';
    snippet += `${indentString}$response = $request->send();\n`;
    snippet += `${indentString}if ($response->getStatus() == 200) {\n`;
    snippet += `${indentString.repeat(2)}echo $response->getBody();\n`;
    snippet += `${indentString}}\n${indentString}else {\n`;
    snippet += `${indentString.repeat(2)}echo 'Unexpected HTTP status: ' . $response->getStatus() . ' ' .\n`;
    snippet += `${indentString.repeat(2)}$response->getReasonPhrase();\n`;
    snippet += `${indentString}}\n`;
    snippet += '}\ncatch(HTTP_Request2_Exception $e) {\n';
    snippet += `${indentString}echo 'Error: ' . $e->getMessage();\n}`;
    return callback(null, snippet);
  }
};


/***/ }),

/***/ 5367:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4390),
  sanitize = __webpack_require__(3985).sanitize,
  path = __webpack_require__(15);

module.exports = function (request, indentString, trim) {
  var bodySnippet = '',
    bodyFileMap = [],
    bodyDataMap = [],
    enabledBodyList;

  switch (request.body.mode) {
    case 'raw':
      bodySnippet += `$request->setBody('${sanitize(request.body[request.body.mode], trim)}');\n`;
      break;
    // eslint-disable-next-line no-case-declarations
    case 'graphql':
      let query = request.body[request.body.mode].query,
        graphqlVariables;
      try {
        graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
      }
      catch (e) {
        graphqlVariables = {};
      }
      bodySnippet += `$request->setBody('${sanitize(JSON.stringify({
        query: query,
        variables: graphqlVariables
      }), trim)}');\n`;
      break;
    case 'urlencoded':
      enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
      if (!_.isEmpty(enabledBodyList)) {
        bodyDataMap = _.map(enabledBodyList, (data) => {
          return `${indentString}'${sanitize(data.key, trim)}' => '${sanitize(data.value, trim)}'`;
        });
        bodySnippet += `$request->addPostParameter(array(\n${bodyDataMap.join(',\n')}\n));\n`;
      }
      break;
    case 'formdata':
      enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
      if (!_.isEmpty(enabledBodyList)) {
        bodyDataMap = _.map(_.filter(enabledBodyList, {'type': 'text'}), function (data) {
          return `${indentString}'${sanitize(data.key, trim)}' => '${sanitize(data.value, trim)}'`;
        });
        bodyFileMap = _.map(_.filter(enabledBodyList, {'type': 'file'}), function (data) {
          let pathArray = data.src.split(path.sep),
            fileName = pathArray[pathArray.length - 1];
          return `'${sanitize(data.key, trim)}', '${data.src}', '${fileName}', '<Content-Type Header>'`;
        });
        if (bodyDataMap.length) {
          bodySnippet += `$request->addPostParameter(array(\n${bodyDataMap.join(',\n')}\n));\n`;
        }
        if (bodyFileMap.length) {
          _.forEach(bodyFileMap, (file) => {
            bodySnippet += `$request->addUpload(${file});\n`;
          });
        }
      }
      break;
    case 'file':
      bodySnippet += '$request->setBody(\'<file contents here>\');\n';
      break;
    default:
      break;
  }
  return bodySnippet;
};


/***/ }),

/***/ 5368:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5369);


/***/ }),

/***/ 5369:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4391).convert,
  getOptions: __webpack_require__(4391).getOptions
};


/***/ }),

/***/ 5370:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4392),
  sanitize = __webpack_require__(3986).sanitize;

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @param  {Boolean} bodyTrim - whether to trim body fields or not
 * @returns {String} - request body
 */
module.exports = function (request, indentation, bodyTrim) {
  // used to check whether body is present in the request or not
  if (request.body) {
    var bodyDataMap = [],
      bodyFileMap = [],
      requestBody = '',
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += `$body->append('${request.body[request.body.mode]}');\n`;
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += `$body->append('${sanitize(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }), bodyTrim)}');\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyDataMap = _.map(enabledBodyList, function (value) {
            return `${indentation}'${sanitize(value.key, bodyTrim)}' => ` +
                            `'${sanitize(value.value, bodyTrim)}'`;
          });
          requestBody = `$body->append(new http\\QueryString(array(\n${bodyDataMap.join(',\n')})));`;
        }
        return requestBody;

      case 'formdata':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyDataMap = _.map(_.filter(enabledBodyList, {'type': 'text'}), function (value) {
            return (`${indentation}'${sanitize(value.key, bodyTrim)}' => ` +
                            `'${sanitize(value.value, bodyTrim)}'`);
          });
          bodyFileMap = _.map(_.filter(enabledBodyList, {'type': 'file'}), function (value) {
            return (`${indentation.repeat(2)}array('name' => '${sanitize(value.key, bodyTrim)}', ` +
                            '\'type\' => \'<Content-type header>\', ' +
                            `'file' => '${sanitize(value.src, bodyTrim)}', ` +
                            '\'data\' => null)');
          });
          requestBody = `$body->addForm(array(\n${bodyDataMap.join(',\n')}\n), ` +
                        `array(\n${bodyFileMap.join(',\n')}\n));\n`;
        }
        return requestBody;

      case 'file':
        // requestBody = `${indentation.repeat(2)}array('name' => '` +
        //             `${sanitize(request.body[request.body.mode].key, bodyTrim)}', ` +
        //             `'type' => '${sanitize(request.body[request.body.mode].type, bodyTrim)}', ` +
        //             `'file' => '${sanitize(request.body[request.body.mode].src, bodyTrim)}', ` +
        //             '\'data\' => null)';
        // return `$body->addForm(array(), array(${requestBody}));\n`;
        requestBody = '$body->append(\'<file contents here>\');\n';
        return requestBody;
      default:
        return requestBody;
    }
  }
  return '';
};


/***/ }),

/***/ 5371:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5372);


/***/ }),

/***/ 5372:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(5373),
  sanitize = __webpack_require__(4103).sanitize,
  sanitizeOptions = __webpack_require__(4103).sanitizeOptions,
  addFormParam = __webpack_require__(4103).addFormParam,
  path = __webpack_require__(15);
const VALID_METHODS = ['DEFAULT',
  'DELETE',
  'GET',
  'HEAD',
  'MERGE',
  'OPTIONS',
  'PATCH',
  'POST',
  'PUT',
  'TRACE'];

/**
 * Parses URLEncoded body from request to powershell-restmethod syntax
 *
 * @param {Object} body URLEncoded Body
 */
function parseURLEncodedBody (body) {
  var bodySnippet = '$body = "',
    urlencodedArray = [];
  _.forEach(body, function (data) {
    if (!data.disabled) {
      urlencodedArray.push(`${escape(data.key)}=${escape(data.value)}`);
    }
  });
  bodySnippet += urlencodedArray.join('&') + '"\n';
  return bodySnippet;
}

/**
 * Parses Formdata from request to powershell-restmethod syntax
 *
 * @param {Object} body FormData body
 * @param {boolean} trim trim body option
 */
function parseFormData (body, trim) {
  var bodySnippet = '$multipartContent = [System.Net.Http.MultipartFormDataContent]::new()\n';
  _.forEach(body, function (data) {
    if (!data.disabled) {
      if (data.type === 'text') {
        bodySnippet += '$stringHeader = ' +
          '[System.Net.Http.Headers.ContentDispositionHeaderValue]::new("form-data")\n' +
          `$stringHeader.Name = "${sanitize(data.key, trim)}"\n` +
          `$StringContent = [System.Net.Http.StringContent]::new("${sanitize(data.value, trim)}")\n` +
          '$StringContent.Headers.ContentDisposition = $stringHeader\n' +
          '$multipartContent.Add($stringContent)\n\n';
      }
      else {
        var pathArray = data.src.split(path.sep),
          fileName = pathArray[pathArray.length - 1];
        bodySnippet += `$multipartFile = '${data.src}'\n` +
          '$FileStream = [System.IO.FileStream]::new($multipartFile, [System.IO.FileMode]::Open)\n' +
          '$fileHeader = [System.Net.Http.Headers.ContentDispositionHeaderValue]::new("form-data")\n' +
          `$fileHeader.Name = "${sanitize(data.key)}"\n` +
          `$fileHeader.FileName = "${sanitize(fileName, trim)}"\n` +
          '$fileContent = [System.Net.Http.StreamContent]::new($FileStream)\n' +
          '$fileContent.Headers.ContentDisposition = $fileHeader\n' +
          '$multipartContent.Add($fileContent)\n\n';
      }
    }
  });
  bodySnippet += '$body = $multipartContent\n';
  return bodySnippet;
}

/**
 * Parses Raw data from request to powershell-restmethod syntax
 *
 * @param {Object} body Raw body data
 * @param {boolean} trim trim body option
 */
function parseRawBody (body, trim) {
  return `$body = "${sanitize(body.toString(), trim)}"\n`;
}

/**
 * Parses graphql data from request to powershell-restmethod syntax
 *
 * @param {Object} body graphql body data
 * @param {boolean} trim trim body option
 */
function parseGraphQL (body, trim) {
  let query = body.query,
    graphqlVariables;
  try {
    graphqlVariables = JSON.parse(body.variables);
  }
  catch (e) {
    graphqlVariables = {};
  }
  return `$body = "${sanitize(JSON.stringify({
    query: query,
    variables: graphqlVariables
  }), trim)}"\n`;
}

/* eslint-disable no-unused-vars*/
/* istanbul ignore next */
/**
 * Parses File data from request to powershell-restmethod syntax
 *
 * @param {Object} src File path
 * @param {boolean} trim trim body option
 */
function parseFileData (src, trim) {
  return '$body = "<file-contents-here>"\n';
}
/* eslint-enable no-unused-vars*/

/**
 * Parses Body from request to powershell-restmethod syntax based on the body mode
 *
 * @param {Object} body body object from request
 * @param {boolean} trim trim body option
 */
function parseBody (body, trim) {
  if (!_.isEmpty(body)) {
    switch (body.mode) {
      case 'urlencoded':
        return parseURLEncodedBody(body.urlencoded);
      case 'raw':
        return parseRawBody(body.raw, trim);
      case 'graphql':
        return parseGraphQL(body.graphql, trim);
      case 'formdata':
        return parseFormData(body.formdata, trim);
        /* istanbul ignore next */
      case 'file':
        return parseFileData(body.file, trim);
      default:
        return parseRawBody(body[body.mode], trim);
    }
  }
  return '';
}

/**
 * Parses headers from request to powershell-restmethod syntax
 *
 * @param {Object} headers headers from the request
 */
function parseHeaders (headers) {
  var headerSnippet = '';
  if (!_.isEmpty(headers)) {
    headers = _.reject(headers, 'disabled');
    headerSnippet = '$headers = New-Object "System.Collections.Generic.Dictionary[[String],[String]]"\n';
    _.forEach(headers, function (header) {
      headerSnippet += `$headers.Add("${sanitize(header.key, true)}", "${sanitize(header.value)}")\n`;
    });
  }
  else {
    headerSnippet = '';
  }
  return headerSnippet;
}

/**
 * Used to get the options specific to this codegen
 *
 * @returns {Array} - Returns an array of option objects
 */
function getOptions () {
  return [
    {
      name: 'Set request timeout',
      id: 'requestTimeout',
      type: 'positiveInteger',
      default: 0,
      description: 'Set number of milliseconds the request should wait for a response' +
    ' before timing out (use 0 for infinity)'
    },
    {
      name: 'Follow redirects',
      id: 'followRedirect',
      type: 'boolean',
      default: true,
      description: 'Automatically follow HTTP redirects'
    },
    {
      name: 'Trim request body fields',
      id: 'trimRequestBody',
      type: 'boolean',
      default: false,
      description: 'Remove white space and additional lines that may affect the server\'s response'
    }
  ];
}

/**
 * Converts Postman sdk request object to powershell-restmethod code snippet
 *
 * @param {Object} request - postman-SDK request object
 * @param {Object} options
 * @param {Boolean} options.followRedirect - whether to enable followredirect
 * @param {Boolean} options.trimRequestBody - whether to trim fields in request body or not
 * @param {Number} options.requestTimeout : time in milli-seconds after which request will bail out
 * @param {Function} callback - callback function with parameters (error, snippet)
 */
function convert (request, options, callback) {
  if (!_.isFunction(callback)) {
    throw new Error('Powershell RestMethod Converter callback is not a valid function');
  }
  options = sanitizeOptions(options, getOptions());

  var trim = options.trimRequestBody,
    headers, body,
    codeSnippet = '',
    headerSnippet = '',
    bodySnippet = '';
  if (request.body && !request.headers.has('Content-Type')) {
    if (request.body.mode === 'file') {
      request.addHeader({
        key: 'Content-Type',
        value: 'text/plain'
      });
    }
    else if (request.body.mode === 'graphql') {
      request.addHeader({
        key: 'Content-Type',
        value: 'application/json'
      });
    }
  }

  headers = request.toJSON().header;
  headerSnippet = parseHeaders(headers);

  // The following code handles multiple files in the same formdata param.
  // It removes the form data params where the src property is an array of filepath strings
  // Splits that array into different form data params with src set as a single filepath string
  if (request.body && request.body.mode === 'formdata') {
    let formdata = request.body.formdata,
      formdataArray = [];
    formdata.members.forEach((param) => {
      let key = param.key,
        type = param.type,
        disabled = param.disabled,
        contentType = param.contentType;
        // check if type is file or text
      if (type === 'file') {
        // if src is not of type string we check for array(multiple files)
        if (typeof param.src !== 'string') {
          // if src is an array(not empty), iterate over it and add files as separate form fields
          if (Array.isArray(param.src) && param.src.length) {
            param.src.forEach((filePath) => {
              addFormParam(formdataArray, key, param.type, filePath, disabled, contentType);
            });
          }
          // if src is not an array or string, or is an empty array, add a placeholder for file path(no files case)
          else {
            addFormParam(formdataArray, key, param.type, '/path/to/file', disabled, contentType);
          }
        }
        // if src is string, directly add the param with src as filepath
        else {
          addFormParam(formdataArray, key, param.type, param.src, disabled, contentType);
        }
      }
      // if type is text, directly add it to formdata array
      else {
        addFormParam(formdataArray, key, param.type, param.value, disabled, contentType);
      }
    });
    request.body.update({
      mode: 'formdata',
      formdata: formdataArray
    });
  }
  body = request.body ? request.body.toJSON() : {};
  bodySnippet = parseBody(body, trim);

  if (headerSnippet !== '') {
    codeSnippet += headerSnippet + '\n';
  }
  if (bodySnippet !== '') {
    codeSnippet += bodySnippet + '\n';
  }

  if (_.includes(VALID_METHODS, request.method)) {
    codeSnippet += `$response = Invoke-RestMethod '${request.url.toString().replace(/'/g, '\'\'')}' -Method '` +
                        `${request.method}' -Headers $headers -Body $body`;
  }
  else {
    codeSnippet += `$response = Invoke-RestMethod '${request.url.toString()}' -CustomMethod ` +
                        `'${request.method}' -Headers $headers -Body $body`;
  }
  if (options.requestTimeout > 0) {
    // Powershell rest method accepts timeout in seconds
    let requestTimeout = options.requestTimeout;
    requestTimeout /= 1000;
    codeSnippet += ` -TimeoutSec ${requestTimeout}`;
  }
  if (!options.followRedirect) {
    codeSnippet += ' -MaximumRedirection 0';
  }
  codeSnippet += '\n$response | ConvertTo-Json';
  callback(null, codeSnippet);
}

module.exports = {
  convert: convert,
  getOptions: getOptions
};


/***/ }),

/***/ 5373:
/***/ (function(module, exports) {

/* istanbul ignore file */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }

    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ }),

/***/ 5374:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5375);


/***/ }),

/***/ 5375:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4393).convert,
  getOptions: __webpack_require__(4393).getOptions
};


/***/ }),

/***/ 5376:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4394),
  sanitize = __webpack_require__(3987).sanitize,
  path = __webpack_require__(15);

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @param  {Boolean} bodyTrim - whether to trim request body fields
 * @returns {String} - request body
 */
module.exports = function (request, indentation, bodyTrim) {
  // used to check whether body is present in the request or not
  if (!_.isEmpty(request.body)) {
    var requestBody = '',
      bodyDataMap,
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += `payload = ${sanitize(request.body[request.body.mode],
            request.body.mode, bodyTrim)}\n`;
        }
        else {
          requestBody = 'payload = \'\'\n';
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += `payload = ${sanitize(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }),
        'raw', bodyTrim)}\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyDataMap = _.map(enabledBodyList, function (value) {
            return `${sanitize(value.key, request.body.mode, bodyTrim)}=` +
                            `${sanitize(value.value, request.body.mode, bodyTrim)}`;
          });
          requestBody += `payload = '${bodyDataMap.join('&')}'\n`;
        }
        else {
          requestBody = 'payload = \'\'\n';
        }
        return requestBody;
      case 'formdata':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          requestBody += 'dataList = []\n';
          requestBody += 'boundary = \'wL36Yn8afVp8Ag7AmP8qZ0SA4n1v9T\'\n';
          enabledBodyList.forEach((data) => {
            requestBody += 'dataList.append(\'--\' + boundary)\n';
            if (data.type !== 'file') {
              requestBody += `dataList.append('Content-Disposition: form-data; name=${sanitize(data.key, 'form-data', true)};')\n\n`; // eslint-disable-line max-len
              requestBody += 'dataList.append(\'Content-Type: {}\'.format(\'multipart/form-data\'))\n';
              requestBody += 'dataList.append(\'\')\n\n';
              requestBody += `dataList.append("${sanitize(data.value, 'form-data', true)}")\n`;
            }
            else {
              var pathArray = data.src.split(path.sep),
                fileName = pathArray[pathArray.length - 1];
              requestBody += `dataList.append('Content-Disposition: form-data; name=${sanitize(data.key, 'form-data', true)}; filename={0}'.format('${sanitize(fileName, 'formdata', true)}'))\n\n`; // eslint-disable-line max-len
              requestBody += `fileType = mimetypes.guess_type('${sanitize(data.src, 'formdata', true)}')[0] or 'application/octet-stream'\n`; // eslint-disable-line max-len
              requestBody += 'dataList.append(\'Content-Type: {}\'.format(fileType))\n';
              requestBody += 'dataList.append(\'\')\n\n';

              requestBody += `with open('${data.src}') as f:\n`;
              requestBody += `${indentation}dataList.append(f.read())\n`;
            }
          });
          requestBody += 'dataList.append(\'--\'+boundary+\'--\')\n';
          requestBody += 'dataList.append(\'\')\n';
          requestBody += 'body = \'\\r\\n\'.join(dataList)\n';
          requestBody += 'payload = body\n';
        }
        else {
          requestBody = 'boundary = \'\'\n';
          requestBody += 'payload = \'\'\n';
        }
        return requestBody;
      case 'file':
        return 'payload = "<file contents here>"\n';
      default:
        return 'payload = \'\'\n';
    }
  }
  return 'payload = \'\'\n';
};


/***/ }),

/***/ 5377:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5378);


/***/ }),

/***/ 5378:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4395).convert,
  getOptions: __webpack_require__(4395).getOptions
};


/***/ }),

/***/ 5379:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4396),
  sanitize = __webpack_require__(3988).sanitize;

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {String} indentation - used for indenting snippet's structure
 * @param  {Boolean} bodyTrim - whether to trim request body fields
 * @returns {String} - request body
 */
module.exports = function (request, indentation, bodyTrim) {
  // used to check whether body is present in the request or not
  if (request.body) {
    var requestBody = '',
      bodyDataMap,
      bodyFileMap,
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += `payload = ${sanitize(request.body[request.body.mode],
            request.body.mode, bodyTrim)}\n`;
        }
        else {
          requestBody = 'payload  = {}\n';
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += `payload = ${sanitize(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }),
        'raw', bodyTrim)}\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyDataMap = _.map(enabledBodyList, function (value) {
            return `${sanitize(value.key, request.body.mode, bodyTrim)}=` +
                        `${sanitize(value.value, request.body.mode, bodyTrim)}`;
          });
          requestBody += `payload = '${bodyDataMap.join('&')}'\n`;
        }
        else {
          requestBody = 'payload = {}\n';
        }
        return requestBody;
      case 'formdata':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyDataMap = _.map(_.filter(enabledBodyList, {'type': 'text'}), function (value) {
            return (`'${sanitize(value.key, request.body.mode, bodyTrim)}': ` +
                            `'${sanitize(value.value, request.body.mode, bodyTrim)}'`);
          });
          bodyFileMap = _.map(_.filter(enabledBodyList, {'type': 'file'}), function (value) {
            return `${indentation}('${value.key}', open('${sanitize(value.src, request.body.mode, bodyTrim)}','rb'))`;
          });
          requestBody = `payload = {${bodyDataMap.join(',\n')}}\nfiles = [\n${bodyFileMap.join(',\n')}\n]\n`;
        }
        else {
          requestBody = 'payload = {}\nfiles = {}\n';
        }
        return requestBody;
      case 'file':
        // return `payload = {open('${request.body[request.body.mode].src}', 'rb').read()\n}`;
        return 'payload = "<file contents here>"\n';
      default:
        return 'payload = {}\n';
    }
  }
  return 'payload = {}\n';
}
;


/***/ }),

/***/ 5380:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5381);


/***/ }),

/***/ 5381:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4397).convert,
  getOptions: __webpack_require__(4397).getOptions
};


/***/ }),

/***/ 5382:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4398),
  sanitize = __webpack_require__(3989).sanitize;

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {Boolean} trimRequestBody - whether to trim request body fields
 * @returns {String} - request body
 */
module.exports = function (request, trimRequestBody) {
  // used to check whether body is present in the request and return accordingly
  if (request.body) {
    var requestBody = '',
      bodyMap,
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += 'request.body = ' +
                        `${sanitize(request.body[request.body.mode], request.body.mode, trimRequestBody)}\n`;
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += 'request.body = ' +
        `${sanitize(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }), 'raw', trimRequestBody)}\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyMap = _.map(enabledBodyList, function (value) {
            return `${sanitize(value.key, request.body.mode, trimRequestBody)}=` +
                            `${sanitize(value.value, request.body.mode, trimRequestBody)}`;
          });
          requestBody = `request.body = "${sanitize(bodyMap.join('&'), 'doubleQuotes')}"\n`;
        }
        return requestBody;
      case 'formdata':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyMap = _.map(enabledBodyList, function (data) {
            if (data.type === 'text') {
              return `['${sanitize(data.key, 'formdata', trimRequestBody)}',` +
              ` '${sanitize(data.value, 'formdata', trimRequestBody)}']`;
            }
            return `['${sanitize(data.key, 'formdata', trimRequestBody)}', File.open('${data.src}')]`;
          });
        }
        requestBody = `form_data = [${bodyMap.join(',')}]\n`;
        requestBody += 'request.set_form form_data, \'multipart/form-data\'';
        return requestBody;
      case 'file':
        requestBody = 'request.body = "<file contents here>"\n';
        return requestBody;
      default:
        return requestBody;

    }
  }
  return '';
};


/***/ }),

/***/ 5383:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5384);


/***/ }),

/***/ 5384:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4399).convert,
  getOptions: __webpack_require__(4399).getOptions
};


/***/ }),

/***/ 5385:
/***/ (function(module, exports, __webpack_require__) {

var Sanitize = __webpack_require__(4104),
  _ = __webpack_require__(4400);

const BOUNDARY_HASH = 'e4dgoae5mIkjFjfG',
  URLENCODED = 'urlencoded',
  FORM_DATA = 'formdata',
  RAW = 'raw',
  GRAPHQL = 'graphql';
  // APP_JSON = 'application/json',
  // APP_JS = 'application/javascript',
  // APP_XML = 'application/xml',
  // TEXT_XML = 'text/xml',
  // TEXT_PLAIN = 'text/plain',
  // TEXT_HTML = 'text/html';

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @returns {String} - request body
 */
module.exports = {

  boundaryHash: BOUNDARY_HASH,
  contentType: '',

  // function to add headers to the shell snippet
  // returns headerString, comprising of all headers present in the request object
  addHeaders: function (request) {
    var headerString = '';
    if (request.hasOwnProperty('headers')) {
      if (Array.isArray(request.headers.members) && request.headers.members.length) {
        request.headers.members = _.reject(request.headers.members, 'disabled');
        headerString = request.headers.members.map((header) => {
          return ' ' + header.key.trim() + ':' + Sanitize.quote(header.value);
        }).join(' \\\n');
      }
      else {
        headerString = '';
      }
    }

    if (headerString === []) {
      return '';
    }
    return headerString;
  },

  /**
   * parses host of request object and returns code snippet of nodejs native to add hostname
   *
   * @param {Object} request - Postman SDK request object
   * @returns {String} - code snippet of nodejs native to add hostname
   */
  addHost: function (request) {
    var hostArray = _.get(request, 'url.host', []),
      hostSnippet = '';

    if (hostArray && hostArray.length) {
      hostSnippet += _.reduce(hostArray, function (accumalator, key) {
        accumalator.push(`${key}`);
        return accumalator;
      }, []).join('.');
    }

    return hostSnippet;
  },

  /**
   * parses port of request object and returns code snippet of shell httpie to add port
   *
   * @param {Object} request - Postman SDK request object
   * @returns {String} - code snippet of shell httpie to add port
   */

  addPort: function (request) {
    var port = request.url.port,
      portSnippet = '';
    if (port) {
      portSnippet += ':' + port;
    }
    return portSnippet;
  },

  addPathandQuery: function (request) {
    var pathArray = _.get(request, 'url.path'),
      queryArray = _.get(request.toJSON(), 'url.query'),
      pathSnippet = '/',
      querySnippet = '';

    if (pathArray && pathArray.length) {
      pathSnippet += _.reduce(pathArray, function (accumalator, key) {
        if (key.length) {
          accumalator.push(`${key}`);
        }
        else {
          accumalator.push('');
        }
        return accumalator;
      }, []).join('/');
    }

    if (queryArray && queryArray.length) {
      const queryExists = !(_.every(queryArray, function (element) {
        return element.disabled && element.disabled === false;
      }));

      if (queryExists) {
        querySnippet += ' ' + _.reduce(queryArray, function (accumalator, queryElement) {
          if (!queryElement.disabled || _.get(queryElement, 'disabled') === false) {
            accumalator.push(`${Sanitize.quote(queryElement.key)}==${Sanitize.quote(queryElement.value)}`);
          }
          return accumalator;
        }, []).join(' ');
      }
    }
    pathSnippet += querySnippet;
    return pathSnippet;
  },

  /**
 * parses variable of request url object and sets hostname, path and query in request object
 *
 * @param {Object} request - Postman SDK request object
 */
  parseURLVariable: function (request) {
    const variableArray = _.get(request.toJSON(), 'url.variable', []);

    if (!variableArray.length) {
      return;
    }

    variableArray.forEach(function (variableArrayElement) {
      request.url.host.forEach(function (hostArrayElement, hostArrayElementIndex) {
        if (hostArrayElement === ':' + variableArrayElement.key) {
          request.url.host[hostArrayElementIndex] = variableArrayElement.value;
        }
      });

      request.url.path.forEach(function (pathArrayElement, pathArrayElementIndex) {
        if (pathArrayElement === ':' + variableArrayElement.key) {
          request.url.path[pathArrayElementIndex] = variableArrayElement.value;
        }
      });

      request.toJSON().url.query.forEach(function (queryArrayElement, queryArrayElementIndex) {
        if (queryArrayElement === ':' + variableArrayElement.key) {
          request.url.query[queryArrayElementIndex] = variableArrayElement.value;
        }
      });
    });
  },

  getRequestBody: function (requestBody, contentCategory) {
    var parsedBody;

    switch (contentCategory) {
      case URLENCODED:
        if (Array.isArray(requestBody.members) && requestBody.members.length) {
          parsedBody = requestBody.members.map((param) => {
            if (typeof param.value === 'string') {
              return ' ' + Sanitize.quote(param.key) + '=' + Sanitize.quote(param.value);
            }
            return ' ' + param.key + ':=' + param.value;
          }).join(' \\\n');
        }
        else {
          parsedBody = '';
        }
        break;

      case FORM_DATA:
        if (Array.isArray(requestBody.members) && requestBody.members.length) {
          parsedBody = requestBody.members.map((param) => {
            if (param.type === 'text') {
              if (typeof param.value === 'string') {
                return ' ' + Sanitize.quote(param.key) + '=' + Sanitize.quote(param.value);
              }
              return ' ' + param.key + ':=' + param.value;
            }
            return ' ' + Sanitize.quote(param.key) + '@' + param.src;
          }).join(' \\\n');
        }
        else {
          parsedBody = '';
        }
        break;

      case RAW:
        if (requestBody === undefined) {
          parsedBody = '';
        }
        else {
          parsedBody = requestBody ? `${Sanitize.quote(requestBody, RAW)}` : '';
        }
        break;
      // eslint-disable-next-line no-case-declarations
      case GRAPHQL:
        let query = requestBody.query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(requestBody.variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        parsedBody = Sanitize.quote(JSON.stringify({
          query: query,
          variables: graphqlVariables
        }), RAW);
        break;
      case 'file':
        parsedBody = requestBody.src;
        break;
      default:
        parsedBody = '';
    }

    return parsedBody ? parsedBody : '';
  }
};


/***/ }),

/***/ 5386:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5387);


/***/ }),

/***/ 5387:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4401).convert,
  getOptions: __webpack_require__(4401).getOptions
};


/***/ }),

/***/ 5388:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(4402),
  sanitize = __webpack_require__(4105).sanitize;

/**
 * Used to parse the body of the postman SDK-request and return in the desired format
 *
 * @param  {Object} request - postman SDK-request object
 * @param  {Boolean} trimRequestBody - whether to trim request body fields
 * @param  {String} indentation - used for indenting snippet's structure
 * @returns {String} - request body
 */
module.exports = function (request, trimRequestBody, indentation) {
  // used to check whether body is present in the request and return accordingly
  if (request.body) {
    var requestBody = '',
      bodyMap = [],
      enabledBodyList;

    switch (request.body.mode) {
      case 'raw':
        if (!_.isEmpty(request.body[request.body.mode])) {
          requestBody += `${indentation}--body-data ` +
                        `'${sanitize(request.body[request.body.mode], request.body.mode, trimRequestBody)}' \\\n`;
        }
        return requestBody;
      // eslint-disable-next-line no-case-declarations
      case 'graphql':
        let query = request.body[request.body.mode].query,
          graphqlVariables;
        try {
          graphqlVariables = JSON.parse(request.body[request.body.mode].variables);
        }
        catch (e) {
          graphqlVariables = {};
        }
        requestBody += `${indentation}--body-data ` +
          `'${sanitize(JSON.stringify({
            query: query,
            variables: graphqlVariables
          }), 'raw', trimRequestBody)}' \\\n`;
        return requestBody;
      case 'urlencoded':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          bodyMap = _.map(enabledBodyList, function (value) {
            return `${sanitize(value.key, request.body.mode, trimRequestBody)}=` +
                            `${sanitize(value.value, request.body.mode, trimRequestBody)}`;
          });
          requestBody = `${indentation}--body-data '${bodyMap.join('&')}' \\\n`;
        }
        return requestBody;
      case 'formdata':
        enabledBodyList = _.reject(request.body[request.body.mode], 'disabled');
        if (!_.isEmpty(enabledBodyList)) {
          _.forEach(enabledBodyList, function (value) {
            if (value.type === 'text') {
              bodyMap.push(`${sanitize(value.key, request.body.mode, trimRequestBody)}=` +
                            `${sanitize(value.value, request.body.mode, trimRequestBody)}`);
            }
          });
          requestBody = `${indentation}--body-data '${bodyMap.join('&')}' \\\n`;
        }
        return requestBody;
        /* istanbul ignore next */
      case 'file':
        requestBody = `${indentation}--body-file='`;
        requestBody += `${sanitize(request.body[request.body.mode].src,
          request.body.mode, trimRequestBody)}' \\\n`;
        return requestBody;
      default:
        return requestBody;

    }
  }
  return '';
};


/***/ }),

/***/ 5389:
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(5390);


/***/ }),

/***/ 5390:
/***/ (function(module, exports, __webpack_require__) {

module.exports = {
  convert: __webpack_require__(4403).convert,
  getOptions: __webpack_require__(4403).getOptions
};


/***/ }),

/***/ 5391:
/***/ (function(module, exports) {

/* istanbul ignore next */
module.exports = {

  /**
       * Checks if `value` is an empty object, array or string.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Values such as strings, arrays are considered empty if they have a `length` of `0`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * isEmpty(null)
       * // => true
       *
       * isEmpty(true)
       * // => true
       *
       * isEmpty(1)
       * // => true
       *
       * isEmpty([1, 2, 3])
       * // => false
       *
       * isEmpty('abc')
       * // => false
       *
       * isEmpty({ 'a': 1 })
       * // => false
       */
  isEmpty: function (value) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (value === null || value === undefined) {
      return true;
    }
    if (Array.isArray(value) || typeof value === 'string' || typeof value.splice === 'function') {
      return !value.length;
    }

    for (const key in value) {
      if (Object.prototype.hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  },

  /**
       * Checks if `value` is `undefined`.
       *
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * isUndefined(void 0)
       * // => true
       *
       * isUndefined(null)
       * // => false
       */
  isUndefined: function (value) {
    return value === undefined;
  },

  /**
       * Checks if `func` is classified as a `Function` object.
       *
       * @param {*} func The value to check.
       * @returns {boolean} Returns `true` if `func` is a function, else `false`.
       * @example
       *
       * isFunction(self.isEmpty)
       * // => true
       *
       * isFunction(/abc/)
       * // => false
       */
  isFunction: function (func) {
    return typeof func === 'function';
  },

  /**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * capitalize('FRED')
       * // => 'Fred'
       *
       * capitalize('john')
       * // => 'John'
       */

  capitalize: function (string) {
    return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
  },

  /**
       * Reduces `array` to a value which is the accumulated result of running
       * each element in `array` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `array` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, array).
       *
       * @param {Array} array The Array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * reduce([1, 2], (sum, n) => sum + n, 0)
       * // => 3
       *
       */
  reduce: function (array, iteratee, accumulator) {
    return array.reduce(iteratee, accumulator);
  },

  /**
       * Iterates over elements of `array`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function|object} predicate The function/object invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * filter(users, ({ active }) => active)
          * // => object for ['barney']
          */
  filter: function (array, predicate) {
    if (typeof predicate === 'function') {
      return array.filter(predicate);
    }
    var key = Object.keys(predicate),
      val = predicate[key],
      res = [];
    array.forEach(function (item) {
      if (item[key] && item[key] === val) {
        res.push(item);
      }
    });
    return res;
  },

  /**
       * The opposite of `filter` this method returns the elements of `array`
       * that `predicate` does **not** return truthy for.
       *
       * @param {Array} array collection to iterate over.
       * @param {String} predicate The String that needs to have truthy value, invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @example
       *
       * const users = [
          *   { 'user': 'barney', 'active': true },
          *   { 'user': 'fred',   'active': false }
          * ]
          *
          * reject(users, 'active')
          * // => object for ['fred']
          */
  reject: function (array, predicate) {
    var res = [];
    array.forEach((object) => {
      if (!object[predicate]) {
        res.push(object);
      }
    });
    return res;
  },

  /**
       * Creates an array of values by running each element of `array` thru `iteratee`.
       * The iteratee is invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
          *   return n * n
          * }
          *
          * map([4, 8], square)
          * // => [16, 64]
          */
  map: function (array, iteratee) {
    return array.map(iteratee);
  },

  /**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       *
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @example
       *
       * forEach([1, 2], value => console.log(value))
       * // => Logs `1` then `2`.
       *
       * forEach({ 'a': 1, 'b': 2 }, (value, key) => console.log(key))
       * // => Logs 'a' then 'b'
       */

  forEach: function (collection, iteratee) {
    if (collection === null) {
      return null;
    }

    if (Array.isArray(collection)) {
      return collection.forEach(iteratee);
    }
    const iterable = Object(collection),
      props = Object.keys(collection);
    var index = -1,
      key, i;

    for (i = 0; i < props.length; i++) {
      key = props[++index];
      iteratee(iterable[key], key, iterable);
    }
    return collection;
  },

  /**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise it checks if the `value` is present
       * as a key in a `collection` object.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */
  includes: function (collection, value) {
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.includes(value);
    }
    for (var key in collection) {
      if (collection.hasOwnProperty(key)) {
        if (collection[key] === value) {
          return true;
        }
      }
    }
    return false;
  },

  /**
       * Gets the size of `collection` by returning its length for array and strings.
       * For objects it returns the number of enumerable string keyed
       * properties.
       *
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * size([1, 2, 3])
       * // => 3
       *
       * size({ 'a': 1, 'b': 2 })
       * // => 2
       *
       * size('pebbles')
       * // => 7
       */
  size: function (collection) {
    // eslint-disable-next-line lodash/prefer-is-nil
    if (collection === null || collection === undefined) {
      return 0;
    }
    if (Array.isArray(collection) || typeof collection === 'string') {
      return collection.length;
    }

    return Object.keys(collection).length;
  },

  /**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */
  join: function (array, separator) {
    if (array === null) {
      return '';
    }
    return array.join(separator);
  },

  /**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * trimEnd('  abc  ')
       * // => '  abc'
       *
       * trimEnd('-_-abc-_-', '_-')
       * // => '-_-abc'
       */
  trimEnd: function (string, chars) {
    if (!string) {
      return '';
    }
    if (string && !chars) {
      return string.replace(/\s*$/, '');
    }
    chars += '$';
    return string.replace(new RegExp(chars, 'g'), '');
  },

  /**
       * Returns the index of the first
       * element `predicate` returns truthy for.
       *
       * @param {Array} array The array to inspect.
       * @param {Object} predicate The exact object to be searched for in the array.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
          *   { 'user': 'barney',  'active': false },
          *   { 'user': 'fred',    'active': false },
          *   { 'user': 'pebbles', 'active': true }
          * ];
          *
          * _.findIndex(users, { 'user': 'fred', 'active': false });
          * // => 1
          *
          * _.findIndex(users, {'active' : false});
          * // => 0
          *
          */
  findIndex: function (array, predicate) {
    var length = array === null ? 0 : array.length,
      index = -1,
      keys = Object.keys(predicate),
      found, i;
    if (!length) {
      return -1;
    }
    for (i = 0; i < array.length; i++) {
      found = true;
      // eslint-disable-next-line no-loop-func
      keys.forEach((key) => {
        if (!(array[i][key] && array[i][key] === predicate[key])) {
          found = false;
        }
      });
      if (found) {
        index = i;
        break;
      }
    }
    return index;
  },

  /**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @param {Object} object The object to query.
       * @param {string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * const object = { a: {b : 'c'} }
       *
       *
       * get(object, 'a.b.c', 'default')
       * // => 'default'
       *
       * get(object, 'a.b', 'default')
       * // => 'c'
       */
  get: function (object, path, defaultValue) {
    if (object === null) {
      return undefined;
    }
    var arr = path.split('.'),
      res = object,
      i;
    for (i = 0; i < arr.length; i++) {
      res = res[arr[i]];
      if (res === undefined) {
        return defaultValue;
      }
    }
    return res;
  },

  /**
       * Checks if `predicate` returns truthy for **all** elements of `array`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @param {Array} array The array to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * every([true, 1, null, 'yes'], Boolean)
       * // => false
       */
  every: function (array, predicate) {
    var index = -1,
      length = array === null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

};


/***/ })

});