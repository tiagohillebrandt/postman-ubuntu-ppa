webpackJsonp([0],{

/***/ 3377:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* WEBPACK VAR INJECTION */(function(_) {/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__checkImportEnvironmentFromUrl__ = __webpack_require__(3556);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__importCollectionAndEnvironment__ = __webpack_require__(3591);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__convertData__ = __webpack_require__(3592);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__importFileFromUrl__ = __webpack_require__(3593);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__importFiles__ = __webpack_require__(3594);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__importFolder__ = __webpack_require__(3595);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__saveEntity__ = __webpack_require__(3596);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__stores_get_store__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__importers_index__ = __webpack_require__(1522);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_async__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9_async___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_9_async__);











/**
                            * This is like a step callback that will be called after each collection import
                            * to handle the success or failure case
                           */
function handleCollectionImportStatus(error, collection) {
  if (!error) {
    pm.toasts.success('Collection ' + collection.name + ' imported');
  } else
  {
    pm.toasts.error('Failed to import collection ' + collection.name);
  }
}

/**
   * Imports a Collection, Environment, Request, Globals, etc. in any supported format.
   * (Collection v2, Swagger RAML, etc.)
   *
   * @param {string|object} data - A string containing JSON/YAML/XML/etc, or other type of data
   * @param {object} options - options, Currently used by analytics handler to determine which analytics event to send
   * @param {Function} done - calls after every entity is imported
   *
   *
   * @returns {object} convertedData - imported data
   * Resolves with the Postman objects that were imported, and the format that they were imported from.
   */
async function importData(data, options, done) {
  if (_.isEmpty(data)) return _.isFunction(done) && done();
  __WEBPACK_IMPORTED_MODULE_9_async___default.a.series([
  next => {
    __WEBPACK_IMPORTED_MODULE_8__importers_index__["a" /* default */].importCollections(data.collections, options, handleCollectionImportStatus, next);

  },
  next => {
    __WEBPACK_IMPORTED_MODULE_8__importers_index__["a" /* default */].importGlobals(data.globals, _.pick(options, ['activeWorkspace']), next);
  },
  next => {
    __WEBPACK_IMPORTED_MODULE_8__importers_index__["a" /* default */].importHeaderPresets(data.headerPresets, _.pick(options, ['currentUserID', 'activeWorkspace']), next);
  },
  next => {
    __WEBPACK_IMPORTED_MODULE_8__importers_index__["a" /* default */].importEnvironments(data.environments, _.pick(options, ['currentUserID']), next);
  },
  next => {
    __WEBPACK_IMPORTED_MODULE_8__importers_index__["a" /* default */].importRequests(data.requests, next);
  }],
  () => {
    _.isFunction(done) && done();
  });
}

/* harmony default export */ __webpack_exports__["default"] = ({
  checkImportEnvironmentFromUrl: __WEBPACK_IMPORTED_MODULE_0__checkImportEnvironmentFromUrl__["a" /* default */],
  importCollectionAndEnvironment: __WEBPACK_IMPORTED_MODULE_1__importCollectionAndEnvironment__["a" /* default */],
  importData,
  convertRawData: __WEBPACK_IMPORTED_MODULE_2__convertData__["a" /* default */],
  importDataAs: __WEBPACK_IMPORTED_MODULE_2__convertData__["b" /* importDataAs */],
  stringify: __WEBPACK_IMPORTED_MODULE_2__convertData__["c" /* stringify */],
  importFileFromUrl: __WEBPACK_IMPORTED_MODULE_3__importFileFromUrl__["a" /* default */],
  importFiles: __WEBPACK_IMPORTED_MODULE_4__importFiles__["a" /* default */],
  importFolder: __WEBPACK_IMPORTED_MODULE_5__importFolder__["a" /* default */],
  saveEntity: __WEBPACK_IMPORTED_MODULE_6__saveEntity__["a" /* default */] });
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),

/***/ 3406:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, isEmpty, isFunction, isObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(3410), isObject = ref.isObject, isFunction = ref.isFunction, isEmpty = ref.isEmpty;

  XMLElement = null;

  XMLCData = null;

  XMLComment = null;

  XMLDeclaration = null;

  XMLDocType = null;

  XMLRaw = null;

  XMLText = null;

  XMLProcessingInstruction = null;

  module.exports = XMLNode = (function() {
    function XMLNode(parent) {
      this.parent = parent;
      if (this.parent) {
        this.options = this.parent.options;
        this.stringify = this.parent.stringify;
      }
      this.children = [];
      if (!XMLElement) {
        XMLElement = __webpack_require__(3431);
        XMLCData = __webpack_require__(3432);
        XMLComment = __webpack_require__(3433);
        XMLDeclaration = __webpack_require__(3434);
        XMLDocType = __webpack_require__(3435);
        XMLRaw = __webpack_require__(3440);
        XMLText = __webpack_require__(3441);
        XMLProcessingInstruction = __webpack_require__(3442);
      }
    }

    XMLNode.prototype.element = function(name, attributes, text) {
      var childNode, item, j, k, key, lastChild, len, len1, ref1, val;
      lastChild = null;
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (Array.isArray(name)) {
        for (j = 0, len = name.length; j < len; j++) {
          item = name[j];
          lastChild = this.element(item);
        }
      } else if (isFunction(name)) {
        lastChild = this.element(name.apply());
      } else if (isObject(name)) {
        for (key in name) {
          if (!hasProp.call(name, key)) continue;
          val = name[key];
          if (isFunction(val)) {
            val = val.apply();
          }
          if ((isObject(val)) && (isEmpty(val))) {
            val = null;
          }
          if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
            lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
          } else if (!this.options.separateArrayItems && Array.isArray(val)) {
            for (k = 0, len1 = val.length; k < len1; k++) {
              item = val[k];
              childNode = {};
              childNode[key] = item;
              lastChild = this.element(childNode);
            }
          } else if (isObject(val)) {
            lastChild = this.element(key);
            lastChild.element(val);
          } else {
            lastChild = this.element(key, val);
          }
        }
      } else {
        if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
          lastChild = this.text(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
          lastChild = this.cdata(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
          lastChild = this.comment(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
          lastChild = this.raw(text);
        } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
          lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
        } else {
          lastChild = this.node(name, attributes, text);
        }
      }
      if (lastChild == null) {
        throw new Error("Could not create any elements with: " + name);
      }
      return lastChild;
    };

    XMLNode.prototype.insertBefore = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.insertAfter = function(name, attributes, text) {
      var child, i, removed;
      if (this.isRoot) {
        throw new Error("Cannot insert elements at root level");
      }
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.element(name, attributes, text);
      Array.prototype.push.apply(this.parent.children, removed);
      return child;
    };

    XMLNode.prototype.remove = function() {
      var i, ref1;
      if (this.isRoot) {
        throw new Error("Cannot remove the root element");
      }
      i = this.parent.children.indexOf(this);
      [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
      return this.parent;
    };

    XMLNode.prototype.node = function(name, attributes, text) {
      var child, ref1;
      if (name != null) {
        name = name.valueOf();
      }
      attributes || (attributes = {});
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      child = new XMLElement(this, name, attributes);
      if (text != null) {
        child.text(text);
      }
      this.children.push(child);
      return child;
    };

    XMLNode.prototype.text = function(value) {
      var child;
      child = new XMLText(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.cdata = function(value) {
      var child;
      child = new XMLCData(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.comment = function(value) {
      var child;
      child = new XMLComment(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.commentBefore = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.commentAfter = function(value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.comment(value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.raw = function(value) {
      var child;
      child = new XMLRaw(this, value);
      this.children.push(child);
      return this;
    };

    XMLNode.prototype.instruction = function(target, value) {
      var insTarget, insValue, instruction, j, len;
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (j = 0, len = target.length; j < len; j++) {
          insTarget = target[j];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        instruction = new XMLProcessingInstruction(this, target, value);
        this.children.push(instruction);
      }
      return this;
    };

    XMLNode.prototype.instructionBefore = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.instructionAfter = function(target, value) {
      var child, i, removed;
      i = this.parent.children.indexOf(this);
      removed = this.parent.children.splice(i + 1);
      child = this.parent.instruction(target, value);
      Array.prototype.push.apply(this.parent.children, removed);
      return this;
    };

    XMLNode.prototype.declaration = function(version, encoding, standalone) {
      var doc, xmldec;
      doc = this.document();
      xmldec = new XMLDeclaration(doc, version, encoding, standalone);
      if (doc.children[0] instanceof XMLDeclaration) {
        doc.children[0] = xmldec;
      } else {
        doc.children.unshift(xmldec);
      }
      return doc.root() || doc;
    };

    XMLNode.prototype.doctype = function(pubID, sysID) {
      var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
      doc = this.document();
      doctype = new XMLDocType(doc, pubID, sysID);
      ref1 = doc.children;
      for (i = j = 0, len = ref1.length; j < len; i = ++j) {
        child = ref1[i];
        if (child instanceof XMLDocType) {
          doc.children[i] = doctype;
          return doctype;
        }
      }
      ref2 = doc.children;
      for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
        child = ref2[i];
        if (child.isRoot) {
          doc.children.splice(i, 0, doctype);
          return doctype;
        }
      }
      doc.children.push(doctype);
      return doctype;
    };

    XMLNode.prototype.up = function() {
      if (this.isRoot) {
        throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
      }
      return this.parent;
    };

    XMLNode.prototype.root = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node.rootObject;
        } else if (node.isRoot) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.document = function() {
      var node;
      node = this;
      while (node) {
        if (node.isDocument) {
          return node;
        } else {
          node = node.parent;
        }
      }
    };

    XMLNode.prototype.end = function(options) {
      return this.document().end(options);
    };

    XMLNode.prototype.prev = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i < 1) {
        throw new Error("Already at the first node");
      }
      return this.parent.children[i - 1];
    };

    XMLNode.prototype.next = function() {
      var i;
      i = this.parent.children.indexOf(this);
      if (i === -1 || i === this.parent.children.length - 1) {
        throw new Error("Already at the last node");
      }
      return this.parent.children[i + 1];
    };

    XMLNode.prototype.importDocument = function(doc) {
      var clonedRoot;
      clonedRoot = doc.root().clone();
      clonedRoot.parent = this;
      clonedRoot.isRoot = false;
      this.children.push(clonedRoot);
      return this;
    };

    XMLNode.prototype.ele = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.doc = function() {
      return this.document();
    };

    XMLNode.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLNode.prototype.dtd = function(pubID, sysID) {
      return this.doctype(pubID, sysID);
    };

    XMLNode.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLNode.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLNode.prototype.t = function(value) {
      return this.text(value);
    };

    XMLNode.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLNode.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLNode.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLNode.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLNode.prototype.u = function() {
      return this.up();
    };

    XMLNode.prototype.importXMLBuilder = function(doc) {
      return this.importDocument(doc);
    };

    return XMLNode;

  })();

}).call(this);


/***/ }),

/***/ 3410:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  var assign, isArray, isEmpty, isFunction, isObject, isPlainObject,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  assign = function() {
    var i, key, len, source, sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    if (isFunction(Object.assign)) {
      Object.assign.apply(null, arguments);
    } else {
      for (i = 0, len = sources.length; i < len; i++) {
        source = sources[i];
        if (source != null) {
          for (key in source) {
            if (!hasProp.call(source, key)) continue;
            target[key] = source[key];
          }
        }
      }
    }
    return target;
  };

  isFunction = function(val) {
    return !!val && Object.prototype.toString.call(val) === '[object Function]';
  };

  isObject = function(val) {
    var ref;
    return !!val && ((ref = typeof val) === 'function' || ref === 'object');
  };

  isArray = function(val) {
    if (isFunction(Array.isArray)) {
      return Array.isArray(val);
    } else {
      return Object.prototype.toString.call(val) === '[object Array]';
    }
  };

  isEmpty = function(val) {
    var key;
    if (isArray(val)) {
      return !val.length;
    } else {
      for (key in val) {
        if (!hasProp.call(val, key)) continue;
        return false;
      }
      return true;
    }
  };

  isPlainObject = function(val) {
    var ctor, proto;
    return isObject(val) && (proto = Object.getPrototypeOf(val)) && (ctor = proto.constructor) && (typeof ctor === 'function') && (ctor instanceof ctor) && (Function.prototype.toString.call(ctor) === Function.prototype.toString.call(Object));
  };

  module.exports.assign = assign;

  module.exports.isFunction = isFunction;

  module.exports.isObject = isObject;

  module.exports.isArray = isArray;

  module.exports.isEmpty = isEmpty;

  module.exports.isPlainObject = isPlainObject;

}).call(this);


/***/ }),

/***/ 3431:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLElement, XMLNode, isFunction, isObject, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(3410), isObject = ref.isObject, isFunction = ref.isFunction;

  XMLNode = __webpack_require__(3406);

  XMLAttribute = __webpack_require__(3480);

  module.exports = XMLElement = (function(superClass) {
    extend(XMLElement, superClass);

    function XMLElement(parent, name, attributes) {
      XMLElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing element name");
      }
      this.name = this.stringify.eleName(name);
      this.attributes = {};
      if (attributes != null) {
        this.attribute(attributes);
      }
      if (parent.isDocument) {
        this.isRoot = true;
        this.documentObject = parent;
        parent.rootObject = this;
      }
    }

    XMLElement.prototype.clone = function() {
      var att, attName, clonedSelf, ref1;
      clonedSelf = Object.create(this);
      if (clonedSelf.isRoot) {
        clonedSelf.documentObject = null;
      }
      clonedSelf.attributes = {};
      ref1 = this.attributes;
      for (attName in ref1) {
        if (!hasProp.call(ref1, attName)) continue;
        att = ref1[attName];
        clonedSelf.attributes[attName] = att.clone();
      }
      clonedSelf.children = [];
      this.children.forEach(function(child) {
        var clonedChild;
        clonedChild = child.clone();
        clonedChild.parent = clonedSelf;
        return clonedSelf.children.push(clonedChild);
      });
      return clonedSelf;
    };

    XMLElement.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLElement.prototype.removeAttribute = function(name) {
      var attName, i, len;
      if (name == null) {
        throw new Error("Missing attribute name");
      }
      name = name.valueOf();
      if (Array.isArray(name)) {
        for (i = 0, len = name.length; i < len; i++) {
          attName = name[i];
          delete this.attributes[attName];
        }
      } else {
        delete this.attributes[name];
      }
      return this;
    };

    XMLElement.prototype.toString = function(options) {
      return this.options.writer.set(options).element(this);
    };

    XMLElement.prototype.att = function(name, value) {
      return this.attribute(name, value);
    };

    XMLElement.prototype.a = function(name, value) {
      return this.attribute(name, value);
    };

    return XMLElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3432:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLCData = (function(superClass) {
    extend(XMLCData, superClass);

    function XMLCData(parent, text) {
      XMLCData.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing CDATA text");
      }
      this.text = this.stringify.cdata(text);
    }

    XMLCData.prototype.clone = function() {
      return Object.create(this);
    };

    XMLCData.prototype.toString = function(options) {
      return this.options.writer.set(options).cdata(this);
    };

    return XMLCData;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3433:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLComment, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLComment = (function(superClass) {
    extend(XMLComment, superClass);

    function XMLComment(parent, text) {
      XMLComment.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing comment text");
      }
      this.text = this.stringify.comment(text);
    }

    XMLComment.prototype.clone = function() {
      return Object.create(this);
    };

    XMLComment.prototype.toString = function(options) {
      return this.options.writer.set(options).comment(this);
    };

    return XMLComment;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3434:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDeclaration, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(3410).isObject;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLDeclaration = (function(superClass) {
    extend(XMLDeclaration, superClass);

    function XMLDeclaration(parent, version, encoding, standalone) {
      var ref;
      XMLDeclaration.__super__.constructor.call(this, parent);
      if (isObject(version)) {
        ref = version, version = ref.version, encoding = ref.encoding, standalone = ref.standalone;
      }
      if (!version) {
        version = '1.0';
      }
      this.version = this.stringify.xmlVersion(version);
      if (encoding != null) {
        this.encoding = this.stringify.xmlEncoding(encoding);
      }
      if (standalone != null) {
        this.standalone = this.stringify.xmlStandalone(standalone);
      }
    }

    XMLDeclaration.prototype.toString = function(options) {
      return this.options.writer.set(options).declaration(this);
    };

    return XMLDeclaration;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3435:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(3410).isObject;

  XMLNode = __webpack_require__(3406);

  XMLDTDAttList = __webpack_require__(3436);

  XMLDTDEntity = __webpack_require__(3437);

  XMLDTDElement = __webpack_require__(3438);

  XMLDTDNotation = __webpack_require__(3439);

  module.exports = XMLDocType = (function(superClass) {
    extend(XMLDocType, superClass);

    function XMLDocType(parent, pubID, sysID) {
      var ref, ref1;
      XMLDocType.__super__.constructor.call(this, parent);
      this.documentObject = parent;
      if (isObject(pubID)) {
        ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
      }
      if (sysID == null) {
        ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
      }
      if (pubID != null) {
        this.pubID = this.stringify.dtdPubID(pubID);
      }
      if (sysID != null) {
        this.sysID = this.stringify.dtdSysID(sysID);
      }
    }

    XMLDocType.prototype.element = function(name, value) {
      var child;
      child = new XMLDTDElement(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var child;
      child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.entity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, false, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.pEntity = function(name, value) {
      var child;
      child = new XMLDTDEntity(this, true, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.notation = function(name, value) {
      var child;
      child = new XMLDTDNotation(this, name, value);
      this.children.push(child);
      return this;
    };

    XMLDocType.prototype.toString = function(options) {
      return this.options.writer.set(options).docType(this);
    };

    XMLDocType.prototype.ele = function(name, value) {
      return this.element(name, value);
    };

    XMLDocType.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
    };

    XMLDocType.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocType.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocType.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    XMLDocType.prototype.up = function() {
      return this.root() || this.documentObject;
    };

    return XMLDocType;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3436:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDAttList, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLDTDAttList = (function(superClass) {
    extend(XMLDTDAttList, superClass);

    function XMLDTDAttList(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      XMLDTDAttList.__super__.constructor.call(this, parent);
      if (elementName == null) {
        throw new Error("Missing DTD element name");
      }
      if (attributeName == null) {
        throw new Error("Missing DTD attribute name");
      }
      if (!attributeType) {
        throw new Error("Missing DTD attribute type");
      }
      if (!defaultValueType) {
        throw new Error("Missing DTD attribute default");
      }
      if (defaultValueType.indexOf('#') !== 0) {
        defaultValueType = '#' + defaultValueType;
      }
      if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
        throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT");
      }
      if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
        throw new Error("Default value only applies to #FIXED or #DEFAULT");
      }
      this.elementName = this.stringify.eleName(elementName);
      this.attributeName = this.stringify.attName(attributeName);
      this.attributeType = this.stringify.dtdAttType(attributeType);
      this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
      this.defaultValueType = defaultValueType;
    }

    XMLDTDAttList.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdAttList(this);
    };

    return XMLDTDAttList;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3437:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDEntity, XMLNode, isObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isObject = __webpack_require__(3410).isObject;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLDTDEntity = (function(superClass) {
    extend(XMLDTDEntity, superClass);

    function XMLDTDEntity(parent, pe, name, value) {
      XMLDTDEntity.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing entity name");
      }
      if (value == null) {
        throw new Error("Missing entity value");
      }
      this.pe = !!pe;
      this.name = this.stringify.eleName(name);
      if (!isObject(value)) {
        this.value = this.stringify.dtdEntityValue(value);
      } else {
        if (!value.pubID && !value.sysID) {
          throw new Error("Public and/or system identifiers are required for an external entity");
        }
        if (value.pubID && !value.sysID) {
          throw new Error("System identifier is required for a public external entity");
        }
        if (value.pubID != null) {
          this.pubID = this.stringify.dtdPubID(value.pubID);
        }
        if (value.sysID != null) {
          this.sysID = this.stringify.dtdSysID(value.sysID);
        }
        if (value.nData != null) {
          this.nData = this.stringify.dtdNData(value.nData);
        }
        if (this.pe && this.nData) {
          throw new Error("Notation declaration is not allowed in a parameter entity");
        }
      }
    }

    XMLDTDEntity.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdEntity(this);
    };

    return XMLDTDEntity;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3438:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDElement, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLDTDElement = (function(superClass) {
    extend(XMLDTDElement, superClass);

    function XMLDTDElement(parent, name, value) {
      XMLDTDElement.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing DTD element name");
      }
      if (!value) {
        value = '(#PCDATA)';
      }
      if (Array.isArray(value)) {
        value = '(' + value.join(',') + ')';
      }
      this.name = this.stringify.eleName(name);
      this.value = this.stringify.dtdElementValue(value);
    }

    XMLDTDElement.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdElement(this);
    };

    return XMLDTDElement;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3439:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDTDNotation, XMLNode,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLDTDNotation = (function(superClass) {
    extend(XMLDTDNotation, superClass);

    function XMLDTDNotation(parent, name, value) {
      XMLDTDNotation.__super__.constructor.call(this, parent);
      if (name == null) {
        throw new Error("Missing notation name");
      }
      if (!value.pubID && !value.sysID) {
        throw new Error("Public or system identifiers are required for an external entity");
      }
      this.name = this.stringify.eleName(name);
      if (value.pubID != null) {
        this.pubID = this.stringify.dtdPubID(value.pubID);
      }
      if (value.sysID != null) {
        this.sysID = this.stringify.dtdSysID(value.sysID);
      }
    }

    XMLDTDNotation.prototype.toString = function(options) {
      return this.options.writer.set(options).dtdNotation(this);
    };

    return XMLDTDNotation;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3440:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLRaw,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLRaw = (function(superClass) {
    extend(XMLRaw, superClass);

    function XMLRaw(parent, text) {
      XMLRaw.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing raw text");
      }
      this.value = this.stringify.raw(text);
    }

    XMLRaw.prototype.clone = function() {
      return Object.create(this);
    };

    XMLRaw.prototype.toString = function(options) {
      return this.options.writer.set(options).raw(this);
    };

    return XMLRaw;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3441:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLText,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLText = (function(superClass) {
    extend(XMLText, superClass);

    function XMLText(parent, text) {
      XMLText.__super__.constructor.call(this, parent);
      if (text == null) {
        throw new Error("Missing element text");
      }
      this.value = this.stringify.eleText(text);
    }

    XMLText.prototype.clone = function() {
      return Object.create(this);
    };

    XMLText.prototype.toString = function(options) {
      return this.options.writer.set(options).text(this);
    };

    return XMLText;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3442:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLNode, XMLProcessingInstruction,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLNode = __webpack_require__(3406);

  module.exports = XMLProcessingInstruction = (function(superClass) {
    extend(XMLProcessingInstruction, superClass);

    function XMLProcessingInstruction(parent, target, value) {
      XMLProcessingInstruction.__super__.constructor.call(this, parent);
      if (target == null) {
        throw new Error("Missing instruction target");
      }
      this.target = this.stringify.insTarget(target);
      if (value) {
        this.value = this.stringify.insValue(value);
      }
    }

    XMLProcessingInstruction.prototype.clone = function() {
      return Object.create(this);
    };

    XMLProcessingInstruction.prototype.toString = function(options) {
      return this.options.writer.set(options).processingInstruction(this);
    };

    return XMLProcessingInstruction;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3457:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__swagger1__ = __webpack_require__(1516);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__swagger2__ = __webpack_require__(1518);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__postmanCollection1__ = __webpack_require__(3557);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__postmanCollection2__ = __webpack_require__(3558);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__postmanCollection2_1__ = __webpack_require__(3559);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__postmanCollection2CloudApi__ = __webpack_require__(3560);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__postmanGlobals1__ = __webpack_require__(3561);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__postmanGlobals2__ = __webpack_require__(3562);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__postmanEnvironment__ = __webpack_require__(3563);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__postmanEnvironmentCloudApi__ = __webpack_require__(3564);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__dhcProject__ = __webpack_require__(3565);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__raml__ = __webpack_require__(1519);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__runscopeRadar__ = __webpack_require__(3567);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__curl__ = __webpack_require__(3569);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__wadl__ = __webpack_require__(3458);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_15__wadlNamespaced__ = __webpack_require__(3588);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_16__wadlNamespacedNS2__ = __webpack_require__(3589);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_17__dataDump__ = __webpack_require__(3590);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_18__openapi3__ = __webpack_require__(1521);




















/* harmony default export */ __webpack_exports__["a"] = ([
__WEBPACK_IMPORTED_MODULE_0__swagger1__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_1__swagger2__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_2__postmanCollection1__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_3__postmanCollection2__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_4__postmanCollection2_1__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_5__postmanCollection2CloudApi__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_6__postmanGlobals1__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_7__postmanGlobals2__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_8__postmanEnvironment__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_9__postmanEnvironmentCloudApi__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_10__dhcProject__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_11__raml__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_12__runscopeRadar__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_13__curl__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_14__wadl__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_15__wadlNamespaced__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_16__wadlNamespacedNS2__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_18__openapi3__["a" /* default */],
__WEBPACK_IMPORTED_MODULE_17__dataDump__["a" /* default */]]);

/***/ }),

/***/ 3458:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_wadl_to_postman__ = __webpack_require__(3578);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_wadl_to_postman___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__postman_wadl_to_postman__);


/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'wadl',

  /**
               * The type of format, irrespective of version
               * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
               *
               * @type {string}
               */
  type: 'wadl',

  /**
                 * The user-friendly name of the format. Used for success and error messages.
                 *
                 * @type {string}
                 */
  name: 'WADL',

  /**
                 * Determines whether the given data is in WADL format
                 *
                 * @param {string} data - A string containing JSON/YAML/XML/etc.
                 * @returns {boolean} - Returns true if the data appears to be in WADL format
                 */
  isFormat(data) {
    let firstLine = __WEBPACK_IMPORTED_MODULE_0__parse__["a" /* default */].firstLine(data);
    let first400Characters = data.substr(0, 400);

    return firstLine.includes('<') && first400Characters.includes('<application');
  },

  /**
      * Converts the given data from WADL format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  convert(data) {
    return new Promise((resolve, reject) => {
      __WEBPACK_IMPORTED_MODULE_1__postman_wadl_to_postman___default.a.convertXMLString(data, {}, success, failure);

      function success(collection) {
        resolve({ collections: [collection] });
      }

      function failure(errorMessage) {
        reject(new SyntaxError(errorMessage));
      }
    });
  } });

/***/ }),

/***/ 3459:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  exports.defaults = {
    "0.1": {
      explicitCharkey: false,
      trim: true,
      normalize: true,
      normalizeTags: false,
      attrkey: "@",
      charkey: "#",
      explicitArray: false,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: false,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      childkey: '@@',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      emptyTag: ''
    },
    "0.2": {
      explicitCharkey: false,
      trim: false,
      normalize: false,
      normalizeTags: false,
      attrkey: "$",
      charkey: "_",
      explicitArray: true,
      ignoreAttrs: false,
      mergeAttrs: false,
      explicitRoot: true,
      validator: null,
      xmlns: false,
      explicitChildren: false,
      preserveChildrenOrder: false,
      childkey: '$$',
      charsAsChildren: false,
      includeWhiteChars: false,
      async: false,
      strict: true,
      attrNameProcessors: null,
      attrValueProcessors: null,
      tagNameProcessors: null,
      valueProcessors: null,
      rootName: 'root',
      xmldec: {
        'version': '1.0',
        'encoding': 'UTF-8',
        'standalone': true
      },
      doctype: null,
      renderOpts: {
        'pretty': true,
        'indent': '  ',
        'newline': '\n'
      },
      headless: false,
      chunkSize: 10000,
      emptyTag: '',
      cdata: false
    }
  };

}).call(this);


/***/ }),

/***/ 3460:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(3434);

  XMLDocType = __webpack_require__(3435);

  XMLCData = __webpack_require__(3432);

  XMLComment = __webpack_require__(3433);

  XMLElement = __webpack_require__(3431);

  XMLRaw = __webpack_require__(3440);

  XMLText = __webpack_require__(3441);

  XMLProcessingInstruction = __webpack_require__(3442);

  XMLDTDAttList = __webpack_require__(3436);

  XMLDTDElement = __webpack_require__(3438);

  XMLDTDEntity = __webpack_require__(3437);

  XMLDTDNotation = __webpack_require__(3439);

  XMLWriterBase = __webpack_require__(3482);

  module.exports = XMLStringWriter = (function(superClass) {
    extend(XMLStringWriter, superClass);

    function XMLStringWriter(options) {
      XMLStringWriter.__super__.constructor.call(this, options);
    }

    XMLStringWriter.prototype.document = function(doc) {
      var child, i, len, r, ref;
      this.textispresent = false;
      r = '';
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        r += (function() {
          switch (false) {
            case !(child instanceof XMLDeclaration):
              return this.declaration(child);
            case !(child instanceof XMLDocType):
              return this.docType(child);
            case !(child instanceof XMLComment):
              return this.comment(child);
            case !(child instanceof XMLProcessingInstruction):
              return this.processingInstruction(child);
            default:
              return this.element(child, 0);
          }
        }).call(this);
      }
      if (this.pretty && r.slice(-this.newline.length) === this.newline) {
        r = r.slice(0, -this.newline.length);
      }
      return r;
    };

    XMLStringWriter.prototype.attribute = function(att) {
      return ' ' + att.name + '="' + att.value + '"';
    };

    XMLStringWriter.prototype.cdata = function(node, level) {
      return this.space(level) + '<![CDATA[' + node.text + ']]>' + this.newline;
    };

    XMLStringWriter.prototype.comment = function(node, level) {
      return this.space(level) + '<!-- ' + node.text + ' -->' + this.newline;
    };

    XMLStringWriter.prototype.declaration = function(node, level) {
      var r;
      r = this.space(level);
      r += '<?xml version="' + node.version + '"';
      if (node.encoding != null) {
        r += ' encoding="' + node.encoding + '"';
      }
      if (node.standalone != null) {
        r += ' standalone="' + node.standalone + '"';
      }
      r += this.spacebeforeslash + '?>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.docType = function(node, level) {
      var child, i, len, r, ref;
      level || (level = 0);
      r = this.space(level);
      r += '<!DOCTYPE ' + node.root().name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      if (node.children.length > 0) {
        r += ' [';
        r += this.newline;
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLDTDAttList):
                return this.dtdAttList(child, level + 1);
              case !(child instanceof XMLDTDElement):
                return this.dtdElement(child, level + 1);
              case !(child instanceof XMLDTDEntity):
                return this.dtdEntity(child, level + 1);
              case !(child instanceof XMLDTDNotation):
                return this.dtdNotation(child, level + 1);
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown DTD node type: " + child.constructor.name);
            }
          }).call(this);
        }
        r += ']';
      }
      r += this.spacebeforeslash + '>';
      r += this.newline;
      return r;
    };

    XMLStringWriter.prototype.element = function(node, level) {
      var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
      level || (level = 0);
      textispresentwasset = false;
      if (this.textispresent) {
        this.newline = '';
        this.pretty = false;
      } else {
        this.newline = this.newlinedefault;
        this.pretty = this.prettydefault;
      }
      space = this.space(level);
      r = '';
      r += space + '<' + node.name;
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        r += this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          r += '></' + node.name + '>' + this.newline;
        } else {
          r += this.spacebeforeslash + '/>' + this.newline;
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        r += '>';
        r += node.children[0].value;
        r += '</' + node.name + '>' + this.newline;
      } else {
        if (this.dontprettytextnodes) {
          ref1 = node.children;
          for (i = 0, len = ref1.length; i < len; i++) {
            child = ref1[i];
            if (child.value != null) {
              this.textispresent++;
              textispresentwasset = true;
              break;
            }
          }
        }
        if (this.textispresent) {
          this.newline = '';
          this.pretty = false;
          space = this.space(level);
        }
        r += '>' + this.newline;
        ref2 = node.children;
        for (j = 0, len1 = ref2.length; j < len1; j++) {
          child = ref2[j];
          r += (function() {
            switch (false) {
              case !(child instanceof XMLCData):
                return this.cdata(child, level + 1);
              case !(child instanceof XMLComment):
                return this.comment(child, level + 1);
              case !(child instanceof XMLElement):
                return this.element(child, level + 1);
              case !(child instanceof XMLRaw):
                return this.raw(child, level + 1);
              case !(child instanceof XMLText):
                return this.text(child, level + 1);
              case !(child instanceof XMLProcessingInstruction):
                return this.processingInstruction(child, level + 1);
              default:
                throw new Error("Unknown XML node type: " + child.constructor.name);
            }
          }).call(this);
        }
        if (textispresentwasset) {
          this.textispresent--;
        }
        if (!this.textispresent) {
          this.newline = this.newlinedefault;
          this.pretty = this.prettydefault;
        }
        r += space + '</' + node.name + '>' + this.newline;
      }
      return r;
    };

    XMLStringWriter.prototype.processingInstruction = function(node, level) {
      var r;
      r = this.space(level) + '<?' + node.target;
      if (node.value) {
        r += ' ' + node.value;
      }
      r += this.spacebeforeslash + '?>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.raw = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.text = function(node, level) {
      return this.space(level) + node.value + this.newline;
    };

    XMLStringWriter.prototype.dtdAttList = function(node, level) {
      var r;
      r = this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType;
      if (node.defaultValueType !== '#DEFAULT') {
        r += ' ' + node.defaultValueType;
      }
      if (node.defaultValue) {
        r += ' "' + node.defaultValue + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdElement = function(node, level) {
      return this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value + this.spacebeforeslash + '>' + this.newline;
    };

    XMLStringWriter.prototype.dtdEntity = function(node, level) {
      var r;
      r = this.space(level) + '<!ENTITY';
      if (node.pe) {
        r += ' %';
      }
      r += ' ' + node.name;
      if (node.value) {
        r += ' "' + node.value + '"';
      } else {
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        if (node.nData) {
          r += ' NDATA ' + node.nData;
        }
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.dtdNotation = function(node, level) {
      var r;
      r = this.space(level) + '<!NOTATION ' + node.name;
      if (node.pubID && node.sysID) {
        r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
      } else if (node.pubID) {
        r += ' PUBLIC "' + node.pubID + '"';
      } else if (node.sysID) {
        r += ' SYSTEM "' + node.sysID + '"';
      }
      r += this.spacebeforeslash + '>' + this.newline;
      return r;
    };

    XMLStringWriter.prototype.openNode = function(node, level) {
      var att, name, r, ref;
      level || (level = 0);
      if (node instanceof XMLElement) {
        r = this.space(level) + '<' + node.name;
        ref = node.attributes;
        for (name in ref) {
          if (!hasProp.call(ref, name)) continue;
          att = ref[name];
          r += this.attribute(att);
        }
        r += (node.children ? '>' : '/>') + this.newline;
        return r;
      } else {
        r = this.space(level) + '<!DOCTYPE ' + node.rootNodeName;
        if (node.pubID && node.sysID) {
          r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
        } else if (node.sysID) {
          r += ' SYSTEM "' + node.sysID + '"';
        }
        r += (node.children ? ' [' : '>') + this.newline;
        return r;
      }
    };

    XMLStringWriter.prototype.closeNode = function(node, level) {
      level || (level = 0);
      switch (false) {
        case !(node instanceof XMLElement):
          return this.space(level) + '</' + node.name + '>' + this.newline;
        case !(node instanceof XMLDocType):
          return this.space(level) + ']>' + this.newline;
      }
    };

    return XMLStringWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ 3480:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute;

  module.exports = XMLAttribute = (function() {
    function XMLAttribute(parent, name, value) {
      this.options = parent.options;
      this.stringify = parent.stringify;
      if (name == null) {
        throw new Error("Missing attribute name of element " + parent.name);
      }
      if (value == null) {
        throw new Error("Missing attribute value for attribute " + name + " of element " + parent.name);
      }
      this.name = this.stringify.attName(name);
      this.value = this.stringify.attValue(value);
    }

    XMLAttribute.prototype.clone = function() {
      return Object.create(this);
    };

    XMLAttribute.prototype.toString = function(options) {
      return this.options.writer.set(options).attribute(this);
    };

    return XMLAttribute;

  })();

}).call(this);


/***/ }),

/***/ 3481:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLStringifier,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  module.exports = XMLStringifier = (function() {
    function XMLStringifier(options) {
      this.assertLegalChar = bind(this.assertLegalChar, this);
      var key, ref, value;
      options || (options = {});
      this.noDoubleEncoding = options.noDoubleEncoding;
      ref = options.stringify || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
    }

    XMLStringifier.prototype.eleName = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.eleText = function(val) {
      val = '' + val || '';
      return this.assertLegalChar(this.elEscape(val));
    };

    XMLStringifier.prototype.cdata = function(val) {
      val = '' + val || '';
      val = val.replace(']]>', ']]]]><![CDATA[>');
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.comment = function(val) {
      val = '' + val || '';
      if (val.match(/--/)) {
        throw new Error("Comment text cannot contain double-hypen: " + val);
      }
      return this.assertLegalChar(val);
    };

    XMLStringifier.prototype.raw = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.attName = function(val) {
      return val = '' + val || '';
    };

    XMLStringifier.prototype.attValue = function(val) {
      val = '' + val || '';
      return this.attEscape(val);
    };

    XMLStringifier.prototype.insTarget = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.insValue = function(val) {
      val = '' + val || '';
      if (val.match(/\?>/)) {
        throw new Error("Invalid processing instruction value: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlVersion = function(val) {
      val = '' + val || '';
      if (!val.match(/1\.[0-9]+/)) {
        throw new Error("Invalid version number: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlEncoding = function(val) {
      val = '' + val || '';
      if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
        throw new Error("Invalid encoding: " + val);
      }
      return val;
    };

    XMLStringifier.prototype.xmlStandalone = function(val) {
      if (val) {
        return "yes";
      } else {
        return "no";
      }
    };

    XMLStringifier.prototype.dtdPubID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdSysID = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdElementValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttType = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdAttDefault = function(val) {
      if (val != null) {
        return '' + val || '';
      } else {
        return val;
      }
    };

    XMLStringifier.prototype.dtdEntityValue = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.dtdNData = function(val) {
      return '' + val || '';
    };

    XMLStringifier.prototype.convertAttKey = '@';

    XMLStringifier.prototype.convertPIKey = '?';

    XMLStringifier.prototype.convertTextKey = '#text';

    XMLStringifier.prototype.convertCDataKey = '#cdata';

    XMLStringifier.prototype.convertCommentKey = '#comment';

    XMLStringifier.prototype.convertRawKey = '#raw';

    XMLStringifier.prototype.assertLegalChar = function(str) {
      var res;
      res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
      if (res) {
        throw new Error("Invalid character in string: " + str + " at index " + res.index);
      }
      return str;
    };

    XMLStringifier.prototype.elEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\r/g, '&#xD;');
    };

    XMLStringifier.prototype.attEscape = function(str) {
      var ampregex;
      ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
      return str.replace(ampregex, '&amp;').replace(/</g, '&lt;').replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
    };

    return XMLStringifier;

  })();

}).call(this);


/***/ }),

/***/ 3482:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLWriterBase,
    hasProp = {}.hasOwnProperty;

  module.exports = XMLWriterBase = (function() {
    function XMLWriterBase(options) {
      var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
      options || (options = {});
      this.pretty = options.pretty || false;
      this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
      if (this.pretty) {
        this.indent = (ref1 = options.indent) != null ? ref1 : '  ';
        this.newline = (ref2 = options.newline) != null ? ref2 : '\n';
        this.offset = (ref3 = options.offset) != null ? ref3 : 0;
        this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref6 = options.writer || {};
      for (key in ref6) {
        if (!hasProp.call(ref6, key)) continue;
        value = ref6[key];
        this[key] = value;
      }
    }

    XMLWriterBase.prototype.set = function(options) {
      var key, ref, value;
      options || (options = {});
      if ("pretty" in options) {
        this.pretty = options.pretty;
      }
      if ("allowEmpty" in options) {
        this.allowEmpty = options.allowEmpty;
      }
      if (this.pretty) {
        this.indent = "indent" in options ? options.indent : '  ';
        this.newline = "newline" in options ? options.newline : '\n';
        this.offset = "offset" in options ? options.offset : 0;
        this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
      } else {
        this.indent = '';
        this.newline = '';
        this.offset = 0;
        this.dontprettytextnodes = 0;
      }
      this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : '';
      if (this.spacebeforeslash === true) {
        this.spacebeforeslash = ' ';
      }
      this.newlinedefault = this.newline;
      this.prettydefault = this.pretty;
      ref = options.writer || {};
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this[key] = value;
      }
      return this;
    };

    XMLWriterBase.prototype.space = function(level) {
      var indent;
      if (this.pretty) {
        indent = (level || 0) + this.offset + 1;
        if (indent > 0) {
          return new Array(indent).join(this.indent);
        } else {
          return '';
        }
      } else {
        return '';
      }
    };

    return XMLWriterBase;

  })();

}).call(this);


/***/ }),

/***/ 3483:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var prefixMatch;

  prefixMatch = new RegExp(/(?!xmlns)^.*:/);

  exports.normalize = function(str) {
    return str.toLowerCase();
  };

  exports.firstCharLowerCase = function(str) {
    return str.charAt(0).toLowerCase() + str.slice(1);
  };

  exports.stripPrefix = function(str) {
    return str.replace(prefixMatch, '');
  };

  exports.parseNumbers = function(str) {
    if (!isNaN(str)) {
      str = str % 1 === 0 ? parseInt(str, 10) : parseFloat(str);
    }
    return str;
  };

  exports.parseBooleans = function(str) {
    if (/^(?:true|false)$/i.test(str)) {
      str = str.toLowerCase() === 'true';
    }
    return str;
  };

}).call(this);


/***/ }),

/***/ 3556:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {/* harmony export (immutable) */ __webpack_exports__["a"] = checkImportEnvironmentFromUrl;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_postman_collection_transformer__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_postman_collection_transformer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_postman_collection_transformer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_js_yaml__ = __webpack_require__(937);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_js_yaml___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_js_yaml__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formats__ = __webpack_require__(3457);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__modules_pipelines_user_action__ = __webpack_require__(48);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__utils_util__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__modules_controllers_UserController__ = __webpack_require__(50);







/**
                                                                        * Checks a URL for presence of an environment, and imports the environment if it is present.
                                                                        * If a URL has been clicked on, it might include an environment
                                                                        * See https://postmanlabs.atlassian.net/wiki/display/PRODUCT/Run+in+Postman+-+Protocol+Proposal for more
                                                                        *
                                                                        * @param {URL} url - URL of the resource that is being fetched
                                                                        *
                                                                        * @fires Environments#importedEnvironmentFromURL
                                                                        */
function checkImportEnvironmentFromUrl(url) {
  url = decodeURIComponent(url);
  var urlVars = __WEBPACK_IMPORTED_MODULE_4__utils_util__["a" /* default */].getHashVars(url, false),
  i;
  _.each(urlVars, function (urlVar) {
    var key = decodeURIComponent(urlVar.key);
    if (key.indexOf('env[') == 0 && key[key.length - 1] == ']') {
      try {
        // if urlVar.value ends with ", trim it
        // for the extra trailing " in some cases
        var asciiVal = '';
        try {
          asciiVal = atob(urlVar.value);
        }
        catch (e) {
          if (_.endsWith(urlVar.value, '"')) {
            urlVar.value = urlVar.value.substring(0, urlVar.value.length - 1);
            asciiVal = atob(urlVar.value);
          } else
          {
            throw e;
          }
        }

        var name = key.substring(4, key.length - 1),
        envJson = JSON.parse(asciiVal),
        envArrayToUse = [];

        if (envJson instanceof Array) {
          var numVars = envJson.length;
          for (i = 0; i < numVars; i++) {
            envArrayToUse.push(_.assign({
              'type': 'text',
              'enabled': true },
            envJson[i]));
          }
        } else
        {
          // it's an object
          _.forOwn(envJson, function (value, key) {
            envArrayToUse.push({
              key: key,
              value: value,
              type: 'text',
              enabled: true });

          });
        }

        __WEBPACK_IMPORTED_MODULE_5__modules_controllers_UserController__["a" /* default */].
        get().
        then(user => {
          let createEnvironmentEvent = {
            name: 'create',
            namespace: 'environment',
            data: {
              id: __WEBPACK_IMPORTED_MODULE_4__utils_util__["a" /* default */].guid(),
              name: name,
              values: envArrayToUse,
              owner: user.id } };



          Object(__WEBPACK_IMPORTED_MODULE_3__modules_pipelines_user_action__["a" /* default */])(createEnvironmentEvent);

          pm.toasts.success('Environment ' + name + ' imported');
        }).
        catch(e => {
          pm.logger.error('Error in creating evironment', e);
        });
      }
      catch (e) {
        console.log('Could not import environment');
      }
    }
  });
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),

/***/ 3557:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'collection',

  /**
                     * The type of format, irrespective of version
                     * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                     *
                     * @type {string}
                     */
  type: 'postman_collection',

  /**
                               * The user-friendly name of the format. Used for success and error messages.
                               *
                               * @type {string}
                               */
  name: 'Postman Collection v1',

  /**
                                  * Determines whether the given data is in Postman Collection v1 format
                                  *
                                  * @param {string} data - A string containing JSON/YAML/XML/etc.
                                  * @returns {boolean} - Returns true if the data appears to be in Postman Collection v1 format
                                  */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' && (
    data.hasOwnProperty('folders') ||
    data.hasOwnProperty('requests') ||
    data.hasOwnProperty('order'));
  },

  /**
      * Converts the given data from Postman Collection v1 format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // No conversion is necessary. Just clone the existing collection
    return {
      collections: [
      __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(data)] };


  } });

/***/ }),

/***/ 3558:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer__);




/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'COLLECTION_V2',

  /**
                        * The type of format, irrespective of version
                        * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                        *
                        * @type {string}
                        */
  type: 'postman_collection',

  /**
                               * The user-friendly name of the format. Used for success and error messages.
                               *
                               * @type {string}
                               */
  name: 'Postman Collection v2.0',

  /**
                                    * Determines whether the given data is in Postman Collection v2.0 format
                                    *
                                    * @param {string} data - A string containing JSON/YAML/XML/etc.
                                    * @returns {boolean} - Returns true if the data appears to be in Postman Collection v2.0 format
                                    */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    typeof data.info === 'object' &&
    typeof data.info.schema === 'string' &&
    data.info.schema.includes('https://schema.getpostman.com/json/collection/v2.0');
  },

  /**
      * Converts the given data from Postman Collection v2.0 format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // Convert the V2 collection to V1 for importing
    let collection = __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer___default.a.convert(data, {
      inputVersion: '2.0.0',
      outputVersion: '1.0.0' });


    // Add an ID field, so analytics can get the original ID
    collection.id = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.get(data, 'info._postman_id');

    return { collections: [collection] };
  } });

/***/ }),

/***/ 3559:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer__);




/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'COLLECTION_V2_1',

  /**
                          * The type of format, irrespective of version
                          * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                          *
                          * @type {string}
                          */
  type: 'postman_collection',

  /**
                               * The user-friendly name of the format. Used for success and error messages.
                               *
                               * @type {string}
                               */
  name: 'Postman Collection v2.1',

  /**
                                    * Determines whether the given data is in Postman Collection v2.1 format
                                    *
                                    * @param {string} data - A string containing JSON/YAML/XML/etc.
                                    * @returns {boolean} - Returns true if the data appears to be in Postman Collection v2.1 format
                                    */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    typeof data.info === 'object' &&
    typeof data.info.schema === 'string' &&
    data.info.schema.includes('https://schema.getpostman.com/json/collection/v2.1.0');
  },

  /**
      * Converts the given data from Postman Collection v2.1 format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // Convert the V2 collection to V1 for importing
    let collection = __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer___default.a.convert(data, {
      inputVersion: '2.1.0',
      outputVersion: '1.0.0' });


    // Add an ID field, so analytics can get the original ID
    collection.id = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.get(data, 'info._postman_id');

    return { collections: [collection] };
  } });

/***/ }),

/***/ 3560:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer__);




/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'COLLECTION_V2_CLOUDAPI',

  /**
                                 * The type of format, irrespective of version
                                 * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                                 *
                                 * @type {string}
                                 */
  type: 'postman_collection',

  /**
                               * The user-friendly name of the format. Used for success and error messages.
                               *
                               * @type {string}
                               */
  name: 'Postman Collection v2 (from Cloud API)',

  /**
                                                   * Determines whether the given data is in Postman Collection v2 (from Cloud API) format
                                                   *
                                                   * @param {string} data - A string containing JSON/YAML/XML/etc.
                                                   * @returns {boolean} - Returns true if the data appears to be in Postman Collection v2 (from Cloud API) format
                                                   */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    typeof data.collection === 'object' &&
    typeof data.collection.info === 'object' &&
    typeof data.collection.info.schema === 'string' &&
    data.collection.info.schema.includes('https://schema.getpostman.com');
  },

  /**
      * Converts the given data from Postman Collection v2 (from Cloud API) format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // Convert the V2 collection to V1 for importing
    let collection = __WEBPACK_IMPORTED_MODULE_2_postman_collection_transformer___default.a.convert(data.collection, {
      inputVersion: '2.0.0',
      outputVersion: '1.0.0' });


    // Add an ID field, so analytics can get the original ID
    collection.id = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.get(data, 'collection.info._postman_id');

    return { collections: [collection] };
  } });

/***/ }),

/***/ 3561:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'GLOBALS',

  /**
                  * The type of format, irrespective of version
                  * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                  *
                  * @type {string}
                  */
  type: 'postman_globals',

  /**
                            * The user-friendly name of the format. Used for success and error messages.
                            *
                            * @type {string}
                            */
  name: 'Postman Global Variables',

  /**
                                     * Determines whether the given data is in Postman Global Variables format
                                     *
                                     * @param {string} data - A string containing JSON/YAML/XML/etc.
                                     * @returns {boolean} - Returns true if the data appears to be in Postman Global Variables format
                                     */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    if (Array.isArray(data)) {
      // is globals only if each element of the array has a key and value prop
      // if there's any element of the array without KEY and VALUE, it's not a GLOBALS file
      return data.every(item => item.hasOwnProperty('key') && item.hasOwnProperty('value'));
    } else
    {
      return false;
    }
  },

  /**
      * Converts the given data from Postman Global Variables format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ globals: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // No conversion is necessary. Just clone the existing globals
    return { globals: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(data) };
  } });

/***/ }),

/***/ 3562:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'GLOBALS_V2',

  /**
                     * The type of format, irrespective of version
                     * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                     *
                     * @type {string}
                     */
  type: 'postman_globals',

  /**
                            * The user-friendly name of the format. Used for success and error messages.
                            *
                            * @type {string}
                            */
  name: 'Postman Global Variables v2',

  /**
                                        * Determines whether the given data is in Postman Global Variables v2 format
                                        *
                                        * @param {string} data - A string containing JSON/YAML/XML/etc.
                                        * @returns {boolean} - Returns true if the data appears to be in Postman Global Variables v2 format
                                        */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    data.hasOwnProperty('values') &&
    data.hasOwnProperty('name') &&
    data.hasOwnProperty('_postman_variable_scope') &&
    data._postman_variable_scope === 'globals';
  },

  /**
      * Converts the given data from Postman Global Variables v2 format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ globals: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // No conversion is necessary. Just clone the existing globals
    return { globals: __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(data.values) };
  } });

/***/ }),

/***/ 3563:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'ENVIRONMENT',

  /**
                      * The type of format, irrespective of version
                      * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                      *
                      * @type {string}
                      */
  type: 'postman_environment',

  /**
                                * The user-friendly name of the format. Used for success and error messages.
                                *
                                * @type {string}
                                */
  name: 'Postman Environment',

  /**
                                * Determines whether the given data is in Postman Environment format
                                *
                                * @param {string} data - A string containing JSON/YAML/XML/etc.
                                * @returns {boolean} - Returns true if the data appears to be in Postman Environment format
                                */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    data.hasOwnProperty('values') &&
    data.hasOwnProperty('name');
  },

  /**
      * Converts the given data from Postman Environment format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ environments: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // No conversion is necessary. Just clone the existing environment
    return {
      environments: [
      __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(data)] };


  } });

/***/ }),

/***/ 3564:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'ENVIRONMENT_CLOUDAPI',

  /**
                               * The type of format, irrespective of version
                               * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                               *
                               * @type {string}
                               */
  type: 'postman_environment',

  /**
                                * The user-friendly name of the format. Used for success and error messages.
                                *
                                * @type {string}
                                */
  name: 'Postman Environment (from Cloud API)',

  /**
                                                 * Determines whether the given data is in Postman Environment (from Cloud API) format
                                                 *
                                                 * @param {string} data - A string containing JSON/YAML/XML/etc.
                                                 * @returns {boolean} - Returns true if the data appears to be in Postman Environment (from Cloud API) format
                                                 */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    typeof data.environment === 'object' &&
    data.environment.hasOwnProperty('values') &&
    data.environment.hasOwnProperty('name');
  },

  /**
      * Converts the given data from Postman Environment (from Cloud API) format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ environments: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // No conversion is necessary. Just clone the existing environment
    return {
      environments: [
      __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(data.environment)] };


  } });

/***/ }),

/***/ 3565:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_dhc_to_postman__ = __webpack_require__(3566);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_dhc_to_postman___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__postman_dhc_to_postman__);


/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'DHC_PROJECT',

  /**
                      * The type of format, irrespective of version
                      * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                      *
                      * @type {string}
                      */
  type: 'dhc_project',

  /**
                        * The user-friendly name of the format. Used for success and error messages.
                        *
                        * @type {string}
                        */
  name: 'DHC Project',

  /**
                        * Determines whether the given data is in DHC Project format
                        *
                        * @param {string} data - A string containing JSON/YAML/XML/etc.
                        * @returns {boolean} - Returns true if the data appears to be in DHC Project format
                        */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_0__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    data.hasOwnProperty('nodes') &&
    Array.isArray(data.nodes);
  },

  /**
      * Converts the given data from DHC Project format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_0__parse__["a" /* default */].asJSON(data);
    let collection = __WEBPACK_IMPORTED_MODULE_1__postman_dhc_to_postman___default.a.convert(data);
    return { collections: [collection] };
  } });

/***/ }),

/***/ 3566:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(0),
	uuidv4 = __webpack_require__(45);

var dhcConverter = {
	requestGroups: [],
	folderGroups: [],
	headerGroups: [],
	zidRidMap: {},
	collection: {},
	methodsWithBody: ['POST', 'PUT', 'PATCH', 'DELETE', 'LINK', 'UNLINK', 'LOCK', 'PROPFIND', 'VIEW', 'OPTIONS'],

	createCollection: function (name) {
		return {
			id: uuidv4(),
			name: name,
			description: 'New collection (imported from DHC)',
			order: [],
			folders: [],
			requests: [],
			timestamp: (new Date()).getTime()
		};
	},

	addRequestToCollection: function (request, collection) {
		if(collection.order.indexOf(request.id) === -1) {
			collection.order.push(request.id);
		}
		if(!_.find(collection.requests, function (cr) {cr.id === request.id;})) {
			request.collectionId = collection.id;
			collection.requests.push(request);
		}
	},

	convertToPmRequest: function (dhcRequest) {
		var request = {
			id: dhcRequest.id.toLowerCase(),
			name: dhcRequest.name,			
			description: '',
			folder: null,
			pathVariables: {},
			url: dhcRequest.uri.scheme.name + '://' + dhcRequest.uri.path,
			method: dhcRequest.method.name,
			headers: '',
			preRequestScript: null,
			tests: null,
			currentHelper: 'normal',
			data: null,
			dataMode: 'params',
			rawModeData: null
		};

		_.each(dhcRequest.headers, function (dhcHeader) {
			var str = (dhcHeader.enabled === false) ? '//' : '';
			str += dhcHeader.name + ': ' + dhcHeader.value + '\n';
			request.headers += str;
		});


		if(this.methodsWithBody.indexOf(request.method.toUpperCase()) > -1) {
			var dhcBody = dhcRequest.body;
			if(dhcBody.bodyType === 'Form' && dhcBody.formBody && dhcBody.formBody.encoding === 'multipart/form-data') {
				// multipart
				request.dataMode = 'params';
				request.data = [];
				_.each(dhcBody.formBody.items, function (item) {
					if(item.type === 'Text') {
						request.data.push({
							key: item.name,
							value: item.value,
							type: 'text',
							enabled: item.enabled
						});
					}
				});
			}
			else if(dhcBody.bodyType === 'Form' && dhcBody.formBody && 
				dhcBody.formBody.encoding === 'application/x-www-form-urlencoded') {
				// urlencoded
				request.dataMode = 'urlencoded';
				request.data = [];
				_.each(dhcBody.formBody.items, function (item) {
					if(item.type === 'Text') {
						request.data.push({
							key: item.name,
							value: item.value,
							type: 'text',
							enabled: item.enabled
						});
					}
				});
			}
			else if(dhcBody.bodyType === 'Text' && dhcBody.textBody) {
				// raw
				request.dataMode = 'raw';
				request.rawModeData = dhcBody.textBody;
			}
		}
		return request;
	},

	convertDhcProject: function (obj) {
		var rootNode = _.find(obj.nodes, function (node) {
				return node.type === 'Project';
			}),
			collection = this.createCollection(rootNode.name),
			dhcRequests = _.filter(obj.nodes, function (node) {
				return node.type === 'Request';
			}),
			oldThis = this;

		_.each(dhcRequests, function (dhcRequest) {
			var pmRequest = oldThis.convertToPmRequest(dhcRequest);
			oldThis.addRequestToCollection(pmRequest, collection);
		});
		return collection;
	},

	convert: function (dhcJson) {
		if(typeof dhcJson === 'string') {
			dhcJson = JSON.parse(dhcJson);
		}
		var collection = this.convertDhcProject(dhcJson);
		return collection;
	},
};

module.exports = dhcConverter;

/***/ }),

/***/ 3567:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_runscope_to_postman__ = __webpack_require__(3568);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_runscope_to_postman___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__postman_runscope_to_postman__);


/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'RUNSCOPE_RADAR',

  /**
                         * The type of format, irrespective of version
                         * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                         *
                         * @type {string}
                         */
  type: 'runscope_radar',

  /**
                           * The user-friendly name of the format. Used for success and error messages.
                           *
                           * @type {string}
                           */
  name: 'Runscope Radar',

  /**
                           * Determines whether the given data is in Runscope Radar format
                           *
                           * @param {string} data - A string containing JSON/YAML/XML/etc.
                           * @returns {boolean} - Returns true if the data appears to be in Runscope Radar format
                           */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_0__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    data.hasOwnProperty('trigger_url') &&
    data.hasOwnProperty('steps');
  },

  /**
      * Converts the given data from Runscope Radar format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[], environments: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_0__parse__["a" /* default */].asJSON(data);
    let collection = __WEBPACK_IMPORTED_MODULE_1__postman_runscope_to_postman___default.a.convert(data);
    return { collections: [collection] };
  } });

/***/ }),

/***/ 3568:
/***/ (function(module, exports, __webpack_require__) {

var _ = __webpack_require__(0),
	//SDK = require('postman-collection'),
	uuidv4 = __webpack_require__(45);

// var runscopeConverterV2 = {
// 	validateRunscope: function (runscopeJson) {
// 		//validate
// 		if (typeof runscopeJson === 'string') {
// 			runscopeJson = JSON.parse(runscopeJson);
// 		}

// 		if (runscopeJson.hasOwnProperty('name') && 
// 			runscopeJson.hasOwnProperty('trigger_url')) {
// 			return runscopeJson;
// 		}
// 		else {
// 			throw {
// 				'message': 'Not a runscope test'
// 			};
// 		}
// 	},

// 	getHeadersForStep: function (runscopeJson, step) {
// 		var retVal = [];
// 		for (var prop in step) {
// 			if (step.hasOwnProperty(prop)) {
// 				retVal.push(new SDK.Header({
// 					key: prop,
// 					value: step[prop][0]
// 				}));
// 			}
// 		}
// 		return retVal;
// 	},

// 	getRequestsFromSteps: function (runscopeJson) {
// 		var oldThis = this;
// 		return _.map(runscopeJson.steps, function(step) {
// 			console.log('URL: ' + step.url);
// 			var r = new SDK.Request({
// 				url: step.url,
// 				method: step.method
// 			});
// 			r.headers = oldThis.getHeadersForStep(runscopeJson, step);
// 			return r;
// 		});
// 	},

// 	convert: function (runscopeJson) {
// 		var oldThis = this;
// 		runscopeJson = oldThis.validateRunscope(runscopeJson);
// 		var collection = new SDK.Collection({
// 			info: {
// 				name: runscopeJson.name,
// 				description: runscopeJson.description
// 			}
// 		});


// 		var items = oldThis.getRequestsFromSteps(runscopeJson);
// 		_.each(items, function (rItem) {
// 			var cItem = new SDK.Item({
// 				id: uuid.v4(),
// 				version: '1.0.0',
// 				name: rItem.name,
// 				request: rItem
// 			});
// 			console.log('Added request: ' , rItem.toJSON());
// 			collection.items.add(cItem);
// 		});
// 		//console.log(JSON.stringify(collection));
// 	}
// };


var runscopeConverterV1 = {
	validateRunscope: function (runscopeJson) {
		//validate
		if(typeof runscopeJson === 'string') {
			runscopeJson = JSON.parse(runscopeJson);
		}

		if(runscopeJson.hasOwnProperty('name') && 
			runscopeJson.hasOwnProperty('trigger_url')) {
			return runscopeJson;
		}
		else {
			throw {
				'message': 'Not a runscope test'
			};
		}
	},

	initCollection: function (runscopeJson) {
		return {
			id: uuidv4(),
			name: runscopeJson.name,
			description: runscopeJson.description,
			order: [],
			folders: [],
			requests: [],
			timestamp: (new Date()).getTime()
		};
	},

	getPostmanHeadersFromRunscopeHeaders: function (runscopeHeaders) {
		var str = '';
		for(var key in runscopeHeaders) {
			if(runscopeHeaders.hasOwnProperty(key)) {
				str += key+':'+runscopeHeaders[key]+'\n';
			}
		}
		return str;
	},

	addRequest: function (collection, request) {
		collection.order.push(request.id);
		request.collectionId = collection.id;
		collection.requests.push(request);
	},

	handleAuth: function (request, step) {
		if(step.auth.auth_type === 'basic') {
			request.currentHelper = 'basicAuth';
			request.helperAttributes = {
				id: 'basic',
				saveToRequest: true,
				username: step.auth.username,
				password: step.auth.password,
			};
		}
		//no other auth types supported yet
		//do oauth1 next
	},

	handleData: function (request, step) {
		if((typeof step.body === 'string') && JSON.stringify(step.form) == '{}') {
			request.dataMode = 'raw';
			request.data = step.body;
		}

		else if(step.form) {
			request.dataMode = 'urlencoded';
			var formArray = [];
			for(var key in step.form) {
				if(step.form.hasOwnProperty(key)) {
					formArray.push({
						key: key,
						value: step.form[key][0]
					});
				}
			}
			request.data = formArray;
		}
	},

	// handleAssertions: function (request, step) {
	// 	var tests = '';
	// 	_.each(step.assertions, function(ass) {
	// 	});
	// 	return tests;
	// },

	handleScripts: function (request, step) {
		if(!step.before_scripts) {
			step.before_scripts = [];
		}

		request.preRequestScript = '';

		var runscopePrScript = step.before_scripts.join('\n');
		runscopePrScript = runscopePrScript.replace(/\n/g,'\n//');
		if(!_.isEmpty(runscopePrScript)) {
			request.preRequestScript = '//==== You will need to convert this to a ' + 
				'Postman-compliant script ====\n' + 
				'//==== (Select text and use Ctrl + / (Win) or Cmd + / (Mac) to uncomment ====\n' + 
				'//' + runscopePrScript;
		}


		if(!step.scripts) {
			step.scripts = [];
		}
		var runscopeTestScript = step.scripts.join('\n');
		runscopeTestScript = runscopeTestScript.replace(/\n/g,'\n//');
		if(!_.isEmpty(runscopeTestScript)) {
			request.tests += '//==== You will need to convert this to a ' + 
				'Postman-compliant script ====\n' + 
				'//==== (Select text and use Ctrl + / (Win) or Cmd + / (Mac) to uncomment ====\n' + 
				'//' + runscopeTestScript;
		}
	},

	getRHSFromComparisonAndOperands: function(comparison, oper1, oper2) {
		switch(comparison) {
			case 'equal_number':
			case 'equal':
				return oper1 + ' == ' + oper2;
			case 'not_equal':
				return oper1 + '!=' + oper2;
			case 'empty':
				return '_.isEmpty(' + oper1 + ')';
			case 'not_empty':
				return '!_.isEmpty(' + oper1 + ')';
			case 'contains':
				return '_.contains(' + oper1 + ')';
			case 'does_not_contain':
				return '!_.contains(' + oper1 + ')';
			case 'is_a_number':
				return '!isNaN('+oper1+')';
			case 'is_less_than':
				return oper1 + ' < ' + oper2;
			case 'is_less_than_or_equal':
				return oper1 + ' <= ' + oper2;
			case 'is_greater_than':
				return oper1 + ' > ' + oper2;
			case 'is_greater_than_or_equal':
				return oper1 + ' >= ' + oper2;
			case 'has_key':
				return oper1 + '.hasOwnProperty(' + oper2 + ')';
			case 'has_value':
				return '_.contains(_.values(' + oper1 + '), ' + oper2 + ')';
			default:
				return '<comparison here>';
		}
	},

	handleAssertions: function (request, step) {
		var tests = '',
			oldThis = this;
		_.each(step.assertions, function (ass) {

			var testName = '',
				oper1 = null,
				oper2 = '\'' + ass.value + '\'',
				testScript = '';

			// Handle source (LHS)
			switch(ass.source) {
				case 'response_status':
					testName += 'Status Code is correct';
					oper1 = 'responseCode.code';
					break;
				case 'response_headers':
					// this will have a property
					testName += '\''+ass.property+'\' Response Header is correct';
					oper1 = 'postman.getResponseHeader(\''+ass.property+'\')';
					break;
				case 'response_json':
					if(ass.property) {
						testName += 'Response.' + ass.property + ' is correct';
						oper1 = 'JSON.parse(responseBody).'+ass.property;
					}
					else {
						testName += 'JSON Response is correct';
						oper1 = 'JSON.parse(responseBody)';
					}
					break;
				case 'response_size':
					testName += '//';
					break;
				case 'response_text':
					testName += 'Response text is correct';
					oper1 = 'responseBody';
					break;
				case 'response_time':
					testName += 'Response time is correct';
					oper1 = 'responseTime';
					break;
			}

			if(oper1) {
				testScript = 'tests["' + testName + '"] = ' + 
					oldThis.getRHSFromComparisonAndOperands(ass.comparison, oper1, oper2) + ';';
				if(testScript.indexOf('JSON.parse') > -1) {
					testScript = 'try {\n\t' + testScript + '\n}\ncatch(e) {\n\t'+
					'tests["' + testName + '"] = false;\n\t' +
					'console.log(\"Could not parse JSON\");\n}';
				}
				tests += testScript + '\n\n';
			}
		});

		if(!_.isEmpty(tests)) {
			request.tests += '//==== This section is Postman-compliant ====\n' + 
				tests + '\n';
		}
	},

	getRequestFromStep: function (step) {
		var oldThis = this;

		var request = {
			id: uuidv4(),
			url: step.url,
			headers: oldThis.getPostmanHeadersFromRunscopeHeaders(step.headers),
			pathVariables: {},
			method: step.method,
			name: step.url,
			description: step.note,
			tests: ''
		};

		oldThis.handleData(request, step);

		oldThis.handleAuth(request, step);

		oldThis.handleAssertions(request, step);

		oldThis.handleScripts(request, step);		

		return request;
	},

	convert: function (runscopeJson) {
		var oldThis = this;
		runscopeJson = this.validateRunscope(runscopeJson);
		var collection = this.initCollection(runscopeJson);

		_.each(runscopeJson.steps, function(step) {
			oldThis.addRequest(collection, oldThis.getRequestFromStep(step));
		});

		return collection;
	}
};

module.exports = runscopeConverterV1;

/***/ }),

/***/ 3569:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__parse__ = __webpack_require__(644);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_curl_to_postman__ = __webpack_require__(3570);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__postman_curl_to_postman___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__postman_curl_to_postman__);


/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'curl',

  /**
               * The type of format, irrespective of version
               * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
               *
               * @type {string}
               */
  type: 'curl',

  /**
                 * The user-friendly name of the format. Used for success and error messages.
                 *
                 * @type {string}
                 */
  name: 'Curl',

  /**
                 * Determines whether the given data is in Curl format
                 *
                 * @param {string} data - A string containing JSON/YAML/XML/etc.
                 * @returns {boolean} - Returns true if the data appears to be in Curl format
                 */
  isFormat(data) {
    let firstLine = __WEBPACK_IMPORTED_MODULE_0__parse__["a" /* default */].firstLine(data);
    return firstLine.trim().toLowerCase().startsWith('curl');
  },

  /**
      * Converts the given data from Curl format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ requests: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    let request = __WEBPACK_IMPORTED_MODULE_1__postman_curl_to_postman___default.a.convertCurlToRequest(data);

    if (request.error) {
      throw new SyntaxError(request.error);
    }

    var re = /\\n/gi;
    request.headers = request.headers.replace(re, '\n');

    // needed so that clicking on Save always opens the AddToCollection Modal
    delete request.collectionId;

    return { requests: [request] };
  } });

/***/ }),

/***/ 3570:
/***/ (function(module, exports, __webpack_require__) {

var uuidv4 = __webpack_require__(45),
    program = __webpack_require__(1517),
    _ = __webpack_require__(0).noConflict(),
    shellQuote = __webpack_require__(3571);

var curlConverter = {
    loaded: false,

    methodsWithBody: ["POST", "PUT", "PATCH", "DELETE", "LINK", "UNLINK", "LOCK", "PROPFIND", "VIEW", "OPTIONS"],

    requestUrl: "",

    initialize: function() {
        function collectValues(str, memo) {
            memo.push(str);
            return memo;
        }

        program.version('0.0.1')
            .usage('[options] <URL ...>')
            .option('-A, --user-agent <string>', 'An optional user-agent string', null)
            .option('-d, --data <string>', 'Sends the specified data to the server with type application/x-www-form-urlencoded. application/x-www-form-urlencoded', collectValues, [])
            .option('--data-ascii <string>', 'Sends the specified data to the server with type application/x-www-form-urlencoded. application/x-www-form-urlencoded', collectValues, [])
            .option('--data-urlencode <string>', 'Sends the specified data to the server with type application/x-www-form-urlencoded. application/x-www-form-urlencoded', collectValues, [])
            .option('--data-binary <string>', 'Data sent as-is', null)
            .option('-F, --form <name=content>', 'A single form-data field', collectValues, [])
            .option('-G, --get', 'Forces the request to be sent as GET, with the --data parameters appended to the query string', null)
            .option('-H, --header <string>', 'Add a header (can be used multiple times)', collectValues, [])
            .option('-X, --request <string>', 'Specify a custom request mehod to be used', null)
            .option('--url <string>', 'An alternate way to specify the URL', null);
    },

    trimQuotesFromString: function(str) {
        if(str === null) return null;
        var strlen = str.length;
        if((str[0]==='"' && str[strlen-1]==='"') || (str[0]==="'" && str[strlen-1]==="'"))  {
        	return str.substring(1,strlen-1);
        }
        return str;
    },

    validateCurlRequest: function(curlObj) {
        //must be a valid method
        var validMethods = ["GET","POST","PUT","PATCH","DELETE","COPY","HEAD","OPTIONS","LINK","UNLINK","PURGE","LOCK","UNLOCK","PROPFIND"];
        if(validMethods.indexOf(curlObj.request.toUpperCase())===-1) {
            throw "The method "+ curlObj.request + " is not supported";
        }

        //must have a URL
        if(curlObj.args.length!==1 && !curlObj.url) {
            throw (curlObj.args.length + " option-less arguments found. Only one is supported (the URL)");
        }
    },

    getHeaders: function(curlObj) {
        var headerArray = curlObj.header;
        var str="";
        if(curlObj["userAgent"]) {
        	str += "User-Agent: "+this.trimQuotesFromString(curlObj["userAgent"]);+"\\n";
        	this.headerPairs["User-Agent"]=this.trimQuotesFromString(curlObj["userAgent"]);
        }
        if(headerArray==null || headerArray.length==0) {
            return str;
        }
        var numHeaders = headerArray.length;
        for(var i=0;i<numHeaders;i++) {
            var thisHeader = headerArray[i];

            //remove leading and trailing quotes
            thisHeader = this.trimQuotesFromString(thisHeader);

            var keyIndex = thisHeader.indexOf(":");
            this.headerPairs[thisHeader.substring(0,keyIndex).trim()]=thisHeader.substring(keyIndex+1, thisHeader.length).trim();
            if(keyIndex===-1) {
                continue;
            }

            str += thisHeader+"\\n";
        }
        return str;
    },

    setDefaultPostmanFields: function(request, curlstring) {
        request.collectionId = "";
        request.description = 'Generated from a curl request: \n' +  curlstring.split('"').join('\\\"');
        request.descriptionFormat = "html";
        request.preRequestScript="";
        request.tests="";
        request.synced=false;
        request.pathVariables={};
        request.version = 2;
    },

    resetProgram: function() {
        program["user-agent"] = null;
        program["data"] = [];
        program["dataBinary"] = null;
        program["dataAscii"] = [];
        program["dataUrlencode"] = [];
        program["form"] = [];
        delete program["get"];
        program["header"] = [];
        program["request"] = null;
        program["url"] = null;
        this.requestUrl = "";
    },

    getDataForForm: function(dataArray, toDecodeUri) {
        var numElems = dataArray.length;
        var retVal = [];
        for(var i=0;i<numElems;i++) {
            var thisElem = dataArray[i];
            if(dataArray[i]==="") continue;

            thisElem = this.trimQuotesFromString(thisElem);

            var equalIndex = thisElem.indexOf("=");
           	var key="";
            var val="";
            if(equalIndex===-1) {
                key = thisElem;
                val = "";
            }
            else {
            	key = thisElem.substring(0,equalIndex);
            	val = thisElem.substring(equalIndex+1, thisElem.length);
            }

            if(toDecodeUri) {
                key = decodeURIComponent(key);
                val = decodeURIComponent(val);
            }

            retVal.push({
                key: key,
                value: val,
                type: "text",
                enabled: true
            });
        }

        return retVal;
    },

    getDataForUrlEncoded: function(dataArray, enableDecoding) {
        var concatString = dataArray.join("&").trim();
        if(concatString === null) return null;

        dataArray = this.trimQuotesFromString(concatString).split("&");
        return this.getDataForForm(dataArray, enableDecoding);
    },

    getLowerCaseHeader: function(hk, rHeaders) {
        for(var hKey in rHeaders) {
            if(rHeaders.hasOwnProperty(hKey)) {
                if(hKey.toLowerCase()===hk.toLowerCase()) {
                    return rHeaders[hKey];
                }
            }
        }
        return "";
    },

    convertArrayToAmpersandString: function(arr) {
    	if(arr instanceof Array) {
    		return arr.join("&");
		}
		else {
			return "";
		}
    },

    trySetDefaultBodyMethod: function(request) {
        //if the request method is GET
        if(this.methodsWithBody.indexOf(request.method.toUpperCase()) === -1) {
            request.method = "POST";
        }
    },

    convertCurlToRequest: function(curlString) {
        try {
            if(this.loaded===false) {
                this.initialize();
                this.loaded=true;
            }

            this.resetProgram();

            var argv = shellQuote.parse("node " + curlString);
            var sanitizedArgs = _.map(_.filter(argv, function(arg) { return !_.isEmpty(arg) }), function (arg) {
              if (_.isObject(arg) && arg.op === 'glob') {
                return arg.pattern
              }
              else {
                return arg
              }
            })
            var curlObj = program.parse(sanitizedArgs);

            this.headerPairs = {};

            if(!curlObj.request) {
            	curlObj.request = "GET";
            }

            curlObj.request = this.trimQuotesFromString(curlObj.request);

            this.validateCurlRequest(curlObj);

            if(curlObj.args.length == 0) {
                this.requestUrl = curlObj.url;
            }
            else {
                this.requestUrl = curlObj.args[0];
            }

            var request = {};

            request.method= 'GET';//curlObj.request;
            if(curlObj.request && curlObj.request.length!==0) {
                request.method = curlObj.request;
            }

            request.url = request.name = this.trimQuotesFromString(this.requestUrl);

            request.headers = this.getHeaders(curlObj);
            request.time = (new Date()).getTime();
            request.id = request.collectionRequestId = uuidv4();

            var content_type = this.getLowerCaseHeader("content-type", this.headerPairs);
            var urlData = "";

            request.data = [];

            request.dataMode = "params";


            if(curlObj["dataBinary"]!==null) {
                request.dataMode="raw";
                request.data = request.rawModeData = curlObj["dataBinary"];
                urlData = request.rawModeData;
                this.trySetDefaultBodyMethod(request);
            }
            if(curlObj.form && curlObj.form.length!==0) {
                request.data = request.data.concat(this.getDataForForm(curlObj.form, false));
                request.dataMode = "params";
                this.trySetDefaultBodyMethod(request);
            }
            if((curlObj.data && curlObj.data.length!==0) || (curlObj.dataAscii && curlObj.dataAscii.length!==0)) {
            	if(content_type==="" || content_type === "application/x-www-form-urlencoded") {
            		//No content-type set
            		//set to urlencoded
            		request.data = request.data.concat(this.getDataForUrlEncoded(curlObj.data, false)).concat(this.getDataForUrlEncoded(curlObj.dataAscii, false));
            		request.dataMode = "urlencoded";
                	this.trySetDefaultBodyMethod(request);
                    var str1 = this.convertArrayToAmpersandString(curlObj.data),
                        str2 = this.convertArrayToAmpersandString(curlObj.dataAscii);
                	urlData = str1
                        + ((str1.length>0 && str2.length>0)?"&":"")
                        + str2;

            	}
                else {
                	var dataString = this.convertArrayToAmpersandString(curlObj.data);
                	var dataAsciiString = this.convertArrayToAmpersandString(curlObj.dataAscii);
                    var str1 = this.trimQuotesFromString(dataString),
                        str2 = this.trimQuotesFromString(dataAsciiString);

                    request.data =  str1
                        + ((str1.length>0 && str2.length>0)?"&":"")
                        + str2;
                    request.dataMode = "raw";
                    this.trySetDefaultBodyMethod(request);
                    urlData = request.data;
                }
            }
            if(curlObj['dataUrlencode'] && curlObj['dataUrlencode'].length!==0) {
                request.data = request.data.concat(this.getDataForUrlEncoded(curlObj['dataUrlencode'], true));
                request.dataMode = "urlencoded";
                this.trySetDefaultBodyMethod(request);
                urlData = curlObj['dataUrlencode'];
            }

            if(!!curlObj.get) {
                request.method="GET";
                if(request.method.toLowerCase()==="get" && urlData!=="") {
                	request.url+="?" + urlData;
                }
            }

            request.id = request.collectionRequestId = uuidv4();

            this.setDefaultPostmanFields(request, curlString);
            return request;
        }
        catch(e) {
            if(e.message === "process.exit is not a function") {
                //happened because of
                e.message = "Invalid format for cURL."
            }
            return {error:e};
        }
    }
};

module.exports = curlConverter;


/***/ }),

/***/ 3571:
/***/ (function(module, exports, __webpack_require__) {

var json = typeof JSON !== undefined ? JSON : __webpack_require__(3572);
var map = __webpack_require__(3575);
var filter = __webpack_require__(3576);
var reduce = __webpack_require__(3577);

exports.quote = function (xs) {
    return map(xs, function (s) {
        if (s && typeof s === 'object') {
            return s.op.replace(/(.)/g, '\\$1');
        }
        else if (/["\s]/.test(s) && !/'/.test(s)) {
            return "'" + s.replace(/(['\\])/g, '\\$1') + "'";
        }
        else if (/["'\s]/.test(s)) {
            return '"' + s.replace(/(["\\$`!])/g, '\\$1') + '"';
        }
        else {
            return String(s).replace(/([#!"$&'()*,:;<=>?@\[\\\]^`{|}])/g, '\\$1'); 
        }
    }).join(' ');
};

var CONTROL = '(?:' + [
    '\\|\\|', '\\&\\&', ';;', '\\|\\&', '[&;()|<>]'
].join('|') + ')';
var META = '|&;()<> \\t';
var BAREWORD = '(\\\\[\'"' + META + ']|[^\\s\'"' + META + '])+';
var SINGLE_QUOTE = '"((\\\\"|[^"])*?)"';
var DOUBLE_QUOTE = '\'((\\\\\'|[^\'])*?)\'';

var TOKEN = '';
for (var i = 0; i < 4; i++) {
    TOKEN += (Math.pow(16,8)*Math.random()).toString(16);
}

exports.parse = function (s, env, opts) {
    var mapped = parse(s, env, opts);
    if (typeof env !== 'function') return mapped;
    return reduce(mapped, function (acc, s) {
        if (typeof s === 'object') return acc.concat(s);
        var xs = s.split(RegExp('(' + TOKEN + '.*?' + TOKEN + ')', 'g'));
        if (xs.length === 1) return acc.concat(xs[0]);
        return acc.concat(map(filter(xs, Boolean), function (x) {
            if (RegExp('^' + TOKEN).test(x)) {
                return json.parse(x.split(TOKEN)[1]);
            }
            else return x;
        }));
    }, []);
};

function parse (s, env, opts) {
    var chunker = new RegExp([
        '(' + CONTROL + ')', // control chars
        '(' + BAREWORD + '|' + SINGLE_QUOTE + '|' + DOUBLE_QUOTE + ')*'
    ].join('|'), 'g');
    var match = filter(s.match(chunker), Boolean);
    var commented = false;

    if (!match) return [];
    if (!env) env = {};
    if (!opts) opts = {};
    return map(match, function (s, j) {
        if (commented) {
            return;
        }
        if (RegExp('^' + CONTROL + '$').test(s)) {
            return { op: s };
        }

        // Hand-written scanner/parser for Bash quoting rules:
        //
        //  1. inside single quotes, all characters are printed literally.
        //  2. inside double quotes, all characters are printed literally
        //     except variables prefixed by '$' and backslashes followed by
        //     either a double quote or another backslash.
        //  3. outside of any quotes, backslashes are treated as escape
        //     characters and not printed (unless they are themselves escaped)
        //  4. quote context can switch mid-token if there is no whitespace
        //     between the two quote contexts (e.g. all'one'"token" parses as
        //     "allonetoken")
        var SQ = "'";
        var DQ = '"';
        var DS = '$';
        var BS = opts.escape || '\\';
        var quote = false;
        var esc = false;
        var out = '';
        var isGlob = false;

        for (var i = 0, len = s.length; i < len; i++) {
            var c = s.charAt(i);
            isGlob = isGlob || (!quote && (c === '*' || c === '?'));
            if (esc) {
                out += c;
                esc = false;
            }
            else if (quote) {
                if (c === quote) {
                    quote = false;
                }
                else if (quote == SQ) {
                    out += c;
                }
                else { // Double quote
                    if (c === BS) {
                        i += 1;
                        c = s.charAt(i);
                        if (c === DQ || c === BS || c === DS) {
                            out += c;
                        } else {
                            out += BS + c;
                        }
                    }
                    else if (c === DS) {
                        out += parseEnvVar();
                    }
                    else {
                        out += c;
                    }
                }
            }
            else if (c === DQ || c === SQ) {
                quote = c;
            }
            else if (RegExp('^' + CONTROL + '$').test(c)) {
                return { op: s };
            }
            else if (RegExp('^#$').test(c)) {
                commented = true;
                if (out.length){
                    return [out, { comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
                }
                return [{ comment: s.slice(i+1) + match.slice(j+1).join(' ') }];
            }
            else if (c === BS) {
                esc = true;
            }
            else if (c === DS) {
                out += parseEnvVar();
            }
            else out += c;
        }

        if (isGlob) return {op: 'glob', pattern: out};

        return out;

        function parseEnvVar() {
            i += 1;
            var varend, varname;
            //debugger
            if (s.charAt(i) === '{') {
                i += 1;
                if (s.charAt(i) === '}') {
                    throw new Error("Bad substitution: " + s.substr(i - 2, 3));
                }
                varend = s.indexOf('}', i);
                if (varend < 0) {
                    throw new Error("Bad substitution: " + s.substr(i));
                }
                varname = s.substr(i, varend - i);
                i = varend;
            }
            else if (/[*@#?$!_\-]/.test(s.charAt(i))) {
                varname = s.charAt(i);
                i += 1;
            }
            else {
                varend = s.substr(i).match(/[^\w\d_]/);
                if (!varend) {
                    varname = s.substr(i);
                    i = s.length;
                } else {
                    varname = s.substr(i, varend.index);
                    i += varend.index - 1;
                }
            }
            return getVar(null, '', varname);
        }
    })
    // finalize parsed aruments
    .reduce(function(prev, arg){
        if (arg === undefined){
            return prev;
        }
        return prev.concat(arg);
    },[]);

    function getVar (_, pre, key) {
        var r = typeof env === 'function' ? env(key) : env[key];
        if (r === undefined) r = '';

        if (typeof r === 'object') {
            return pre + TOKEN + json.stringify(r) + TOKEN;
        }
        else return pre + r;
    }
}


/***/ }),

/***/ 3572:
/***/ (function(module, exports, __webpack_require__) {

exports.parse = __webpack_require__(3573);
exports.stringify = __webpack_require__(3574);


/***/ }),

/***/ 3573:
/***/ (function(module, exports) {

var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};


/***/ }),

/***/ 3574:
/***/ (function(module, exports) {

var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};


/***/ }),

/***/ 3575:
/***/ (function(module, exports) {

module.exports = function (xs, f) {
    if (xs.map) return xs.map(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = xs[i];
        if (hasOwn.call(xs, i)) res.push(f(x, i, xs));
    }
    return res;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ 3576:
/***/ (function(module, exports) {

/**
 * Array#filter.
 *
 * @param {Array} arr
 * @param {Function} fn
 * @return {Array}
 */

module.exports = function (arr, fn) {
  if (arr.filter) return arr.filter(fn);
  var ret = [];
  for (var i = 0; i < arr.length; i++) {
    if (!hasOwn.call(arr, i)) continue;
    if (fn(arr[i], i, arr)) ret.push(arr[i]);
  }
  return ret;
};

var hasOwn = Object.prototype.hasOwnProperty;


/***/ }),

/***/ 3577:
/***/ (function(module, exports) {

var hasOwn = Object.prototype.hasOwnProperty;

module.exports = function (xs, f, acc) {
    var hasAcc = arguments.length >= 3;
    if (hasAcc && xs.reduce) return xs.reduce(f, acc);
    if (xs.reduce) return xs.reduce(f);
    
    for (var i = 0; i < xs.length; i++) {
        if (!hasOwn.call(xs, i)) continue;
        if (!hasAcc) {
            acc = xs[i];
            hasAcc = true;
            continue;
        }
        acc = f(acc, xs[i], i);
    }
    return acc;
};


/***/ }),

/***/ 3578:
/***/ (function(module, exports, __webpack_require__) {

var fs = __webpack_require__(28);
var uuidv4 = __webpack_require__(45);
var path = __webpack_require__(16);
var xml2js = __webpack_require__(3579);

var converter = {
	getDefaultOptions: function(options) {
		if(!options) options = {};
		if(options.group == null) options.group = true;
		if(options.outputFile == null) options.outputFile = false;
		if(options.pretty == null) options.pretty = true;
		return options;
	},

	convertXMLString: function(xmlString, options, callback, callbackError) {
		this.folders = [];
		options = this.getDefaultOptions(options);
		xml2js.parseString(xmlString, function(err, result) {
			if(err) {
				callbackError("Error converting xml. Please check validity");
				return;
			}
			//result is a JSON object
			converter.processObject(result, options, callback, callbackError);
		});
	},

	saveGlobalMethods: function(app) {
		var methods = app.method || [];
		this.globalMethods = {};
		for(var i=0;i<methods.length;i++) {
			this.globalMethods['#'+methods[i].$.id] = methods[i];
		}
	},

	saveGlobalParams: function(app) {
		var params = app.param || [];
		this.globalParams = {};
		for(var i=0;i<params.length;i++) {
			this.globalParams['#'+params[i].$.id] = params[i];
		}
	},

	addRequestIdToFolderOrder: function(requestId, folderId) {
		if(folderId==null) return;

		var numFolders = this.folders.length;
		for(var i=0;i<numFolders;i++) {
			if(this.folders[i].id===folderId) {
				this.folders[i].order.push(requestId);
				return;
			}
		}
	},

	processResource: function(baseUrl, postmanCollection, resource, options, currentTime, rootResource, parentFolder) {
		var resourcePath = resource.$.path;
		var methods = resource.method || [];
		var numMethods = methods.length;
		var resourceParams = resource.param || [];
		var thisFolder;

		var smartFolder = options.smartGroup;
		//Methods at this URL
		if(options.group && rootResource) {
			thisFolder = {
				'id': uuidv4(),
				'name': resourcePath,
				'description': resourcePath,
				'order': [],
				'collection_name': postmanCollection.name,
				'collection_id': postmanCollection.id
			};
			parentFolder = thisFolder.id;
			this.folders.push(thisFolder);
		}

		var j;
		for(j=0;j<numMethods;j++) {
			if(methods[j].$.hasOwnProperty("href")) {
				methods[j] = this.globalMethods[methods[j].$.href];
			}
			var sep = (baseUrl[baseUrl.length-1]=="/" || resourcePath[0]=="/")?"":"/";
			var thisRequest = this.getRequestFromMethod(baseUrl + sep + resourcePath, methods[j], postmanCollection.id, currentTime, resourceParams);
			if(options.group) {
				this.addRequestIdToFolderOrder(thisRequest.id, parentFolder);
			}
			else {
				postmanCollection.order.push(thisRequest.id);
			}
			postmanCollection.requests.push(thisRequest);
		}

		//NESTED resources
		var childResources = resource.resource || [];
		var numChildren = childResources.length;
		for(var k=0;k<numChildren;k++) {
			var sep = (baseUrl[baseUrl.length-1]=="/" || resourcePath[0]=="/")?"":"/";
			this.processResource(baseUrl + sep + resourcePath, postmanCollection,childResources[k], options, currentTime, false, parentFolder);
		}
	},

	addFoldersToCollection: function(collection) {
		var numFolders = this.folders.length;
		for(var i=0;i<numFolders;i++) {
			if(this.folders[i].order.length!==0)
				collection.folders.push(this.folders[i]);
		}
	},


	processObject: function (wadlObject, options, callback, callbackError) {
		try {
			var api = wadlObject.application.resources[0];
			var baseUrl = api.$.base;
			var postmanCollection = {};
			var currentTime = (new Date()).getTime();
			this.initializeCollection(postmanCollection, currentTime);
			this.saveGlobalMethods(wadlObject.application);
			this.saveGlobalParams(wadlObject.application);

			var postmanRequests = [];
			var resources = api.resource;
			var numResources = resources.length;

			for(var i=0;i<numResources;i++) {
				this.processResource(baseUrl, postmanCollection, resources[i], options, currentTime, true, null);
			}

			this.addFoldersToCollection(postmanCollection);

			if(typeof callback == 'function') {
				callback(postmanCollection);
				return;
			}


			var indent = 0;
			if(options.pretty) {
				indent = 2;
			}
			if(options.outputFile) {
				fs.writeFileSync(options.outputFile, JSON.stringify(postmanCollection, null, indent));
				return;
			}
			else {
				console.log(JSON.stringify(postmanCollection, null, indent));
				return;
			}
		}
		catch(e) {
			callbackError(e);
		}
	},

	initializeCollection: function(collectionObj, timestamp) {
		collectionObj.id = uuidv4();
		collectionObj.name = "Converted from WADL";
		collectionObj.desctiption = "Converted from WADL";
		collectionObj.order = [];
		collectionObj.folders = [];
		collectionObj.synced=false;
		collectionObj.timestamp = timestamp;
		collectionObj.requests = [];
	},

	getRequestFromMethod: function(path, method, collectionId, timestamp, parentParams) {
		var request = {};
		request.id = uuidv4();
		request.url = request.name = path;

		request.url = request.url.replace(/\{([a-zA-Z0-9\_\-\.]*)\}/g,"\:$1"); //replace {a} with :a (as a path variable)

		request.preRequestScript = request.tests = "";
		request.synced = false;
		request.collectionId = collectionId;
		request.version = 2;
		request.time = timestamp;
		request.descriptionFormat = "html";

		request.method = method.$.name;

		var methodData = (method.request)?method.request[0]:{};
		var methodParams = methodData.param || [];
		var params = parentParams.concat(methodParams);
		var numParams = params.length;

		var requestData = [];
		var headerString = "";
		var urlParams = "?";
		var pathVariables = {};
		var dataMode = "params";

		for(var i=0;i<numParams;i++) {
			if(params[i].$.hasOwnProperty("href")) {
				params[i] = this.globalParams[params[i].$.href];
			}
			var name = params[i].$.name;
			var style = params[i].$.style; //query/header/raw/form :s
			var defaultVal = params[i].$.default;
			if(defaultVal == null) defaultVal = "";

			if(style==="header") {
				headerString += name+":"+defaultVal+"\n";
			}
			else if(style==="query") {
				if(request.method.toUpperCase()==="POST" || request.method.toUpperCase()==="PUT") {
					requestData.push({
						'key': name,
						'type': 'text',
						'value': defaultVal
					});
					dataMode = "params";
				}
				else {
					urlParams+=name+"="+defaultVal+"&";
				}
			}
			else if(style==="template") {
				//path variable
				pathVariables[name] = defaultVal;
			}
			else {
				//error
				console.log("This param style is not supported");
			}
		}

		request.headers = headerString;
		request.data = requestData;
		request.pathVariables = pathVariables;
		request.url += urlParams;
		request.dataMode = dataMode;

		return request;
	}

};

module.exports = converter;

/***/ }),

/***/ 3579:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, parser, processors,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  defaults = __webpack_require__(3459);

  builder = __webpack_require__(3580);

  parser = __webpack_require__(3585);

  processors = __webpack_require__(3483);

  exports.defaults = defaults.defaults;

  exports.processors = processors;

  exports.ValidationError = (function(superClass) {
    extend(ValidationError, superClass);

    function ValidationError(message) {
      this.message = message;
    }

    return ValidationError;

  })(Error);

  exports.Builder = builder.Builder;

  exports.Parser = parser.Parser;

  exports.parseString = parser.parseString;

}).call(this);


/***/ }),

/***/ 3580:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var builder, defaults, escapeCDATA, requiresCDATA, wrapCDATA,
    hasProp = {}.hasOwnProperty;

  builder = __webpack_require__(3581);

  defaults = __webpack_require__(3459).defaults;

  requiresCDATA = function(entry) {
    return typeof entry === "string" && (entry.indexOf('&') >= 0 || entry.indexOf('>') >= 0 || entry.indexOf('<') >= 0);
  };

  wrapCDATA = function(entry) {
    return "<![CDATA[" + (escapeCDATA(entry)) + "]]>";
  };

  escapeCDATA = function(entry) {
    return entry.replace(']]>', ']]]]><![CDATA[>');
  };

  exports.Builder = (function() {
    function Builder(opts) {
      var key, ref, value;
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
    }

    Builder.prototype.buildObject = function(rootObj) {
      var attrkey, charkey, render, rootElement, rootName;
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      if ((Object.keys(rootObj).length === 1) && (this.options.rootName === defaults['0.2'].rootName)) {
        rootName = Object.keys(rootObj)[0];
        rootObj = rootObj[rootName];
      } else {
        rootName = this.options.rootName;
      }
      render = (function(_this) {
        return function(element, obj) {
          var attr, child, entry, index, key, value;
          if (typeof obj !== 'object') {
            if (_this.options.cdata && requiresCDATA(obj)) {
              element.raw(wrapCDATA(obj));
            } else {
              element.txt(obj);
            }
          } else if (Array.isArray(obj)) {
            for (index in obj) {
              if (!hasProp.call(obj, index)) continue;
              child = obj[index];
              for (key in child) {
                entry = child[key];
                element = render(element.ele(key), entry).up();
              }
            }
          } else {
            for (key in obj) {
              if (!hasProp.call(obj, key)) continue;
              child = obj[key];
              if (key === attrkey) {
                if (typeof child === "object") {
                  for (attr in child) {
                    value = child[attr];
                    element = element.att(attr, value);
                  }
                }
              } else if (key === charkey) {
                if (_this.options.cdata && requiresCDATA(child)) {
                  element = element.raw(wrapCDATA(child));
                } else {
                  element = element.txt(child);
                }
              } else if (Array.isArray(child)) {
                for (index in child) {
                  if (!hasProp.call(child, index)) continue;
                  entry = child[index];
                  if (typeof entry === 'string') {
                    if (_this.options.cdata && requiresCDATA(entry)) {
                      element = element.ele(key).raw(wrapCDATA(entry)).up();
                    } else {
                      element = element.ele(key, entry).up();
                    }
                  } else {
                    element = render(element.ele(key), entry).up();
                  }
                }
              } else if (typeof child === "object") {
                element = render(element.ele(key), child).up();
              } else {
                if (typeof child === 'string' && _this.options.cdata && requiresCDATA(child)) {
                  element = element.ele(key).raw(wrapCDATA(child)).up();
                } else {
                  if (child == null) {
                    child = '';
                  }
                  element = element.ele(key, child.toString()).up();
                }
              }
            }
          }
          return element;
        };
      })(this);
      rootElement = builder.create(rootName, this.options.xmldec, this.options.doctype, {
        headless: this.options.headless,
        allowSurrogateChars: this.options.allowSurrogateChars
      });
      return render(rootElement, rootObj).end(this.options.renderOpts);
    };

    return Builder;

  })();

}).call(this);


/***/ }),

/***/ 3581:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction, ref;

  ref = __webpack_require__(3410), assign = ref.assign, isFunction = ref.isFunction;

  XMLDocument = __webpack_require__(3582);

  XMLDocumentCB = __webpack_require__(3583);

  XMLStringWriter = __webpack_require__(3460);

  XMLStreamWriter = __webpack_require__(3584);

  module.exports.create = function(name, xmldec, doctype, options) {
    var doc, root;
    if (name == null) {
      throw new Error("Root element needs a name");
    }
    options = assign({}, xmldec, doctype, options);
    doc = new XMLDocument(options);
    root = doc.element(name);
    if (!options.headless) {
      doc.declaration(options);
      if ((options.pubID != null) || (options.sysID != null)) {
        doc.doctype(options);
      }
    }
    return root;
  };

  module.exports.begin = function(options, onData, onEnd) {
    var ref1;
    if (isFunction(options)) {
      ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
      options = {};
    }
    if (onData) {
      return new XMLDocumentCB(options, onData, onEnd);
    } else {
      return new XMLDocument(options);
    }
  };

  module.exports.stringWriter = function(options) {
    return new XMLStringWriter(options);
  };

  module.exports.streamWriter = function(stream, options) {
    return new XMLStreamWriter(stream, options);
  };

}).call(this);


/***/ }),

/***/ 3582:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  isPlainObject = __webpack_require__(3410).isPlainObject;

  XMLNode = __webpack_require__(3406);

  XMLStringifier = __webpack_require__(3481);

  XMLStringWriter = __webpack_require__(3460);

  module.exports = XMLDocument = (function(superClass) {
    extend(XMLDocument, superClass);

    function XMLDocument(options) {
      XMLDocument.__super__.constructor.call(this, null);
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter();
      }
      this.options = options;
      this.stringify = new XMLStringifier(options);
      this.isDocument = true;
    }

    XMLDocument.prototype.end = function(writer) {
      var writerOptions;
      if (!writer) {
        writer = this.options.writer;
      } else if (isPlainObject(writer)) {
        writerOptions = writer;
        writer = this.options.writer.set(writerOptions);
      }
      return writer.document(this);
    };

    XMLDocument.prototype.toString = function(options) {
      return this.options.writer.set(options).document(this);
    };

    return XMLDocument;

  })(XMLNode);

}).call(this);


/***/ }),

/***/ 3583:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, isFunction, isObject, isPlainObject, ref,
    hasProp = {}.hasOwnProperty;

  ref = __webpack_require__(3410), isObject = ref.isObject, isFunction = ref.isFunction, isPlainObject = ref.isPlainObject;

  XMLElement = __webpack_require__(3431);

  XMLCData = __webpack_require__(3432);

  XMLComment = __webpack_require__(3433);

  XMLRaw = __webpack_require__(3440);

  XMLText = __webpack_require__(3441);

  XMLProcessingInstruction = __webpack_require__(3442);

  XMLDeclaration = __webpack_require__(3434);

  XMLDocType = __webpack_require__(3435);

  XMLDTDAttList = __webpack_require__(3436);

  XMLDTDEntity = __webpack_require__(3437);

  XMLDTDElement = __webpack_require__(3438);

  XMLDTDNotation = __webpack_require__(3439);

  XMLAttribute = __webpack_require__(3480);

  XMLStringifier = __webpack_require__(3481);

  XMLStringWriter = __webpack_require__(3460);

  module.exports = XMLDocumentCB = (function() {
    function XMLDocumentCB(options, onData, onEnd) {
      var writerOptions;
      options || (options = {});
      if (!options.writer) {
        options.writer = new XMLStringWriter(options);
      } else if (isPlainObject(options.writer)) {
        writerOptions = options.writer;
        options.writer = new XMLStringWriter(writerOptions);
      }
      this.options = options;
      this.writer = options.writer;
      this.stringify = new XMLStringifier(options);
      this.onDataCallback = onData || function() {};
      this.onEndCallback = onEnd || function() {};
      this.currentNode = null;
      this.currentLevel = -1;
      this.openTags = {};
      this.documentStarted = false;
      this.documentCompleted = false;
      this.root = null;
    }

    XMLDocumentCB.prototype.node = function(name, attributes, text) {
      var ref1;
      if (name == null) {
        throw new Error("Missing node name");
      }
      if (this.root && this.currentLevel === -1) {
        throw new Error("Document can only have one root node");
      }
      this.openCurrent();
      name = name.valueOf();
      if (attributes == null) {
        attributes = {};
      }
      attributes = attributes.valueOf();
      if (!isObject(attributes)) {
        ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
      }
      this.currentNode = new XMLElement(this, name, attributes);
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      if (text != null) {
        this.text(text);
      }
      return this;
    };

    XMLDocumentCB.prototype.element = function(name, attributes, text) {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.dtdElement.apply(this, arguments);
      } else {
        return this.node(name, attributes, text);
      }
    };

    XMLDocumentCB.prototype.attribute = function(name, value) {
      var attName, attValue;
      if (!this.currentNode || this.currentNode.children) {
        throw new Error("att() can only be used immediately after an ele() call in callback mode");
      }
      if (name != null) {
        name = name.valueOf();
      }
      if (isObject(name)) {
        for (attName in name) {
          if (!hasProp.call(name, attName)) continue;
          attValue = name[attName];
          this.attribute(attName, attValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        if (!this.options.skipNullAttributes || (value != null)) {
          this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
        }
      }
      return this;
    };

    XMLDocumentCB.prototype.text = function(value) {
      var node;
      this.openCurrent();
      node = new XMLText(this, value);
      this.onData(this.writer.text(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.cdata = function(value) {
      var node;
      this.openCurrent();
      node = new XMLCData(this, value);
      this.onData(this.writer.cdata(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.comment = function(value) {
      var node;
      this.openCurrent();
      node = new XMLComment(this, value);
      this.onData(this.writer.comment(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.raw = function(value) {
      var node;
      this.openCurrent();
      node = new XMLRaw(this, value);
      this.onData(this.writer.raw(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.instruction = function(target, value) {
      var i, insTarget, insValue, len, node;
      this.openCurrent();
      if (target != null) {
        target = target.valueOf();
      }
      if (value != null) {
        value = value.valueOf();
      }
      if (Array.isArray(target)) {
        for (i = 0, len = target.length; i < len; i++) {
          insTarget = target[i];
          this.instruction(insTarget);
        }
      } else if (isObject(target)) {
        for (insTarget in target) {
          if (!hasProp.call(target, insTarget)) continue;
          insValue = target[insTarget];
          this.instruction(insTarget, insValue);
        }
      } else {
        if (isFunction(value)) {
          value = value.apply();
        }
        node = new XMLProcessingInstruction(this, target, value);
        this.onData(this.writer.processingInstruction(node, this.currentLevel + 1));
      }
      return this;
    };

    XMLDocumentCB.prototype.declaration = function(version, encoding, standalone) {
      var node;
      this.openCurrent();
      if (this.documentStarted) {
        throw new Error("declaration() must be the first node");
      }
      node = new XMLDeclaration(this, version, encoding, standalone);
      this.onData(this.writer.declaration(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.doctype = function(root, pubID, sysID) {
      this.openCurrent();
      if (root == null) {
        throw new Error("Missing root node name");
      }
      if (this.root) {
        throw new Error("dtd() must come before the root node");
      }
      this.currentNode = new XMLDocType(this, pubID, sysID);
      this.currentNode.rootNodeName = root;
      this.currentNode.children = false;
      this.currentLevel++;
      this.openTags[this.currentLevel] = this.currentNode;
      return this;
    };

    XMLDocumentCB.prototype.dtdElement = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDElement(this, name, value);
      this.onData(this.writer.dtdElement(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
      var node;
      this.openCurrent();
      node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
      this.onData(this.writer.dtdAttList(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.entity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, false, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.pEntity = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDEntity(this, true, name, value);
      this.onData(this.writer.dtdEntity(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.notation = function(name, value) {
      var node;
      this.openCurrent();
      node = new XMLDTDNotation(this, name, value);
      this.onData(this.writer.dtdNotation(node, this.currentLevel + 1));
      return this;
    };

    XMLDocumentCB.prototype.up = function() {
      if (this.currentLevel < 0) {
        throw new Error("The document node has no parent");
      }
      if (this.currentNode) {
        if (this.currentNode.children) {
          this.closeNode(this.currentNode);
        } else {
          this.openNode(this.currentNode);
        }
        this.currentNode = null;
      } else {
        this.closeNode(this.openTags[this.currentLevel]);
      }
      delete this.openTags[this.currentLevel];
      this.currentLevel--;
      return this;
    };

    XMLDocumentCB.prototype.end = function() {
      while (this.currentLevel >= 0) {
        this.up();
      }
      return this.onEnd();
    };

    XMLDocumentCB.prototype.openCurrent = function() {
      if (this.currentNode) {
        this.currentNode.children = true;
        return this.openNode(this.currentNode);
      }
    };

    XMLDocumentCB.prototype.openNode = function(node) {
      if (!node.isOpen) {
        if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
          this.root = node;
        }
        this.onData(this.writer.openNode(node, this.currentLevel));
        return node.isOpen = true;
      }
    };

    XMLDocumentCB.prototype.closeNode = function(node) {
      if (!node.isClosed) {
        this.onData(this.writer.closeNode(node, this.currentLevel));
        return node.isClosed = true;
      }
    };

    XMLDocumentCB.prototype.onData = function(chunk) {
      this.documentStarted = true;
      return this.onDataCallback(chunk);
    };

    XMLDocumentCB.prototype.onEnd = function() {
      this.documentCompleted = true;
      return this.onEndCallback();
    };

    XMLDocumentCB.prototype.ele = function() {
      return this.element.apply(this, arguments);
    };

    XMLDocumentCB.prototype.nod = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.txt = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.dat = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.com = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.ins = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.dec = function(version, encoding, standalone) {
      return this.declaration(version, encoding, standalone);
    };

    XMLDocumentCB.prototype.dtd = function(root, pubID, sysID) {
      return this.doctype(root, pubID, sysID);
    };

    XMLDocumentCB.prototype.e = function(name, attributes, text) {
      return this.element(name, attributes, text);
    };

    XMLDocumentCB.prototype.n = function(name, attributes, text) {
      return this.node(name, attributes, text);
    };

    XMLDocumentCB.prototype.t = function(value) {
      return this.text(value);
    };

    XMLDocumentCB.prototype.d = function(value) {
      return this.cdata(value);
    };

    XMLDocumentCB.prototype.c = function(value) {
      return this.comment(value);
    };

    XMLDocumentCB.prototype.r = function(value) {
      return this.raw(value);
    };

    XMLDocumentCB.prototype.i = function(target, value) {
      return this.instruction(target, value);
    };

    XMLDocumentCB.prototype.att = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.a = function() {
      if (this.currentNode && this.currentNode instanceof XMLDocType) {
        return this.attList.apply(this, arguments);
      } else {
        return this.attribute.apply(this, arguments);
      }
    };

    XMLDocumentCB.prototype.ent = function(name, value) {
      return this.entity(name, value);
    };

    XMLDocumentCB.prototype.pent = function(name, value) {
      return this.pEntity(name, value);
    };

    XMLDocumentCB.prototype.not = function(name, value) {
      return this.notation(name, value);
    };

    return XMLDocumentCB;

  })();

}).call(this);


/***/ }),

/***/ 3584:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  XMLDeclaration = __webpack_require__(3434);

  XMLDocType = __webpack_require__(3435);

  XMLCData = __webpack_require__(3432);

  XMLComment = __webpack_require__(3433);

  XMLElement = __webpack_require__(3431);

  XMLRaw = __webpack_require__(3440);

  XMLText = __webpack_require__(3441);

  XMLProcessingInstruction = __webpack_require__(3442);

  XMLDTDAttList = __webpack_require__(3436);

  XMLDTDElement = __webpack_require__(3438);

  XMLDTDEntity = __webpack_require__(3437);

  XMLDTDNotation = __webpack_require__(3439);

  XMLWriterBase = __webpack_require__(3482);

  module.exports = XMLStreamWriter = (function(superClass) {
    extend(XMLStreamWriter, superClass);

    function XMLStreamWriter(stream, options) {
      XMLStreamWriter.__super__.constructor.call(this, options);
      this.stream = stream;
    }

    XMLStreamWriter.prototype.document = function(doc) {
      var child, i, j, len, len1, ref, ref1, results;
      ref = doc.children;
      for (i = 0, len = ref.length; i < len; i++) {
        child = ref[i];
        child.isLastRootNode = false;
      }
      doc.children[doc.children.length - 1].isLastRootNode = true;
      ref1 = doc.children;
      results = [];
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        child = ref1[j];
        switch (false) {
          case !(child instanceof XMLDeclaration):
            results.push(this.declaration(child));
            break;
          case !(child instanceof XMLDocType):
            results.push(this.docType(child));
            break;
          case !(child instanceof XMLComment):
            results.push(this.comment(child));
            break;
          case !(child instanceof XMLProcessingInstruction):
            results.push(this.processingInstruction(child));
            break;
          default:
            results.push(this.element(child));
        }
      }
      return results;
    };

    XMLStreamWriter.prototype.attribute = function(att) {
      return this.stream.write(' ' + att.name + '="' + att.value + '"');
    };

    XMLStreamWriter.prototype.cdata = function(node, level) {
      return this.stream.write(this.space(level) + '<![CDATA[' + node.text + ']]>' + this.endline(node));
    };

    XMLStreamWriter.prototype.comment = function(node, level) {
      return this.stream.write(this.space(level) + '<!-- ' + node.text + ' -->' + this.endline(node));
    };

    XMLStreamWriter.prototype.declaration = function(node, level) {
      this.stream.write(this.space(level));
      this.stream.write('<?xml version="' + node.version + '"');
      if (node.encoding != null) {
        this.stream.write(' encoding="' + node.encoding + '"');
      }
      if (node.standalone != null) {
        this.stream.write(' standalone="' + node.standalone + '"');
      }
      this.stream.write(this.spacebeforeslash + '?>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.docType = function(node, level) {
      var child, i, len, ref;
      level || (level = 0);
      this.stream.write(this.space(level));
      this.stream.write('<!DOCTYPE ' + node.root().name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      if (node.children.length > 0) {
        this.stream.write(' [');
        this.stream.write(this.endline(node));
        ref = node.children;
        for (i = 0, len = ref.length; i < len; i++) {
          child = ref[i];
          switch (false) {
            case !(child instanceof XMLDTDAttList):
              this.dtdAttList(child, level + 1);
              break;
            case !(child instanceof XMLDTDElement):
              this.dtdElement(child, level + 1);
              break;
            case !(child instanceof XMLDTDEntity):
              this.dtdEntity(child, level + 1);
              break;
            case !(child instanceof XMLDTDNotation):
              this.dtdNotation(child, level + 1);
              break;
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown DTD node type: " + child.constructor.name);
          }
        }
        this.stream.write(']');
      }
      this.stream.write(this.spacebeforeslash + '>');
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.element = function(node, level) {
      var att, child, i, len, name, ref, ref1, space;
      level || (level = 0);
      space = this.space(level);
      this.stream.write(space + '<' + node.name);
      ref = node.attributes;
      for (name in ref) {
        if (!hasProp.call(ref, name)) continue;
        att = ref[name];
        this.attribute(att);
      }
      if (node.children.length === 0 || node.children.every(function(e) {
        return e.value === '';
      })) {
        if (this.allowEmpty) {
          this.stream.write('></' + node.name + '>');
        } else {
          this.stream.write(this.spacebeforeslash + '/>');
        }
      } else if (this.pretty && node.children.length === 1 && (node.children[0].value != null)) {
        this.stream.write('>');
        this.stream.write(node.children[0].value);
        this.stream.write('</' + node.name + '>');
      } else {
        this.stream.write('>' + this.newline);
        ref1 = node.children;
        for (i = 0, len = ref1.length; i < len; i++) {
          child = ref1[i];
          switch (false) {
            case !(child instanceof XMLCData):
              this.cdata(child, level + 1);
              break;
            case !(child instanceof XMLComment):
              this.comment(child, level + 1);
              break;
            case !(child instanceof XMLElement):
              this.element(child, level + 1);
              break;
            case !(child instanceof XMLRaw):
              this.raw(child, level + 1);
              break;
            case !(child instanceof XMLText):
              this.text(child, level + 1);
              break;
            case !(child instanceof XMLProcessingInstruction):
              this.processingInstruction(child, level + 1);
              break;
            default:
              throw new Error("Unknown XML node type: " + child.constructor.name);
          }
        }
        this.stream.write(space + '</' + node.name + '>');
      }
      return this.stream.write(this.endline(node));
    };

    XMLStreamWriter.prototype.processingInstruction = function(node, level) {
      this.stream.write(this.space(level) + '<?' + node.target);
      if (node.value) {
        this.stream.write(' ' + node.value);
      }
      return this.stream.write(this.spacebeforeslash + '?>' + this.endline(node));
    };

    XMLStreamWriter.prototype.raw = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.text = function(node, level) {
      return this.stream.write(this.space(level) + node.value + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdAttList = function(node, level) {
      this.stream.write(this.space(level) + '<!ATTLIST ' + node.elementName + ' ' + node.attributeName + ' ' + node.attributeType);
      if (node.defaultValueType !== '#DEFAULT') {
        this.stream.write(' ' + node.defaultValueType);
      }
      if (node.defaultValue) {
        this.stream.write(' "' + node.defaultValue + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdElement = function(node, level) {
      this.stream.write(this.space(level) + '<!ELEMENT ' + node.name + ' ' + node.value);
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdEntity = function(node, level) {
      this.stream.write(this.space(level) + '<!ENTITY');
      if (node.pe) {
        this.stream.write(' %');
      }
      this.stream.write(' ' + node.name);
      if (node.value) {
        this.stream.write(' "' + node.value + '"');
      } else {
        if (node.pubID && node.sysID) {
          this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
        } else if (node.sysID) {
          this.stream.write(' SYSTEM "' + node.sysID + '"');
        }
        if (node.nData) {
          this.stream.write(' NDATA ' + node.nData);
        }
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.dtdNotation = function(node, level) {
      this.stream.write(this.space(level) + '<!NOTATION ' + node.name);
      if (node.pubID && node.sysID) {
        this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
      } else if (node.pubID) {
        this.stream.write(' PUBLIC "' + node.pubID + '"');
      } else if (node.sysID) {
        this.stream.write(' SYSTEM "' + node.sysID + '"');
      }
      return this.stream.write(this.spacebeforeslash + '>' + this.endline(node));
    };

    XMLStreamWriter.prototype.endline = function(node) {
      if (!node.isLastRootNode) {
        return this.newline;
      } else {
        return '';
      }
    };

    return XMLStreamWriter;

  })(XMLWriterBase);

}).call(this);


/***/ }),

/***/ 3585:
/***/ (function(module, exports, __webpack_require__) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  var bom, defaults, events, isEmpty, processItem, processors, sax, setImmediate,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  sax = __webpack_require__(3586);

  events = __webpack_require__(38);

  bom = __webpack_require__(3587);

  processors = __webpack_require__(3483);

  setImmediate = __webpack_require__(24).setImmediate;

  defaults = __webpack_require__(3459).defaults;

  isEmpty = function(thing) {
    return typeof thing === "object" && (thing != null) && Object.keys(thing).length === 0;
  };

  processItem = function(processors, item, key) {
    var i, len, process;
    for (i = 0, len = processors.length; i < len; i++) {
      process = processors[i];
      item = process(item, key);
    }
    return item;
  };

  exports.Parser = (function(superClass) {
    extend(Parser, superClass);

    function Parser(opts) {
      this.parseString = bind(this.parseString, this);
      this.reset = bind(this.reset, this);
      this.assignOrPush = bind(this.assignOrPush, this);
      this.processAsync = bind(this.processAsync, this);
      var key, ref, value;
      if (!(this instanceof exports.Parser)) {
        return new exports.Parser(opts);
      }
      this.options = {};
      ref = defaults["0.2"];
      for (key in ref) {
        if (!hasProp.call(ref, key)) continue;
        value = ref[key];
        this.options[key] = value;
      }
      for (key in opts) {
        if (!hasProp.call(opts, key)) continue;
        value = opts[key];
        this.options[key] = value;
      }
      if (this.options.xmlns) {
        this.options.xmlnskey = this.options.attrkey + "ns";
      }
      if (this.options.normalizeTags) {
        if (!this.options.tagNameProcessors) {
          this.options.tagNameProcessors = [];
        }
        this.options.tagNameProcessors.unshift(processors.normalize);
      }
      this.reset();
    }

    Parser.prototype.processAsync = function() {
      var chunk, err;
      try {
        if (this.remaining.length <= this.options.chunkSize) {
          chunk = this.remaining;
          this.remaining = '';
          this.saxParser = this.saxParser.write(chunk);
          return this.saxParser.close();
        } else {
          chunk = this.remaining.substr(0, this.options.chunkSize);
          this.remaining = this.remaining.substr(this.options.chunkSize, this.remaining.length);
          this.saxParser = this.saxParser.write(chunk);
          return setImmediate(this.processAsync);
        }
      } catch (error1) {
        err = error1;
        if (!this.saxParser.errThrown) {
          this.saxParser.errThrown = true;
          return this.emit(err);
        }
      }
    };

    Parser.prototype.assignOrPush = function(obj, key, newValue) {
      if (!(key in obj)) {
        if (!this.options.explicitArray) {
          return obj[key] = newValue;
        } else {
          return obj[key] = [newValue];
        }
      } else {
        if (!(obj[key] instanceof Array)) {
          obj[key] = [obj[key]];
        }
        return obj[key].push(newValue);
      }
    };

    Parser.prototype.reset = function() {
      var attrkey, charkey, ontext, stack;
      this.removeAllListeners();
      this.saxParser = sax.parser(this.options.strict, {
        trim: false,
        normalize: false,
        xmlns: this.options.xmlns
      });
      this.saxParser.errThrown = false;
      this.saxParser.onerror = (function(_this) {
        return function(error) {
          _this.saxParser.resume();
          if (!_this.saxParser.errThrown) {
            _this.saxParser.errThrown = true;
            return _this.emit("error", error);
          }
        };
      })(this);
      this.saxParser.onend = (function(_this) {
        return function() {
          if (!_this.saxParser.ended) {
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      this.saxParser.ended = false;
      this.EXPLICIT_CHARKEY = this.options.explicitCharkey;
      this.resultObject = null;
      stack = [];
      attrkey = this.options.attrkey;
      charkey = this.options.charkey;
      this.saxParser.onopentag = (function(_this) {
        return function(node) {
          var key, newValue, obj, processedKey, ref;
          obj = {};
          obj[charkey] = "";
          if (!_this.options.ignoreAttrs) {
            ref = node.attributes;
            for (key in ref) {
              if (!hasProp.call(ref, key)) continue;
              if (!(attrkey in obj) && !_this.options.mergeAttrs) {
                obj[attrkey] = {};
              }
              newValue = _this.options.attrValueProcessors ? processItem(_this.options.attrValueProcessors, node.attributes[key], key) : node.attributes[key];
              processedKey = _this.options.attrNameProcessors ? processItem(_this.options.attrNameProcessors, key) : key;
              if (_this.options.mergeAttrs) {
                _this.assignOrPush(obj, processedKey, newValue);
              } else {
                obj[attrkey][processedKey] = newValue;
              }
            }
          }
          obj["#name"] = _this.options.tagNameProcessors ? processItem(_this.options.tagNameProcessors, node.name) : node.name;
          if (_this.options.xmlns) {
            obj[_this.options.xmlnskey] = {
              uri: node.uri,
              local: node.local
            };
          }
          return stack.push(obj);
        };
      })(this);
      this.saxParser.onclosetag = (function(_this) {
        return function() {
          var cdata, emptyStr, key, node, nodeName, obj, objClone, old, s, xpath;
          obj = stack.pop();
          nodeName = obj["#name"];
          if (!_this.options.explicitChildren || !_this.options.preserveChildrenOrder) {
            delete obj["#name"];
          }
          if (obj.cdata === true) {
            cdata = obj.cdata;
            delete obj.cdata;
          }
          s = stack[stack.length - 1];
          if (obj[charkey].match(/^\s*$/) && !cdata) {
            emptyStr = obj[charkey];
            delete obj[charkey];
          } else {
            if (_this.options.trim) {
              obj[charkey] = obj[charkey].trim();
            }
            if (_this.options.normalize) {
              obj[charkey] = obj[charkey].replace(/\s{2,}/g, " ").trim();
            }
            obj[charkey] = _this.options.valueProcessors ? processItem(_this.options.valueProcessors, obj[charkey], nodeName) : obj[charkey];
            if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
              obj = obj[charkey];
            }
          }
          if (isEmpty(obj)) {
            obj = _this.options.emptyTag !== '' ? _this.options.emptyTag : emptyStr;
          }
          if (_this.options.validator != null) {
            xpath = "/" + ((function() {
              var i, len, results;
              results = [];
              for (i = 0, len = stack.length; i < len; i++) {
                node = stack[i];
                results.push(node["#name"]);
              }
              return results;
            })()).concat(nodeName).join("/");
            (function() {
              var err;
              try {
                return obj = _this.options.validator(xpath, s && s[nodeName], obj);
              } catch (error1) {
                err = error1;
                return _this.emit("error", err);
              }
            })();
          }
          if (_this.options.explicitChildren && !_this.options.mergeAttrs && typeof obj === 'object') {
            if (!_this.options.preserveChildrenOrder) {
              node = {};
              if (_this.options.attrkey in obj) {
                node[_this.options.attrkey] = obj[_this.options.attrkey];
                delete obj[_this.options.attrkey];
              }
              if (!_this.options.charsAsChildren && _this.options.charkey in obj) {
                node[_this.options.charkey] = obj[_this.options.charkey];
                delete obj[_this.options.charkey];
              }
              if (Object.getOwnPropertyNames(obj).length > 0) {
                node[_this.options.childkey] = obj;
              }
              obj = node;
            } else if (s) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              objClone = {};
              for (key in obj) {
                if (!hasProp.call(obj, key)) continue;
                objClone[key] = obj[key];
              }
              s[_this.options.childkey].push(objClone);
              delete obj["#name"];
              if (Object.keys(obj).length === 1 && charkey in obj && !_this.EXPLICIT_CHARKEY) {
                obj = obj[charkey];
              }
            }
          }
          if (stack.length > 0) {
            return _this.assignOrPush(s, nodeName, obj);
          } else {
            if (_this.options.explicitRoot) {
              old = obj;
              obj = {};
              obj[nodeName] = old;
            }
            _this.resultObject = obj;
            _this.saxParser.ended = true;
            return _this.emit("end", _this.resultObject);
          }
        };
      })(this);
      ontext = (function(_this) {
        return function(text) {
          var charChild, s;
          s = stack[stack.length - 1];
          if (s) {
            s[charkey] += text;
            if (_this.options.explicitChildren && _this.options.preserveChildrenOrder && _this.options.charsAsChildren && (_this.options.includeWhiteChars || text.replace(/\\n/g, '').trim() !== '')) {
              s[_this.options.childkey] = s[_this.options.childkey] || [];
              charChild = {
                '#name': '__text__'
              };
              charChild[charkey] = text;
              if (_this.options.normalize) {
                charChild[charkey] = charChild[charkey].replace(/\s{2,}/g, " ").trim();
              }
              s[_this.options.childkey].push(charChild);
            }
            return s;
          }
        };
      })(this);
      this.saxParser.ontext = ontext;
      return this.saxParser.oncdata = (function(_this) {
        return function(text) {
          var s;
          s = ontext(text);
          if (s) {
            return s.cdata = true;
          }
        };
      })(this);
    };

    Parser.prototype.parseString = function(str, cb) {
      var err;
      if ((cb != null) && typeof cb === "function") {
        this.on("end", function(result) {
          this.reset();
          return cb(null, result);
        });
        this.on("error", function(err) {
          this.reset();
          return cb(err);
        });
      }
      try {
        str = str.toString();
        if (str.trim() === '') {
          this.emit("end", null);
          return true;
        }
        str = bom.stripBOM(str);
        if (this.options.async) {
          this.remaining = str;
          setImmediate(this.processAsync);
          return this.saxParser;
        }
        return this.saxParser.write(str).close();
      } catch (error1) {
        err = error1;
        if (!(this.saxParser.errThrown || this.saxParser.ended)) {
          this.emit('error', err);
          return this.saxParser.errThrown = true;
        } else if (this.saxParser.ended) {
          throw err;
        }
      }
    };

    return Parser;

  })(events.EventEmitter);

  exports.parseString = function(str, a, b) {
    var cb, options, parser;
    if (b != null) {
      if (typeof b === 'function') {
        cb = b;
      }
      if (typeof a === 'object') {
        options = a;
      }
    } else {
      if (typeof a === 'function') {
        cb = a;
      }
      options = {};
    }
    parser = new exports.Parser(options);
    return parser.parseString(str, cb);
  };

}).call(this);


/***/ }),

/***/ 3586:
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = __webpack_require__(196).Stream
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = __webpack_require__(59).StringDecoder
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? this.sax = {} : exports)

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(9).Buffer))

/***/ }),

/***/ 3587:
/***/ (function(module, exports) {

// Generated by CoffeeScript 1.12.7
(function() {
  "use strict";
  exports.stripBOM = function(str) {
    if (str[0] === '\uFEFF') {
      return str.substring(1);
    } else {
      return str;
    }
  };

}).call(this);


/***/ }),

/***/ 3588:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wadl__ = __webpack_require__(3458);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'WADL_NS',

  /**
                  * The type of format, irrespective of version
                  * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                  *
                  * @type {string}
                  */
  type: 'wadl',

  /**
                 * The user-friendly name of the format. Used for success and error messages.
                 *
                 * @type {string}
                 */
  name: 'WADL (namespaced)',

  /**
                              * Determines whether the given data is in WADL (namespaced) format
                              *
                              * @param {string} data - A string containing JSON/YAML/XML/etc.
                              * @returns {boolean} - Returns true if the data appears to be in WADL (namespaced) format
                              */
  isFormat(data) {
    let firstLine = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].firstLine(data);
    let first400Characters = data.substr(0, 400);

    return firstLine.includes('<') && first400Characters.includes('<wadl:application');
  },

  /**
      * Converts the given data from WADL (namespaced) format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    // Remove the "wadl" namespace prefix
    data = data.replace(/wadl\:/g, '');

    // Now that there's no namespace, we can just use the normal WADL converter
    return await __WEBPACK_IMPORTED_MODULE_0__wadl__["a" /* default */].convert(data);
  } });

/***/ }),

/***/ 3589:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__wadl__ = __webpack_require__(3458);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'NS2_NS',

  /**
                 * The type of format, irrespective of version
                 * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
                 *
                 * @type {string}
                 */
  type: 'wadl',

  /**
                 * The user-friendly name of the format. Used for success and error messages.
                 *
                 * @type {string}
                 */
  name: 'WADL (ns2 namespaced)',

  /**
                                  * Determines whether the given data is in WADL (ns2 namespaced) format
                                  *
                                  * @param {string} data - A string containing JSON/YAML/XML/etc.
                                  * @returns {boolean} - Returns true if the data appears to be in WADL (ns2 namespaced) format
                                  */
  isFormat(data) {
    let firstLine = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].firstLine(data);
    let first400Characters = data.substr(0, 400);

    return firstLine.includes('<') && first400Characters.includes('<ns2:application');
  },

  /**
      * Converts the given data from WADL (ns2 namespaced) format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    // Remove the "ns2" namespace prefix
    data = data.replace(/ns2\:/g, '');

    // Now that there's no namespace, we can just use the normal WADL converter
    return await __WEBPACK_IMPORTED_MODULE_0__wadl__["a" /* default */].convert(data);
  } });

/***/ }),

/***/ 3590:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__parse__ = __webpack_require__(644);



/* harmony default export */ __webpack_exports__["a"] = ({
  /**
                  * The unique format ID, used for analytics
                  *
                  * @type {string}
                  */
  id: 'dump',

  /**
               * The type of format, irrespective of version
               * (e.g. "swagger" for both Swagger 1.2 and Swagger 2.0)
               *
               * @type {string}
               */
  type: 'postman_dump',

  /**
                         * The user-friendly name of the format. Used for success and error messages.
                         *
                         * @type {string}
                         */
  name: 'Postman Data Backup',

  /**
                                * Determines whether the given data is in Data Dump format
                                *
                                * @param {string} data - A string containing JSON/YAML/XML/etc.
                                * @returns {boolean} - Returns true if the data appears to be in Data Dump format
                                */
  isFormat(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    return typeof data === 'object' &&
    data.hasOwnProperty('version') &&
    data.hasOwnProperty('collections') &&
    data.hasOwnProperty('environments');
  },

  /**
      * Converts the given data from Data Dump format to native Postman objects
      *
      * @param {string} data - A string containing JSON/YAML/XML/etc.
      *
      * @returns Promise<{ collections: object[], environments: object[] }>
      * Returns each native Postman object that the data was converted to.
      */
  async convert(data) {
    data = __WEBPACK_IMPORTED_MODULE_1__parse__["a" /* default */].asJSON(data);

    // No conversion is necessary. Just clone the existing data
    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.clone(data);
  } });

/***/ }),

/***/ 3591:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {/* harmony export (immutable) */ __webpack_exports__["a"] = importCollectionAndEnvironment;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_postman_collection_transformer__ = __webpack_require__(307);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_postman_collection_transformer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_postman_collection_transformer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_js_yaml__ = __webpack_require__(937);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_js_yaml___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_js_yaml__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__formats__ = __webpack_require__(3457);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__index__ = __webpack_require__(3377);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__modules_services_AnalyticsService__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__utils_util__ = __webpack_require__(20);







/**
                                      * Handles Run in Postman imports.
                                      * Called when a getpostman.com/collection URL / postman:// protocol is clicked on. Can import collection + environment
                                      *
                                      * @param {URL} url - The URL that was used to import a collection / environment or both
                                      */
function importCollectionAndEnvironment(url) {
  __WEBPACK_IMPORTED_MODULE_3__index__["default"].importFileFromUrl(url, (err, data) => {
    if (err) {
      return pm.logger.error(err);
    }

    __WEBPACK_IMPORTED_MODULE_3__index__["default"].checkImportEnvironmentFromUrl(url);
    var urlVars = __WEBPACK_IMPORTED_MODULE_5__utils_util__["a" /* default */].getUrlVars(url),
    referrer = _.find(urlVars, function (v) {return v.key === 'referrer';}),
    referrerValue = referrer ? decodeURIComponent(referrer.value) : '';

    __WEBPACK_IMPORTED_MODULE_4__modules_services_AnalyticsService__["a" /* default */].addEvent('collection', 'create', 'run_button', null, {
      referrer: referrerValue,
      collection_id: data.id,
      collection_link_id: __WEBPACK_IMPORTED_MODULE_5__utils_util__["a" /* default */].getCollectionLinkId(url) });

  });
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ }),

/***/ 3592:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["b"] = importDataAs;
/* harmony export (immutable) */ __webpack_exports__["c"] = stringify;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__formats__ = __webpack_require__(3457);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_util__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__common_utils_collection_tree__ = __webpack_require__(309);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_RequestConstants__ = __webpack_require__(940);






const DEPRECATED_PROPS = [
'currentHelper',
'helperAttributes',
'tests',
'preRequestScript',
'headers',
'pathVariables'],

METHOD_GET = 'GET',
DBP_FLAG = 'protocolProfileBehavior.disableBodyPruning',
ALLOWED_VARIABLE_FIELDS = ['id', 'key', 'value', 'type', 'enabled', 'description'],
NO_BODY_METHODS_SET = new Set(__WEBPACK_IMPORTED_MODULE_4__constants_RequestConstants__["a" /* NO_BODY_METHODS */]),
COLLECTION_META_PROPS = ['owner', 'permissions', 'shared', 'favorite'];

/**
                                                                         * Sanitizes the collection variables that are being imported
                                                                         * It will remove and non-supported properties and also,
                                                                         * make sure that the each variable has `enabled` properties (and not the `disabled` property which the schema supports)
                                                                         * @param {Object} collection
                                                                         */
function _sanitizeCollectionVariables(collection) {
  if (!collection || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(collection.variables)) {
    return;
  }

  collection.variables = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(collection.variables, variable => {
    let enabled = true;

    // While importing, we give more preference to disabled field (unlike while exporting)
    // since in the schema disabled is the valid property
    if (typeof variable.disabled !== 'undefined') {
      enabled = !variable.disabled;
    } else if (typeof variable.enabled !== 'undefined') {
      enabled = Boolean(variable.enabled);
    }

    return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.pick(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.merge({}, variable, { enabled }), ALLOWED_VARIABLE_FIELDS);
  });
}

/**
   * Sanitizes the request body and then the body of all the responses' requestObject
   * @param {Object} request
   */
function _sanitizeRequest(request) {
  // Only continue if `request` is an object
  if (!request || typeof request !== 'object' || Array.isArray(request)) {
    return;
  }

  // Sanitize the data mode
  _sanitizeDataMode(request);

  // Sanitize the request body
  _sanitizeRequestBody(request);

  // Sanitize the request method
  _sanitizeRequestMethod(request);

  if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(request.responses)) {
    return;
  }

  // Sanitize body for each response' requestObject
  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(request.responses, response => {
    if (!response) {
      return;
    }

    _sanitizeDataMode(response.requestObject);
    _sanitizeRequestBody(response.requestObject);
  });
}

/**
   * Sanitizes request.dataMode
   * @param {Object} request
   */
function _sanitizeDataMode(request) {
  // Only continue if `request` is an object
  if (!request || typeof request !== 'object' || Array.isArray(request)) {
    return;
  }

  switch (request.dataMode) {
    case 'raw':
    case 'binary':
      if ((request.dataMode === 'raw' || request.dataMode === 'binary') && __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.has(request, 'rawModeData')) {
        request.data = request.rawModeData;
        delete request.rawModeData;
      }
      break;
    case 'params':
      _sanitizeFormData(request);
      break;
    case 'urlencoded':
      if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(request.data)) {
        request.data = [];
      }
      break;
    default:
      request.dataMode = null;
      request.data = null;
      break;}

}

/**
   * Removes the body from requests where the method does not support it and when the
   * DBP flag is not set. This data can be present for collections being exported from App with
   * version before 6.6
   * @param {Object} request
   */
function _sanitizeRequestBody(request) {
  // Only continue if `request` is an object
  if (!request || typeof request !== 'object' || Array.isArray(request)) {
    return;
  }

  let methodDoesNotAllowBody = !request.method || NO_BODY_METHODS_SET.has(request.method),
  isDbpFalsy = !__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.get(request, DBP_FLAG);

  if (methodDoesNotAllowBody && isDbpFalsy) {
    request.data = null;
    request.dataMode = null;
  }
}

/**
   * It will set method to GET when it is not valid (a non-empty string)
   * Also, it will uppercase them
   * @param {Object} request
   */
function _sanitizeRequestMethod(request) {
  // Only continue if `request` is an object
  if (!request || typeof request !== 'object' || Array.isArray(request)) {
    return;
  }

  // If method is invalid or is empty string, set it to GET
  if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(request.method) || __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(request.method)) {
    request.method = METHOD_GET;
  }

  // otherwise it's a valid string, just uppercase it
  else {
      request.method = request.method.toUpperCase();
    }
}

/**
   * transform params/form-data request
   * @param {any} entity
   */
function _sanitizeFormData(request) {
  if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isArray(request.data)) {
    request.data = [];

    return;
  }

  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(request.data, datum => {
    if (!datum || datum.type !== 'file' || Array.isArray(datum.value)) {
      return;
    }

    // If type is file and value is a string then convert it to an array
    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(datum.value)) {
      datum.value = [datum.value];
      return;
    }

    // Incase of unknown type cleanup to empty array
    datum.value = [];
  });
}

const responseSanitizeRules = {
  id: {
    type: 'string',
    defaultsTo() {
      return __WEBPACK_IMPORTED_MODULE_2__utils_util__["a" /* default */].guid();
    } },

  name: { type: 'string', defaultsTo: 'Untitled Response' },
  status: { type: 'string', defaultsTo: '' },
  mime: { type: 'string', defaultsTo: '' },
  language: { type: 'string', defaultsTo: '' },
  text: { type: 'string', defaultsTo: '' },
  responseCode: { type: 'object', defaultsTo: null },
  requestObject: { type: 'object', defaultsTo: null },
  headers: { type: 'array', defaultsTo: [] },
  cookies: { type: 'array', defaultsTo: [] },
  request: { type: 'string', defaultsTo: '' },
  collection: { type: 'string', defaultsTo: '' },
  createdAt: false, // indicates - remove property
  updatedAt: false // indicates - remove property
};
/* unused harmony export responseSanitizeRules */


/**
    * Imports a Collection, Environment, Request, Globals, etc. in any supported format.
    * (Collection v2, Swagger RAML, etc.)
    *
    * @param {string|object} data - A string containing JSON/YAML/XML/etc, or other type of data
    *
    * @returns {Promise<?object>}
    * Resolves with the Postman objects that were imported, and the format that they were imported from.
    *
    * @fires Mediator#closeImportModal
    */
/* harmony default export */ __webpack_exports__["a"] = (async function convertRawData(data) {
  let format, importedData;

  // Normalize the data to a string, so it can be passed between processes via IPC
  data = stringify(data);

  // Find the format of the data (Swagger, RAML, Collection, etc.)
  format = determineDataFormat(data);

  if (!format) {
    pm.toasts.error('Error while importing: format not recognized');
  } else
  {
    // Import the data from the selected format (Swagger, RAML, Collection, etc.)
    importedData = await importDataAs(data, format);
  }

  let defaults = {
    format: {
      id: '',
      code: '',
      name: '' },

    requests: [],
    collections: [],
    environment: [],
    globals: [],
    headerPresets: [] };


  // Return the imported format and data
  return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.merge(defaults, { format }, importedData);
});

/**
     * Imports the given data as the specified format.
     *
     * @param {object} format - A format object with a `convert` method
     * @param {string} data - A string containing JSON/YAML/XML/etc.
     * @returns {Promise<object>}
     */
async function importDataAs(data, format) {
  try {
    // Convert the data to native Postman objects (Collections, Environments, Globals, etc)
    let nativeObjects = await format.convert(data);

    // Purify collection objects
    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.has(nativeObjects, 'collections')) {
      for (let i = 0; i < nativeObjects.collections.length; i++) {
        nativeObjects.collections[i] = purifyCollectionData(nativeObjects.collections[i]);
      }
    }

    if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.has(nativeObjects, 'requests')) {
      for (let i = 0; i < nativeObjects.requests.length; i++) {
        nativeObjects.requests[i] = purifyRequestData(nativeObjects.requests[i]);
      }
    }

    return nativeObjects;
  }
  catch (error) {
    pm.toasts.error(`Error while importing ${format.name}: ${error.message}`);
  }
}

/**
   * Converts the given data to a string, if it's not one already
   *
   * @param {string|object} data - A string containing JSON/YAML/XML/etc, or other type of data
   * @returns {string} - Returns the data as a string
   */
function stringify(data) {
  if (typeof Node !== 'undefined' && data instanceof Node) {
    var xs = new XMLSerializer();
    return xs.serializeToString(data);
  } else
  if (typeof data !== 'string') {
    return JSON.stringify(data);
  } else
  {
    return data;
  }
}

/**
   * Returns the appropriate format for the given data
   *
   * @param {string} data - A string containing JSON/YAML/XML/etc.
   * @returns {object} - A format object with a `convert` method
   */
function determineDataFormat(data) {
  for (let format of __WEBPACK_IMPORTED_MODULE_1__formats__["a" /* default */]) {
    try {
      if (format.isFormat(data)) {
        // We found a match, so stop looping and return it
        return format;
      }
    }
    catch (error) {
      // The data is not supported by this format, so just try the next one
    }
  }
}

/**
    * Cleans the collection object, This function decides whether to overwrite or replace in case of a conflict.
    *
    * @param {Collection~definition} collection - The collection to import
    *
    * @return {object} collection - cleaned up collection
    */
function purifyCollectionData(collection) {

  // remove all meta properties from collection
  // instead of deleting all the meta properties, we should whitelist collection V1 schema properties
  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(COLLECTION_META_PROPS, function (metaProp) {
    delete collection[metaProp];
  });

  collection = Object(__WEBPACK_IMPORTED_MODULE_3__common_utils_collection_tree__["a" /* fixEntityOrdersInCollection */])(collection);

  collection.requests = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(collection.requests, purifyRequestData);

  // sanitize enabled-disabled fields
  _sanitizeCollectionVariables(collection);

  // Sanitize each request and it's responses too
  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(collection.requests, request => {
    _sanitizeRequest(request);
  });

  if (!collection.name || collection.name.trim() == '') {
    collection.name = 'New Collection';
  }

  // this.setSelfOwnerForCollection(collection);

  // set Child reference for folders and requests
  // Importing v2 to v1
  // The parent child relationship is available through folder_order and order property,
  // But the child to parent relation ship is not available, that is entity.folder is unavailable.

  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(collection.folders, folder => {
    let order = folder.order,
    folder_order = folder.folders_order,
    folders = collection.folders,
    requests = collection.requests;

    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(order, reqId => {
      let req = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(requests, __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.matchesProperty('id', reqId));
      if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(req)) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.assign(req, { folder: folder.id });
      } else {
        console.log('Something wrong in collection data');
      }
    });

    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(folder_order, folderId => {
      let matchedFolder = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.find(folders, __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.matchesProperty('id', folderId));
      if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(matchedFolder)) {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.assign(matchedFolder, { folder: folder.id });
      } else {
        console.log('Something wrong in collection data');
      }
    });
  });

  return collection;
}

/**
   *
   */
function purifyRequestData(request) {
  // Normalize to create th new properties and
  // then remove the deprecated properties
  // Normalizer will prefer new propertites.
  __WEBPACK_IMPORTED_MODULE_2__utils_util__["a" /* default */].normalizeRequest(request);

  request.method || (request.method = 'GET');

  if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(request.headerData)) {
    // convert header string format to array format and set to headerData.
    request.headerData = __WEBPACK_IMPORTED_MODULE_2__utils_util__["a" /* default */].unpackHeaders(request.headers) || [];
  }

  if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(request.pathVariableData)) {
    // convert { k1: v1, k2: v2 } format to [ { key: k1, value: v1 }, { key: k2, value: v2 }] format
    request.pathVariableData = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.keys(request.pathVariables), k => {
      return {
        key: k,
        value: request.pathVariables[k] };

    });
  }
  if (!__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isEmpty(request.pathVariableData)) {
    // convert [{key: k1, value: v1, description: {content:c type:t}}] to [{key: k1, value: v1, description: c}]
    request.pathVariableData = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(request.pathVariableData, pv => {
      return Object.assign({}, pv, { description: pv.description && pv.description.content ? pv.description.content : pv.description });
    });
  }

  if (request.dataMode === 'raw' && request.rawModeData) {
    request.data = request.rawModeData;
  }

  if (Array.isArray(request.responses)) {
    for (let i = 0; i < request.responses.length; i++) {
      // convert response.requestObject from string to object
      if (__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.has(request.responses[i], 'requestObject') && typeof request.responses[i].requestObject === 'string') {
        let parsedObject = null;

        // Now we need to try parse this value as object and send it to db.
        try {
          parsedObject = JSON.parse(request.responses[i].requestObject);
        }
        catch (e) {
          // no-op here
        } finally
        {
          // Value should be a valid json object or null
          request.responses[i].requestObject = parsedObject;
        }
      }

      let sanitizeResult = sanitizeWithRules(request.responses[i], responseSanitizeRules);
      if (sanitizeResult.isSuccess) {
        request.responses[i] = sanitizeResult.obj;
      } else {
        delete request.responses[i];
      }
    }
  }

  delete request.createdAt;
  delete request.updatedAt;

  return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.omit(request, DEPRECATED_PROPS);
}

/**
   * @description Sanitize object with rules
   *
   * @param {Object} obj - the object that needs to be sanitized
   * @param {Object} rules = sanitization rules
   *
   * @return {Object} sanitized object + status
   */
function sanitizeWithRules(obj, rules) {
  let isSuccess = true;

  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.each(rules, (rule, property) => {
    if (rule === false) {
      delete obj[property];
      return;
    }

    let isMatchingType = false;
    switch (rule.type) {
      case 'string':
        isMatchingType = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isString(obj[property]);
        break;
      case 'object':
        isMatchingType = typeof obj[property] === 'object' && !Array.isArray(obj[property]);
        break;
      case 'array':
        isMatchingType = Array.isArray(obj[property]);
        break;}


    if (!isMatchingType) {
      if (rule.invalidate) isSuccess = false;

      obj[property] = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(rule.defaultsTo) ? rule.defaultsTo() : rule.defaultsTo;
    }
  });

  return { obj, isSuccess };
}

/***/ }),

/***/ 3593:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = importFileFromUrl;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controllers_Importer__ = __webpack_require__(649);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_util__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_HttpService__ = __webpack_require__(173);





/**
                                                    * Fetches resources at a given link and imports the resource by guessing the format.
                                                    * Called by the Import Modal (Import URL)
                                                    *
                                                    * @param {URL} url - URL of the resource
                                                    * @param {Function} callback - The function that will be called once the resource is imported
                                                    *
                                                    * @fires Mediator#failedCollectionImport
                                                    *
                                                    * @see Collections#importData
                                                    */
function importFileFromUrl(url, callback) {
  __WEBPACK_IMPORTED_MODULE_3__utils_HttpService__["a" /* default */].request(url).then(({ body }) => {
    try {
      __WEBPACK_IMPORTED_MODULE_1__controllers_Importer__["a" /* default */].importData(body, { origin: 'import/link', link: url }).
      then(() => {
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback(null, body);
      });
    }
    catch (e) {
      if (e == 'Could not parse') {
        pm.mediator.trigger('failedCollectionImport', 'format not recognized');
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback('format not recognized');
      } else
      {
        pm.mediator.trigger('failedCollectionImport', 'Could not import: ' + e);
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback('Could not import: ' + e);
      }
    }
  }).catch(({ error }) => {
    console.log('Error response while importing: ', error);
    pm.mediator.trigger('failedCollectionImport', 'Error response received from URL. Check the console for more.');
    __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback('Error response received from URL. Check the console for more.');
  });
}

/***/ }),

/***/ 3594:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = importFiles;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controllers_Importer__ = __webpack_require__(649);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_async__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_async___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_async__);




/**
                            * Imports a list of files, guessing each file's format and importing as required.
                            * Called by the Import Modal (Import File)
                            *
                            * @param {File[]} files - The files to import
                            *
                            * @fires Mediator#failedCollectionImport
                            *
                            * @see Collections#importData
                            */
function importFiles(files) {

  __WEBPACK_IMPORTED_MODULE_2_async___default.a.eachSeries(files, (file, next) => {
    let reader = new FileReader();

    // Closure to capture the file information.
    reader.onload = function (e) {
      var data = e.currentTarget.result;
      __WEBPACK_IMPORTED_MODULE_1__controllers_Importer__["a" /* default */].importData(data, { origin: 'import/file' }, next);
    };

    // Read in the image file as a data URL.
    reader.readAsText(file);
  });

}

/***/ }),

/***/ 3595:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (immutable) */ __webpack_exports__["a"] = importFolder;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_lodash___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_lodash__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__controllers_Importer__ = __webpack_require__(649);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_services_AnalyticsService__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_async__ = __webpack_require__(55);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_async___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_async__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__postman_raml_to_postman__ = __webpack_require__(1520);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__postman_raml_to_postman___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__postman_raml_to_postman__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_raml_parser__ = __webpack_require__(942);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_raml_parser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_raml_parser__);







/**
                                       * Imports a file system folder.
                                       *
                                       * @param {File[]} allFiles   - The files that need to be imported
                                       * @param {String} rootPath   - The root path of uploaded data, e.g: /Uber or /my-folder. The slash at the beginning is important
                                       * @param {Function} callback - The function that will be called after the imported resources are written to IndexedDB
                                       *
                                       * @fires Mediator#failedCollectionImport
                                       */
function importFolder(allFiles, rootPath, callback) {
  var uploadedData = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.zipObject(__WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(allFiles, 'fileName'), __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.map(allFiles, 'content')),
  rootFiles = __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.filter(allFiles, { isRoot: true }),
  reader;

  reader = new __WEBPACK_IMPORTED_MODULE_5_raml_parser___default.a.FileReader(function (path) {
    return new Promise(function (resolve, reject) {
      var decodedFullPath = decodeURIComponent(path);
      if (uploadedData.hasOwnProperty(decodedFullPath)) {
        resolve(uploadedData[decodedFullPath]);
      } else
      if (uploadedData.hasOwnProperty(rootPath + path)) {
        resolve(uploadedData[rootPath + path]);
      } else
      {
        reject(new Error('Unable to find file ' + path + ' in uploaded data'));
      }
    });
  });

  // Import RAML files, if any
  __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.forEach(rootFiles, function (rootFile) {
    __WEBPACK_IMPORTED_MODULE_5_raml_parser___default.a.loadFile(rootFile.fileName, { reader: reader }).
    then(function (result) {
      __WEBPACK_IMPORTED_MODULE_4__postman_raml_to_postman___default.a.parseRaw(result, function (op, env) {
        __WEBPACK_IMPORTED_MODULE_2__modules_services_AnalyticsService__["a" /* default */].addEvent('collection', 'create', 'raml');

        // @todo Akhil need to remove this
        // pm.collections.importCollectionData(op);
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback(null, op);
      }, function (errorMessage) {
        pm.toasts.error('Error while importing RAML ' + errorMessage);
        __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback('RAML: ' + errorMessage);
      });
    }).
    catch(function (e) {
      pm.logger.error(e);
      pm.mediator.trigger('failedCollectionImport', 'Error importing RAML API: ' + e);
      return __WEBPACK_IMPORTED_MODULE_0_lodash___default.a.isFunction(callback) && callback(e);
    });
  });

  if (rootFiles.length === 0) {
    __WEBPACK_IMPORTED_MODULE_3_async___default.a.eachOfSeries(uploadedData, (content, fileName, next) => {
      if (!/^.*\.postman_collection$|^.*\.postman_environment$|^.*\.json$/ig.test(fileName)) {
        return next();
      }

      // May be worth importing
      __WEBPACK_IMPORTED_MODULE_1__controllers_Importer__["a" /* default */].importData(content, { origin: 'import/folder' }, next);
    });
  }
}

/***/ }),

/***/ 3596:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(_) {/* harmony export (immutable) */ __webpack_exports__["a"] = saveEntity;
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__models_services_filesystem__ = __webpack_require__(539);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__modules_export_index__ = __webpack_require__(3484);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__modules_services_AnalyticsService__ = __webpack_require__(30);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__export_all__ = __webpack_require__(1423);





const SUPPORTED_FILE_TYPES = {
  json: 'application/json' },

TAB = '\t',
COLLECTION = 'collection',
ENVIRONMENT = 'environment',
GLOBALS = 'globals',
DEFAULT_FILE_NAME_EXT = '.json';

/**
                                  * Saves the exported entity to a file.
                                  * Will show a native prompt for the location to save the exported entity
                                  * @param {Object} criteria
                                  * @param {Object} options
                                  * @param {String} options.type
                                  * @param {String} options.inputVersion
                                  * @param {String} options.outputVersion
                                  */
function saveEntity(criteria, options = {}) {
  let model = options.type,
  exportVersion = _.get(options, 'outputVersion', '1.0.0'),
  exportedData,
  fileType,
  fileName;

  if (!model) {
    console.warn(`Unsupported type '${model}' for exporting`);
    return;
  }

  // This will fetch the entity from db, sanitize and transform it to the exportable format
  return __WEBPACK_IMPORTED_MODULE_1__modules_export_index__["a" /* default */].exportSingle(model, criteria, options)

  // check if the entity was exported correctly
  .then(data => {
    if (!(data && SUPPORTED_FILE_TYPES[data.type] && data[data.type])) {
      console.warn('Invalid data or unsupported file type', data);
      throw new Error('saveEntity: invalid data received');
    }

    return data;
  })

  // cache the data, file type and file name
  .then(data => {
    exportedData = data;
    fileType = SUPPORTED_FILE_TYPES[exportedData.type];
    fileName = _.get(exportedData, 'meta.fileName', model + DEFAULT_FILE_NAME_EXT);
  })

  // serialize the entity
  .then(() => {
    return JSON.stringify(exportedData.json, null, TAB);
  })

  // prompt the user to save the entity to the file system
  .then(serializedData => {
    return new Promise((resolve, reject) => {
      Object(__WEBPACK_IMPORTED_MODULE_0__models_services_filesystem__["b" /* saveAndOpenFile */])(fileName, serializedData, fileType, (err, state) => {
        if (err) {
          console.warn('Error while saving the exported entity', err);
          reject(err);
          return;
        }

        resolve(state);
      });
    });
  })

  // show the success notification and send analytics event
  .then(state => {
    if (state !== __WEBPACK_IMPORTED_MODULE_3__export_all__["a" /* EXPORT_STATE */].SUCCESS) {
      return;
    }

    switch (model) {
      case COLLECTION:
        __WEBPACK_IMPORTED_MODULE_2__modules_services_AnalyticsService__["a" /* default */].addEvent(COLLECTION, 'download', exportVersion, null, { collection_id: criteria.id });
        pm.toasts.success('Your collection was exported successfully.');
        break;

      case ENVIRONMENT:
        __WEBPACK_IMPORTED_MODULE_2__modules_services_AnalyticsService__["a" /* default */].addEvent(model, 'download');
        pm.toasts.success('Your environment was exported successfully.');
        break;

      case GLOBALS:
        __WEBPACK_IMPORTED_MODULE_2__modules_services_AnalyticsService__["a" /* default */].addEvent(model, 'download');
        pm.toasts.success('Your globals were exported successfully.');
        break;}

  }).

  catch(err => {
    pm.toasts.error('Unable to export this entity. Please check the DevTools.');
    console.warn('Error while exporting an entity', criteria, options, err);
  });
}
/* WEBPACK VAR INJECTION */}.call(__webpack_exports__, __webpack_require__(0)))

/***/ })

});